<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Canon Recipe Generator Pro (v11.4 ClassicNeg Matrix)</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#94a3b8; --text:#f1f5f9;
      --line:#263456; --brand:#ff3f34; --ok:#10b981; --warn:#f59e0b;
      --cyan:#06b6d4; --black:#020617; --radius: 16px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0; font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Noto Sans KR", system-ui, sans-serif;
      background: radial-gradient(1100px 520px at 15% 0%, rgba(255,63,52,0.16), transparent 60%),
                  radial-gradient(900px 520px at 85% 0%, rgba(6,182,212,0.16), transparent 60%),
                  var(--bg);
      color:var(--text);
      padding: 16px;
      line-height: 1.5;
    }
    .app{ max-width: 1120px; margin: 0 auto; padding-bottom: 48px; }
    .header{ display:flex; flex-direction:column; gap:10px; margin-bottom:18px; }
    .title h1{ margin:0; font-size:20px; letter-spacing:-0.4px; }
    .title p{ margin:6px 0 0; color:var(--muted); font-size:13px; word-break: keep-all; }

    .badges{ display:flex; gap:8px; flex-wrap:wrap; }
    .badge{
      border:1px solid var(--line); background: rgba(18,26,51,0.7);
      padding:6px 12px; border-radius:999px; font-size:11px; font-weight:800;
      display:flex; gap:6px; align-items:center;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted); }
    .dot.ok{ background:var(--ok); } .dot.warn{ background:var(--warn); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 920px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background: rgba(18,26,51,0.86);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 12px 26px rgba(0,0,0,0.34);
      overflow:hidden;
    }
    .card-h{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--line);
      background: rgba(2,6,23,0.35);
    }
    .card-h strong{ font-size:14px; }
    .step{
      font-size:12px; color:var(--muted);
      padding:4px 10px; border:1px solid var(--line);
      border-radius:999px; background: rgba(2,6,23,0.35);
      font-weight:900;
      white-space:nowrap;
    }
    .card-b{ padding:16px; }

    .seg{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:14px;
      margin-bottom:12px;
    }
    .seg .label{ color:var(--muted); font-size:12px; font-weight:900; margin-bottom:8px; }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:10px 14px;
      border-radius:999px;
      font-size:13px;
      font-weight:900;
      cursor:pointer;
      transition:0.15s;
      flex: 1 1 auto;
      text-align:center;
      user-select:none;
    }
    .chip.active{
      border-color: var(--brand);
      background: rgba(255,63,52,0.15);
      color: #ff8b86;
      box-shadow: 0 0 0 2px rgba(255,63,52,0.10) inset;
    }

    .uploader{ display:flex; flex-direction:column; gap:12px; }
    .drop{
      border:2px dashed var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:18px;
      transition: 0.15s;
      cursor:pointer;
      min-height: 140px;
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      align-items:center;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .drop.dragover{ border-color: var(--ok); background: rgba(16,185,129,0.10); }
    .drop .label{ font-weight:950; font-size:14px; }
    .drop .hint{ color:var(--muted); font-size:12px; line-height:1.45; }
    .drop input{ display:none; }
    .thumb{
      width:100%;
      display:none;
      border-radius:10px;
      max-height:140px;
      object-fit:cover;
      border:1px solid var(--line);
    }
    .filename{
      font-size:12px;
      color: var(--cyan);
      font-weight:900;
      display:none;
      word-break:break-all;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 12px; }
    .kv{
      flex:1;
      display:flex; justify-content:space-between; align-items:center;
      font-size:13px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:10px 12px;
      border-radius:12px;
      gap:10px;
    }
    .kv b{ font-weight:950; }
    .kv select, .kv input[type="range"]{
      width: 54%;
      background: rgba(18,26,51,0.9);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-weight:800;
    }
    .kv .val{ color: var(--cyan); font-weight:950; white-space:nowrap; }

    .btn{
      border:0;
      border-radius:14px;
      padding:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      font-size:14px;
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
    }
    .btn.primary{ background: var(--brand); color:white; }
    .btn.primary:active{ filter: brightness(0.92); transform: scale(0.985); }
    .btn.ghost{ background: rgba(2,6,23,0.25); border:1px solid var(--line); color: var(--text); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none !important; }

    .mini{
      color:var(--muted);
      font-size:12px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:12px;
      word-break: keep-all;
      line-height: 1.55;
    }

    .tabs{
      display:flex; gap:8px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:8px;
      border-radius:14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .tabs .left{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:8px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      user-select:none;
    }
    .tab.active{
      border-color: var(--ok);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(16,185,129,0.12) inset;
    }
    .tabHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(2,6,23,0.35);
      white-space:nowrap;
    }

    .summaryCard{ display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px; }
    .pill{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:14px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .pill .k{ color:var(--muted); font-size:12px; margin-bottom:4px; }
    .pill .v{ font-weight:950; font-size: 14px; line-height:1.4; }
    .pill .v.ok{ color:var(--ok); } .pill .v.warn{ color:var(--warn); } .pill .v.cyan{ color:var(--cyan); }

    .report{
      margin-top:12px;
      background: var(--black);
      color: var(--ok);
      border:1px solid rgba(16,185,129,0.32);
      border-radius:14px;
      padding:16px;
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size:13px;
      overflow-x:auto;
      line-height:1.62;
    }

    .spinner{
      width:18px; height:18px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
      display:none;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }
    .hide{ display:none !important; }

    /* Preview */
    .pvWrap{ display:flex; flex-direction:column; gap:12px; }
    #previewCanvas{
      width:100%;
      display:block;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      max-height: 520px;
      touch-action: none;
      cursor: ew-resize;
    }
    .pvLegend{
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      color:var(--muted); font-size:12px; font-weight:900;
    }
    .pvLegend b{ color: var(--text); }
    .pvHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .pvHint .badge2{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.7);
      padding:6px 10px;
      border-radius:999px;
      font-size:11px;
      font-weight:950;
      color: var(--cyan);
    }
    .pvActions{ display:flex; gap:10px; flex-wrap:wrap; }
    .pvActions .btn{ width:auto; padding:10px 12px; font-size:12px; border-radius:12px; }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <h1>ğŸ“· Canon Recipe Generator Pro <span style="color:var(--cyan); font-size:14px;">v11.4 ClassicNeg Matrix</span></h1>
        <p>
          âœ… <b>Classic Negative: ToneCurve + RGB Cross-talk + HSL ë³€í™˜ ë§¤íŠ¸ë¦­ìŠ¤</b> ì ìš©(í”„ë¦¬ë·° í’ˆì§ˆâ†‘)<br/>
          âœ… ë¶„ì„ ê²°ê³¼(PSE 6ì¶•)ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€ + <b>í”„ë¦¬ë·°ì—ì„œë§Œ</b> ClassicNeg â€œí•„ë¦„ì‹ í¬ë¡œìŠ¤íƒ€í¬/ìƒ‰í‹€ì–´ì§â€ì„ ì¶”ê°€ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.
        </p>
      </div>
      <div class="badges">
        <div class="badge"><span id="dotAI" class="dot warn"></span><span id="aiText">AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)</span></div>
        <div class="badge"><span id="dotP" class="dot"></span> ë¯¸ë¦¬ë³´ê¸°(ì„ íƒ)</div>
        <div class="badge"><span id="dotO" class="dot"></span> ì›ë³¸(ì„ íƒ)</div>
        <div class="badge"><span id="dotR" class="dot"></span> íƒ€ê²Ÿ(í•„ìˆ˜)</div>
      </div>
    </div>

    <div class="grid">

      <!-- Preview -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <strong>PREVIEW. ë‚´ ìºë…¼ ì‚¬ì§„ì— ì ìš©í•´ë³´ê¸°</strong>
          <span class="step">ë“œë˜ê·¸ Split</span>
        </div>
        <div class="card-b">
          <div class="pvWrap">
            <div class="seg">
              <div class="label">ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„(ë‚´ ìºë…¼ JPG)</div>
              <div class="uploader">
                <div class="drop" id="dropPrev">
                  <div class="label">ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„ ì—…ë¡œë“œ</div>
                  <div class="hint">í”„ë¦¬ì…‹/ë ˆì‹œí”¼ë¥¼ ì ìš©í•´ Before/Afterë¥¼ í™•ì¸í•©ë‹ˆë‹¤.</div>
                  <input id="prevFile" type="file" accept="image/*"/>
                  <img id="thumbPrev" class="thumb" alt="preview"/>
                  <div id="filePrev" class="filename"></div>
                </div>
              </div>

              <div class="mini" style="margin-top:12px;">
                âœ… <b>Split ì¡°ì ˆ:</b> ì•„ë˜ í”„ë¦¬ë·° ì´ë¯¸ì§€ ìœ„ì—ì„œ ì¢Œìš°ë¡œ <b>ë“œë˜ê·¸</b>í•˜ì„¸ìš”.<br/>
                (ì¢Œ: ì›ë³¸ / ìš°: ì ìš© ê²°ê³¼)
              </div>
            </div>

            <div class="row">
              <div class="kv">
                <b>ë¯¸ë¦¬ë³´ê¸° ì†ŒìŠ¤</b>
                <select id="previewMode">
                  <option value="preset" selected>í”„ë¦¬ì…‹ë§Œ ì ìš©(ë¹ ë¦„)</option>
                  <option value="recipe">ë§ˆì§€ë§‰ ë¶„ì„ ë ˆì‹œí”¼ ì ìš©(ì •ë°€)</option>
                </select>
                <span class="val" id="previewModeLabel">PRESET</span>
              </div>
              <div class="kv">
                <b>ë¯¸ë¦¬ë³´ê¸° í•´ìƒë„</b>
                <select id="previewDim">
                  <option value="720">720px (ìµœê³ ì†)</option>
                  <option value="1024" selected>1024px (ê¶Œì¥)</option>
                  <option value="1280">1280px (ì •ë°€)</option>
                </select>
                <span class="val">Render</span>
              </div>
            </div>

            <div class="row">
              <div class="kv">
                <b>ì ìš© ê°•ë„</b>
                <input id="previewStrength" type="range" min="0" max="100" value="70" />
                <span class="val" id="previewStrengthLabel">70%</span>
              </div>
              <div class="kv">
                <b>Split ìœ„ì¹˜</b>
                <span class="val" id="splitLabel">50%</span>
                <span class="val" style="color:var(--muted); font-weight:900;">(ë“œë˜ê·¸)</span>
              </div>
            </div>

            <div class="pvHint">
              <div class="badge2" id="pvMeta">-</div>
              <div class="pvActions">
                <button id="btnPreviewApply" class="btn ghost" disabled>ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸</button>
                <button id="btnPreviewReset" class="btn ghost" disabled>â†”ï¸ Split 50%</button>
                <button id="btnPreviewSave" class="btn ghost" disabled>â¬‡ï¸ PNG ì €ì¥</button>
              </div>
            </div>

            <canvas id="previewCanvas"></canvas>
            <div class="pvLegend">
              <div>ì¢Œì¸¡ <b>ì›ë³¸</b></div>
              <div>ìš°ì¸¡ <b>ì ìš© ê²°ê³¼</b></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 1 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 1. ì‚¬ì§„ ë„£ê¸°</strong>
          <span class="step">1/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ë°©ì‹</div>
            <div class="chips">
              <div class="chip active" data-shot="one" onclick="setShot('one')">1ì¥ ëª¨ë“œ (íƒ€ê²Ÿë§Œ)</div>
              <div class="chip" data-shot="two" onclick="setShot('two')">2ì¥ ëª¨ë“œ (ì›ë³¸+íƒ€ê²Ÿ)</div>
            </div>
          </div>

          <div class="uploader">
            <div class="drop hide" id="dropOrig">
              <div class="label">ì›ë³¸ (ì¶”ì²œ: Standard/Neutral)</div>
              <div class="hint">ìºë…¼ í‘œì¤€/ë‰´íŠ¸ëŸ´ë¡œ ì°ì€ ì›ë³¸ ì‚¬ì§„</div>
              <input id="origFile" type="file" accept="image/*"/>
              <img id="thumbOrig" class="thumb" alt="orig"/>
              <div id="fileOrig" class="filename"></div>
            </div>

            <div class="drop" id="dropRef">
              <div class="label">íƒ€ê²Ÿ (ì›í•˜ëŠ” ìƒ‰ê°)</div>
              <div class="hint">
                ë§Œë“¤ê³  ì‹¶ì€ ì˜í™”/í•„ë¦„ ëŠë‚Œì˜ ì°¸ê³  ì‚¬ì§„.<br/>
                <b>ì£¼ì˜:</b> iPhone <b>HEIC</b>ëŠ” <b>JPGë¡œ ë³€í™˜</b> í›„ ì—…ë¡œë“œ ê¶Œì¥.
              </div>
              <input id="refFile" type="file" accept="image/*"/>
              <img id="thumbRef" class="thumb" alt="ref"/>
              <div id="fileRef" class="filename"></div>
            </div>
          </div>

          <div class="mini" style="margin-top:12px;">
            2ì¥ ëª¨ë“œê°€ â€œì§„ì§œ ë§¤ì¹­â€ì…ë‹ˆë‹¤. (ê°€ëŠ¥í•˜ë©´ 2ì¥ ì¶”ì²œ)
          </div>
        </div>
      </div>

      <!-- Step 2 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 2. ì„¤ì •</strong>
          <span class="step">2/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ëª¨ë“œ (í„°ì¹˜)</div>
            <div class="chips">
              <div class="chip active" data-mode="auto" onclick="setMode('auto')">AI ìë™</div>
              <div class="chip" data-mode="portrait" onclick="setMode('portrait')">ì¸ë¬¼</div>
              <div class="chip" data-mode="landscape" onclick="setMode('landscape')">í’ê²½</div>
              <div class="chip" data-mode="snap" onclick="setMode('snap')">ìŠ¤ëƒ…</div>
              <div class="chip" data-mode="night" onclick="setMode('night')">ì•¼ê²½</div>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í•´ìƒë„</b>
              <select id="maxDim">
                <option value="1024" selected>1024px (ê¶Œì¥)</option>
                <option value="1280">1280px (ì •ë°€)</option>
              </select>
              <span class="val">ë¦¬ì‚¬ì´ì¦ˆ ë¶„ì„</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>AI ê°•í™”(ì„ íƒ)</b>
              <select id="aiBoost">
                <option value="off" selected>OFF (ë¹ ë¦„)</option>
                <option value="coco">ON: COCO-SSD (ì •í™•â†‘, ë¬´ê±°ì›€)</option>
              </select>
              <span class="val" id="aiBoostLabel">FAST</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Specific Points</b>
              <select id="specPoints">
                <option value="on" selected>ON (ê¶Œì¥)</option>
                <option value="off">OFF</option>
              </select>
              <span class="val" id="specPointsLabel">ON</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Look Overlay</b>
              <select id="fujiPreset">
                <option value="off" selected>Off (ë¶„ì„ë§Œ)</option>
                <optgroup label="Fuji 5th Gen Looks">
                  <option value="classic_chrome">Fuji_ClassicChrome</option>
                  <option value="classic_negative">Fuji_ClassicNegative (Matrix/HSL ì ìš©)</option>
                  <option value="reala_ace">Fuji_RealaAce</option>
                  <option value="nostalgic_negative">Fuji_NostalgicNeg</option>
                  <option value="provia">Fuji_Provia</option>
                  <option value="astia">Fuji_Astia</option>
                  <option value="velvia">Fuji_Velvia</option>
                  <option value="eterna">Fuji_Eterna</option>
                </optgroup>
                <optgroup label="Ricoh GR Looks">
                  <option value="gr_positive">GR_Positive</option>
                </optgroup>
              </select>
              <span class="val" id="presetLabel">OFF</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í”„ë¦¬ì…‹ ê°•ë„</b>
              <input id="presetStrength" type="range" min="0" max="100" value="50" />
              <span class="val" id="strengthLabel">50%</span>
            </div>
          </div>

          <button id="btnAnalyze" class="btn primary" onclick="analyzeAll()" disabled>
            <span id="btnText">ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”</span>
            <span id="spin" class="spinner"></span>
          </button>

          <div class="mini" style="margin-top:12px;">
            âš ï¸ <b>Classic Negative Matrix/HSL</b>ëŠ” Canon PSEì— ì§ì ‘ ì…ë ¥ ë¶ˆê°€í•œ â€œí•„ë¦„ì‹ ì²˜ë¦¬â€ì´ë¯€ë¡œ, <b>í”„ë¦¬ë·° ì •í™•ë„</b>ë¥¼ ìœ„í•´ ì•± ë‚´ë¶€ ë Œë”ì—ì„œë§Œ ì ìš©í•©ë‹ˆë‹¤.<br/>
            (ë¶„ì„ ê²°ê³¼ ë ˆì‹œí”¼ëŠ” PSE 6ì¶•/ì»¤ë¸Œë¡œ ìµœëŒ€í•œ ê·¼ì‚¬í•©ë‹ˆë‹¤.)
          </div>
        </div>
      </div>

      <!-- Step 3 -->
      <div class="card hide" style="grid-column: 1 / -1;" id="resultCard">
        <div class="card-h">
          <strong>STEP 3. ê²°ê³¼</strong>
          <span class="step" style="color:var(--ok); border-color:var(--ok);">ì™„ë£Œ</span>
        </div>
        <div class="card-b">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; gap:10px;">
              <button class="btn ghost" onclick="copySummary()" style="flex:1;">ğŸ“‹ ìš”ì•½ ë³µì‚¬</button>
              <button class="btn ghost" onclick="copyFull()" style="flex:1;">ğŸ“‹ ì „ì²´ ë³µì‚¬</button>
            </div>
          </div>

          <div class="tabs">
            <div class="left">
              <div class="tab active" data-tab="sum" onclick="setTab('sum')">ìš”ì•½ ë³´ê¸°</div>
              <div class="tab" data-tab="full" onclick="setTab('full')">ì „ì²´ ë³´ê¸°</div>
            </div>
            <div class="tabHint" id="tabHint">ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.</div>
          </div>

          <div class="summaryCard" id="summaryBox">
            <div class="pill">
              <div>
                <div class="k">ë¶„ì„ ëª¨ë“œ</div>
                <div class="v cyan" id="sumMode">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì¶”ì²œ ë² ì´ìŠ¤</div>
                <div class="v ok" id="sumBase">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">ê¸°ë³¸ ì¡°ì •</div>
                <div class="v" id="sumBasic">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ë¸”ë™ ë¦¬í”„íŠ¸</div>
                <div class="v" id="sumLift">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">WB ì œì•ˆ</div>
                <div class="v cyan" id="sumWB">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì‹ ë¢°ë„</div>
                <div class="v" id="sumWBRel">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">í†¤ ì»¤ë¸Œ (IN â†’ OUT)</div>
                <div class="v" id="sumCurve" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">6ìƒ‰ì¶• (H / S / L)</div>
                <div class="v" id="sumColors" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill" id="specPill">
              <div style="width:100%;">
                <div class="k">Specific Colors Points (ìš”ì•½)</div>
                <div class="v" id="sumSpecific" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="mini" id="sumExtra">-</div>
          </div>

          <div id="fullBox" class="hide">
            <div id="reportBox" class="report"></div>
          </div>

          <canvas id="workCanvas" class="hide"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* =========================================================
   State
========================================================= */
let shotMode = "one";
let userMode = "auto";
let viewTab  = "sum";

let origFileState = null;
let refFileState  = null;
let prevFileState = null;

let summaryText = "";
let fullText = "";

let lastRecipe = null;

let worker = null;
let workerUrl = null;

let faceModel = null;
let classifyModel = null;
let cocoModel = null;
let aiState = "idle";
let aiStatusText = "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)";

let split01 = 0.50;
let previewCache = null;
let previewBusy = false;

/* =========================================================
   Classic Negative (ê³µì‹ì‹ ê¸°ë°˜ í”„ë¦¬ë·° ì „ìš© FX)
   - ToneCurve LUT: [0,64,128,192,255] -> [10,45,125,205,240]
   - RGB Cross-talk matrix
   - Global sat mul (HSV S * 0.85 ê·¼ì‚¬)
   - HSL Delta matrix (ì§€ì—­ë³„ Î”H/Î”S/Î”L)
========================================================= */
const CN_FORMULA = {
  curve5: {0:10, 64:45, 128:125, 192:205, 255:240},
  rgbMatrix: [
    [ 1.05, -0.10,  0.05],
    [ 0.00,  0.90,  0.10],
    [-0.05,  0.15,  0.90],
  ],
  satMul: 0.85,
  // Î”H degree, Î”S%, Î”L%  (S/L are ratio-based)
  hslRegions: [
    {name:"Red",          h0:340, h1:360, dH:+5,  dS:-0.15, dL:-0.05},
    {name:"Red",          h0:0,   h1:20,  dH:+5,  dS:-0.15, dL:-0.05},
    {name:"OrangeSkin",   h0:20,  h1:45,  dH:-2,  dS:-0.10, dL: 0.00},
    {name:"Green",        h0:80,  h1:150, dH:+18, dS:-0.25, dL:-0.15},
    {name:"Blue",         h0:210, h1:280, dH:-10, dS:-0.10, dL:-0.10},
  ]
};

/* =========================================================
   Presets
   - NOTE: Classic NegativeëŠ” â€œPSE ê·¼ì‚¬ê°’ + (í”„ë¦¬ë·° ì „ìš© FX)â€ë¥¼ ë™ì‹œì— ìš´ìš©
========================================================= */
const FUJI_PRESETS = {
  off: null,

  provia: {
    name:"Fuji_Provia",
    contrast:+1, sat:+1, tone:0,
    curve5:{0:2,64:66,128:128,192:194,255:252},
    axes:{ R:{H:0,S:0,L:0},Y:{H:0,S:0,L:0},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-2,L:0},M:{H:0,S:0,L:0} }
  },

  astia:  {
    name:"Fuji_Astia",
    contrast:-1, sat:+1, tone:+1,
    curve5:{0:8,64:78,128:132,192:198,255:255},
    axes:{ R:{H:+2,S:-6,L:+6},Y:{H:-2,S:-6,L:+6},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-6,L:0},M:{H:0,S:0,L:0} }
  },

  // Classic Chrome (êµ¬ë¶„ ìœ ì§€)
  classic_chrome: {
    name: "Fuji_ClassicChrome",
    contrast: +2,
    sat: -2,
    tone: -1,
    curve5: {0:12, 64:74, 128:126, 192:184, 255:242},
    axes:{
      R:{H:+2,  S:-8,  L:+3},
      Y:{H:-2,  S:-14, L:+3},
      G:{H:+4,  S:-10, L:-2},
      C:{H:-6,  S:-6,  L:-2},
      B:{H:-8,  S:-10, L:-4},
      M:{H:+2,  S:-12, L: 0},
    }
  },

  // Classic Negative (PSE ê·¼ì‚¬ + í”„ë¦¬ë·° FX íƒ‘ì¬)
  classic_negative: {
    name: "Fuji_ClassicNegative",
    contrast: +3,
    sat: -1,
    tone: -2,
    // âœ… ToneCurveë¥¼ ê³µì‹ì‹ LUTë¡œ ë§ì¶¤
    curve5: CN_FORMULA.curve5,
    axes:{
      R:{H:-4,  S:-6,  L:+6},
      Y:{H:-6,  S:-10, L:+8},
      G:{H:+10, S:+6,  L:-10},
      C:{H:+8,  S:+10, L:-10},
      B:{H:-4,  S:-6,  L:-10},
      M:{H:+6,  S:-10, L:+2},
    },
    // âœ… í”„ë¦¬ë·° ì „ìš© FX
    previewFx: {
      rgbMatrix: CN_FORMULA.rgbMatrix,
      satMul: CN_FORMULA.satMul,
      hslRegions: CN_FORMULA.hslRegions
    }
  },

  reala_ace: {
    name:"Fuji_RealaAce",
    skinProtect:true,
    contrast:+2, sat:+1, tone:+1,
    curve5:{0:4,64:68,128:130,192:200,255:248},
    axes:{ R:{H:0,S:-4,L:+3}, Y:{H:0,S:-6,L:+3}, G:{H:0,S:-2,L:0}, C:{H:+2,S:0,L:-2}, B:{H:+2,S:-2,L:-4}, M:{H:0,S:-2,L:0} }
  },

  nostalgic_negative: {
    name:"Fuji_NostalgicNeg",
    contrast:+1, sat:-1, tone:+2,
    curve5:{0:14,64:84,128:136,192:194,255:244},
    axes:{ R:{H:-4,S:+2,L:+6},Y:{H:-6,S:+4,L:+8},G:{H:+4,S:-8,L:0},C:{H:+6,S:-8,L:-2},B:{H:+8,S:-12,L:-4},M:{H:0,S:-4,L:0} }
  },

  velvia: {
    name:"Fuji_Velvia",
    contrast:+3, sat:+4, tone:-1,
    curve5:{0:0,64:56,128:126,192:210,255:255},
    axes:{ R:{H:0,S:+6,L:0},Y:{H:0,S:+10,L:+2},G:{H:-6,S:+18,L:-6},C:{H:-2,S:+12,L:-6},B:{H:-4,S:+10,L:-8},M:{H:0,S:+4,L:0} }
  },

  eterna: {
    name:"Fuji_Eterna",
    contrast:-2, sat:-3, tone:-1,
    curve5:{0:16,64:88,128:132,192:180,255:238},
    axes:{ R:{H:0,S:-10,L:+2},Y:{H:0,S:-12,L:+2},G:{H:0,S:-8,L:0},C:{H:+2,S:-8,L:0},B:{H:+2,S:-8,L:0},M:{H:0,S:-8,L:0} }
  },

  gr_positive: {
    name:"GR_Positive",
    contrast:+2, sat:+2, tone:0,
    curve5:{0:0,64:60,128:132,192:198,255:252},
    axes:{ R:{H:0,S:+8,L:0},Y:{H:-2,S:+6,L:+2},G:{H:-6,S:+2,L:-6},C:{H:+2,S:+6,L:-4},B:{H:-4,S:+10,L:-8},M:{H:0,S:0,L:0} }
  }
};

/* =========================================================
   Utils
========================================================= */
function clamp(v,a,b){ return v<a?a:(v>b?b:v); }
function lerp(a,b,t){ return a+(b-a)*t; }
function setDot(id, state){
  const el = document.getElementById(id);
  el.className = "dot" + (state ? (" " + state) : "");
}
function modeName(mode){
  if(mode==="auto") return "AIìë™";
  if(mode==="portrait") return "ì¸ë¬¼";
  if(mode==="landscape") return "í’ê²½";
  if(mode==="snap") return "ìŠ¤ëƒ…";
  if(mode==="night") return "ì•¼ê²½";
  return "ìˆ˜ë™";
}

/* =========================================================
   Tabs / Shot / Mode
========================================================= */
function setTab(tab){
  viewTab = tab;
  document.querySelectorAll(".tab").forEach(el=> el.classList.toggle("active", el.dataset.tab === tab));
  const hint = document.getElementById("tabHint");
  if(tab === "sum"){
    hint.textContent = "ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.remove("hide");
    document.getElementById("fullBox").classList.add("hide");
  }else{
    hint.textContent = "ìƒì„¸ ë ˆì‹œí”¼ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.add("hide");
    document.getElementById("fullBox").classList.remove("hide");
  }
}
function setMode(mode){
  userMode = mode;
  document.querySelectorAll(".chip[data-mode]").forEach(el=> el.classList.toggle("active", el.dataset.mode === mode));
  refreshReady();
}
function setShot(mode){
  shotMode = mode;
  document.querySelectorAll(".chip[data-shot]").forEach(el=> el.classList.toggle("active", el.dataset.shot === mode));
  document.getElementById("dropOrig").classList.toggle("hide", shotMode !== "two");
  refreshReady();
}

/* =========================================================
   Preset label
========================================================= */
function updateStrengthLabel(){
  const v = parseInt(document.getElementById("presetStrength").value, 10);
  document.getElementById("strengthLabel").textContent = v + "%";
}
function setStrengthEnabled(enabled){
  const s = document.getElementById("presetStrength");
  s.disabled = !enabled;
  s.style.opacity = enabled ? "1" : "0.5";
}
function updatePresetLabel(){
  const key = document.getElementById("fujiPreset").value;
  const strength = parseInt(document.getElementById("presetStrength").value, 10);
  if(key === "off"){
    document.getElementById("presetLabel").textContent = "OFF";
    setStrengthEnabled(false);
    return;
  }
  setStrengthEnabled(true);
  const name = FUJI_PRESETS[key]?.name || "LookPreset";
  const extra = (key==="classic_negative") ? " Â· MatrixFX" : (FUJI_PRESETS[key]?.skinProtect ? " Â· SkinSafe" : "");
  document.getElementById("presetLabel").textContent = `ON: ${name}${extra} (${strength}%)`;
}

/* =========================================================
   Preview labels / readiness
========================================================= */
function updatePreviewLabels(){
  document.getElementById("splitLabel").textContent = Math.round(split01*100) + "%";
  const st = parseInt(document.getElementById("previewStrength").value,10);
  document.getElementById("previewStrengthLabel").textContent = st + "%";
  const pm = document.getElementById("previewMode").value;
  document.getElementById("previewModeLabel").textContent = (pm==="preset") ? "PRESET" : "RECIPE";
}
function refreshPreviewReady(){
  const btn = document.getElementById("btnPreviewApply");
  const btnReset = document.getElementById("btnPreviewReset");
  const btnSave = document.getElementById("btnPreviewSave");

  const okPrev = !!prevFileState;
  const pm = document.getElementById("previewMode").value;
  const okRecipe = (pm==="recipe") ? !!lastRecipe : true;

  btn.disabled = !(okPrev && okRecipe);
  btnReset.disabled = !okPrev;
  btnSave.disabled = !okPrev;

  setDot("dotP", okPrev ? "ok" : "");
  if(pm==="recipe" && okPrev && !okRecipe){
    setPvMeta("ë ˆì‹œí”¼ ì—†ìŒ(ë¨¼ì € ë¶„ì„í•˜ì„¸ìš”)");
  }
}
function setPvMeta(t){
  document.getElementById("pvMeta").textContent = t || "-";
}

/* =========================================================
   HEIC / EXIF
========================================================= */
function isHeicFile(file){
  const name = (file?.name || "").toLowerCase();
  const type = (file?.type || "").toLowerCase();
  return (name.endsWith(".heic") || name.endsWith(".heif") || type.includes("heic") || type.includes("heif"));
}
function maybeWarnHeic(file){
  if(isHeicFile(file)){
    alert("âš ï¸ HEIC/HEIF íŒŒì¼ì€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦¬ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.\nJPGë¡œ ë³€í™˜ í›„ ì¬ì‹œë„í•´ ì£¼ì„¸ìš”.");
  }
}
async function getExifOrientation(file){
  try{
    const name = (file?.name || "").toLowerCase();
    const type = (file?.type || "").toLowerCase();
    const isJpeg = type.includes("jpeg") || type.includes("jpg") || name.endsWith(".jpg") || name.endsWith(".jpeg");
    if(!isJpeg) return 1;

    const buf = await file.slice(0, 256 * 1024).arrayBuffer();
    const view = new DataView(buf);
    if(view.getUint16(0, false) !== 0xFFD8) return 1;

    let offset = 2;
    const length = view.byteLength;
    while(offset < length){
      if(view.getUint8(offset) !== 0xFF) break;
      const marker = view.getUint8(offset + 1);
      offset += 2;
      if(marker === 0xD9 || marker === 0xDA) break;

      const segLen = view.getUint16(offset, false);
      if(segLen < 2) break;

      if(marker === 0xE1){
        const start = offset + 2;
        if(start + 6 <= length){
          const isExif = view.getUint8(start+0)===0x45 && view.getUint8(start+1)===0x78 && view.getUint8(start+2)===0x69 && view.getUint8(start+3)===0x66;
          if(isExif){
            const tiff = start + 6;
            const endian = view.getUint16(tiff, false);
            const little = (endian === 0x4949);
            const getU16 = (o)=> view.getUint16(o, little);
            const getU32 = (o)=> view.getUint32(o, little);
            const magic = getU16(tiff + 2);
            if(magic !== 0x002A) return 1;
            const ifd0Offset = getU32(tiff + 4);
            let ifd0 = tiff + ifd0Offset;
            const entries = getU16(ifd0);
            ifd0 += 2;
            for(let i=0;i<entries;i++){
              const ent = ifd0 + i*12;
              const tag = getU16(ent + 0);
              if(tag === 0x0112){
                const val = getU16(ent + 8);
                return val || 1;
              }
            }
          }
        }
      }
      offset += segLen;
    }
    return 1;
  }catch(e){ return 1; }
}

/* =========================================================
   Upload
========================================================= */
function setupDropZone(dropId, inputId, thumbId, nameId, onSetFile){
  const drop = document.getElementById(dropId);
  const input = document.getElementById(inputId);
  const thumb = document.getElementById(thumbId);
  const nameEl = document.getElementById(nameId);

  drop.addEventListener("click", ()=> input.click());
  drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("dragover"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("dragover"));
  drop.addEventListener("drop", (e)=>{
    e.preventDefault(); drop.classList.remove("dragover");
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreviewThumb(f, thumb, nameEl);
      refreshReady();
      refreshPreviewReady();
      if(dropId==="dropPrev") queuePreviewRender("upload");
    }
  });
  input.addEventListener("change", ()=>{
    const f = input.files && input.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreviewThumb(f, thumb, nameEl);
      refreshReady();
      refreshPreviewReady();
      if(dropId==="dropPrev") queuePreviewRender("upload");
    }
  });
}
function updatePreviewThumb(file, imgEl, nameEl){
  nameEl.textContent = "âœ… " + file.name;
  nameEl.style.display = "block";
  const r = new FileReader();
  r.onload = (e)=>{ imgEl.src = e.target.result; imgEl.style.display = "block"; };
  r.readAsDataURL(file);
}

/* =========================================================
   AI load
========================================================= */
function setAIUI(state, text){
  const dot = document.getElementById("dotAI");
  const label = document.getElementById("aiText");
  aiState = state;
  aiStatusText = text || aiStatusText;
  dot.className = (state === "ready") ? "dot ok" : "dot warn";
  label.textContent = aiStatusText;
}
async function ensureAIModelsLoaded(){
  if(aiState === "ready") return true;
  if(aiState === "loading") return false;

  setAIUI("loading", "AI ë¡œë”©ì¤‘â€¦(ìë™ ëª¨ë“œ)");
  try{
    await tf.ready();
    faceModel = await blazeface.load();
    classifyModel = await mobilenet.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ");
    return true;
  }catch(e){
    setAIUI("failed", "AI ì‹¤íŒ¨(ìš°íšŒ) Â· ìˆ˜ë™/ëŒ€ì²´ë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}
async function ensureCocoLoadedIfNeeded(){
  const need = (document.getElementById("aiBoost").value === "coco");
  if(!need) return false;
  if(cocoModel) return true;
  try{
    setAIUI("loading", "AI+ (COCO-SSD) ë¡œë”©ì¤‘â€¦");
    await new Promise((resolve, reject)=>{
      const s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js";
      s.onload = resolve;
      s.onerror = reject;
      document.head.appendChild(s);
    });
    cocoModel = await cocoSsd.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ + COCO-SSD");
    return true;
  }catch(e){
    setAIUI("failed", "COCO-SSD ì‹¤íŒ¨(ìš°íšŒ) Â· ê¸°ë³¸ AIë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}

/* =========================================================
   Ready
========================================================= */
function refreshReady(){
  const hasRef = !!refFileState;
  const hasOrig = !!origFileState;

  setDot("dotR", hasRef ? "ok" : "");
  setDot("dotO", (shotMode === "two" && hasOrig) ? "ok" : "");

  const btn = document.getElementById("btnAnalyze");
  const btnText = document.getElementById("btnText");

  const readyForShot = (shotMode === "one") ? hasRef : (hasRef && hasOrig);
  btn.disabled = !readyForShot;

  if(!readyForShot){ btnText.textContent = "ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”"; return; }
  btnText.textContent = (userMode === "auto" && aiState !== "ready") ? "âš¡ ë¶„ì„ ì‹œì‘ (í•„ìš” ì‹œ AI ë¡œë”©)" : "âš¡ ë¶„ì„ ì‹œì‘";
}

/* =========================================================
   Image decode + draw
========================================================= */
async function fileToHTMLImage(file){
  return await new Promise((resolve, reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}
async function decodeToImageBitmap(file){
  try{
    if(typeof createImageBitmap === "function") return await createImageBitmap(file);
    throw new Error("createImageBitmap not available");
  }catch(e){
    return await fileToHTMLImage(file);
  }
}
function applyOrientationTransform(ctx, orientation, w, h){
  switch(orientation){
    case 2: ctx.translate(w, 0); ctx.scale(-1, 1); break;
    case 3: ctx.translate(w, h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0, h); ctx.scale(1, -1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1); break;
    case 6: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); break;
    case 7: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); ctx.scale(-1, 1); break;
    case 8: ctx.translate(0, h); ctx.rotate(-0.5*Math.PI); break;
  }
}
function drawScaledToCanvas(canvas, bitmapOrImg, maxDim, orientation=1){
  const ow = bitmapOrImg.width;
  const oh = bitmapOrImg.height;
  if(orientation === 5 || orientation === 7) orientation = 1;

  const swapWH = (orientation>=5 && orientation<=8);
  const rw = swapWH ? oh : ow;
  const rh = swapWH ? ow : oh;

  const scale = Math.min(1, maxDim / Math.max(rw, rh));
  const tw = Math.max(1, Math.round(rw * scale));
  const th = Math.max(1, Math.round(rh * scale));

  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  canvas.width = tw; canvas.height = th;

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,tw,th);

  ctx.save();
  applyOrientationTransform(ctx, orientation, tw, th);
  if(swapWH) ctx.drawImage(bitmapOrImg, 0, 0, th, tw);
  else ctx.drawImage(bitmapOrImg, 0, 0, tw, th);
  ctx.restore();
  ctx.restore();

  return {w:tw, h:th};
}
function getImageDataFromCanvas(canvas){
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  return ctx.getImageData(0,0,canvas.width, canvas.height);
}

/* =========================================================
   PSE HSL Guard + Point clamp
========================================================= */
function pseConeMaxS01(l01){
  const t = Math.abs(2*l01 - 1);
  return clamp(1 - t, 0, 1);
}
function pseGuardAxisAdjust(axis, avgL01){
  const cone = pseConeMaxS01(avgL01);
  const scale = clamp(0.35 + 0.65*cone, 0.35, 1.0);

  let s = axis.canonS;
  const absS = Math.abs(s);
  const softCap = Math.round(30 * clamp(cone*1.15, 0.15, 1.0));
  if(absS > softCap){
    s = Math.round(Math.sign(s) * (softCap + (absS-softCap)*0.25));
  }
  s = Math.round(s * scale);

  let l = axis.canonL;
  const lScale = clamp(0.55 + 0.45*cone, 0.55, 1.0);
  l = Math.round(l * lScale);

  return {...axis, canonS: clamp(s,-30,30), canonL: clamp(l,-30,30)};
}
function pseClampPointS01(s01, l01){
  const maxS = pseConeMaxS01(l01);
  return clamp(s01, 0, maxS);
}

/* =========================================================
   Curve helper
========================================================= */
function curve5ToLUT(curve5){
  const xs = [0,64,128,192,255];
  const ys = xs.map(x => clamp(Math.round(curve5[x]), 0, 255));
  const lut = new Uint8Array(256);
  for(let i=0;i<xs.length-1;i++){
    const x0=xs[i], x1=xs[i+1];
    const y0=ys[i], y1=ys[i+1];
    const dx = (x1 - x0);
    for(let x=x0; x<=x1; x++){
      const t = dx === 0 ? 0 : (x - x0) / dx;
      lut[x] = clamp(Math.round(lerp(y0, y1, t)), 0, 255);
    }
  }
  for(let i=1;i<256;i++){ if(lut[i] < lut[i-1]) lut[i] = lut[i-1]; }
  return lut;
}

/* =========================================================
   PREVIEW: preset-only recipe
   - ClassicNegativeëŠ” previewFx í¬í•¨
========================================================= */
function buildPresetOnlyRecipe(presetKey, presetStrength01){
  const idLUT = new Uint8Array(256).map((_,i)=>i);
  if(!presetKey || presetKey==="off" || !FUJI_PRESETS[presetKey] || presetStrength01<=0){
    return {
      name: "Identity",
      contrast: 0, sat: 0, tone: 0,
      toneLUT: idLUT,
      axes: ["R","Y","G","C","B","M"].map(k=>({axis:k,canonH:0,canonS:0,canonL:0,avgL01:0.5})),
      specificPoints: [],
      meta: "Preset OFF"
    };
  }

  const p = FUJI_PRESETS[presetKey];
  const pLUT = curve5ToLUT(p.curve5);
  const outLUT = new Uint8Array(256);
  for(let i=0;i<256;i++){
    outLUT[i] = clamp(Math.round(lerp(idLUT[i], pLUT[i], presetStrength01)), 0, 255);
  }
  for(let i=1;i<256;i++){ if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1]; }

  const axes = ["R","Y","G","C","B","M"].map(k=>{
    const a = p.axes[k];
    const base = {axis:k,
      canonH: clamp(Math.round(a.H * presetStrength01), -30, 30),
      canonS: clamp(Math.round(a.S * presetStrength01), -30, 30),
      canonL: clamp(Math.round(a.L * presetStrength01), -30, 30),
      avgL01: 0.5
    };
    return pseGuardAxisAdjust(base, 0.5);
  });

  const fx = p.previewFx ? {
    rgbMatrix: p.previewFx.rgbMatrix,
    satMul: lerp(1.0, p.previewFx.satMul, presetStrength01),   // strengthë¡œ blend
    hslRegions: p.previewFx.hslRegions
  } : null;

  return {
    name: p.name,
    contrast: clamp(Math.round(p.contrast * presetStrength01), -4, 4),
    sat:      clamp(Math.round(p.sat * presetStrength01), -4, 4),
    tone:     clamp(Math.round(p.tone * presetStrength01), -4, 4),
    toneLUT: outLUT,
    axes,
    specificPoints: [],
    previewFx: fx,
    meta: `PresetOnly ${p.name}${fx ? " + MatrixFX" : ""} ${Math.round(presetStrength01*100)}%`
  };
}

/* =========================================================
   PREVIEW: apply recipe to ImageData
   - ìˆœì„œ:
     1) LUT
     2) (optional) RGB matrix cross-talk (sRGB space float)
     3) HSL -> (optional) satMul + region Î”H/Î”S/Î”L
     4) recipe contrast/sat/tone + axes + points
========================================================= */
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0,s=0;
  const l=(max+min)/2;
  if(max!==min){
    const d=max-min;
    s = l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  return [h*360, s, l];
}
function hue2rgb(p, q, t){
  if(t<0) t+=1;
  if(t>1) t-=1;
  if(t<1/6) return p + (q-p)*6*t;
  if(t<1/2) return q;
  if(t<2/3) return p + (q-p)*(2/3 - t)*6;
  return p;
}
function hslToRgb(hDeg, s, l){
  let r,g,b;
  const h = ((hDeg%360)+360)%360 / 360;
  if(s===0){
    r=g=b=l;
  }else{
    const q = l < 0.5 ? l*(1+s) : l + s - l*s;
    const p = 2*l - q;
    r = hue2rgb(p,q,h + 1/3);
    g = hue2rgb(p,q,h);
    b = hue2rgb(p,q,h - 1/3);
  }
  return [Math.round(clamp(r,0,1)*255), Math.round(clamp(g,0,1)*255), Math.round(clamp(b,0,1)*255)];
}
function circularHueDiffDeg(a,b){
  let d=(a-b)%360;
  if(d>180) d-=360;
  if(d<=-180) d+=360;
  return d;
}
function axisFromHue(h){
  if(h>=340 || h<20) return "R";
  if(h>=20 && h<80) return "Y";
  if(h>=80 && h<150) return "G";
  if(h>=150 && h<210) return "C";
  if(h>=210 && h<280) return "B";
  return "M";
}
function buildAxisMap(axes){
  const m = {};
  (axes||[]).forEach(a=> m[a.axis] = a);
  return m;
}
function applyRgbMatrixSRGB(r,g,b, m3){
  // inputs: 0..255 -> float 0..1, operate in sRGB float as python snippet
  const rf = r/255, gf = g/255, bf = b/255;
  const r2 = rf*m3[0][0] + gf*m3[0][1] + bf*m3[0][2];
  const g2 = rf*m3[1][0] + gf*m3[1][1] + bf*m3[1][2];
  const b2 = rf*m3[2][0] + gf*m3[2][1] + bf*m3[2][2];
  return [
    Math.round(clamp(r2,0,1)*255),
    Math.round(clamp(g2,0,1)*255),
    Math.round(clamp(b2,0,1)*255),
  ];
}
function applyHslRegionDeltas(hDeg, s, l, regions, strength01){
  if(!regions || !regions.length || strength01<=0) return [hDeg,s,l];

  // soft weighting around ranges: 10deg feather
  const FEATHER = 10;
  let outH = hDeg, outS = s, outL = l;

  for(const rg of regions){
    const inRange = (rg.h0 <= rg.h1)
      ? (hDeg >= rg.h0 && hDeg <= rg.h1)
      : (hDeg >= rg.h0 || hDeg <= rg.h1);

    // distance to range (0 inside, >0 outside)
    let dist = 0;
    if(inRange){
      dist = 0;
    }else{
      // compute min circular distance to the nearest boundary
      const d0 = Math.abs(circularHueDiffDeg(hDeg, rg.h0));
      const d1 = Math.abs(circularHueDiffDeg(hDeg, rg.h1));
      dist = Math.min(d0, d1);
    }

    const w = clamp(1 - (dist/FEATHER), 0, 1) * strength01;
    if(w <= 0) continue;

    outH = outH + rg.dH * w;
    // Î”S, Î”L are ratio changes
    outS = clamp(outS * (1 + rg.dS * w), 0, 1);
    outL = clamp(outL * (1 + rg.dL * w), 0, 1);
  }
  return [outH,outS,outL];
}

function applyRecipeToImageData(srcImageData, recipe, strength01, enablePoints){
  const w = srcImageData.width, h = srcImageData.height;
  const src = srcImageData.data;
  const out = new ImageData(w,h);
  const dst = out.data;

  const lut = recipe.toneLUT || new Uint8Array(256).map((_,i)=>i);

  // recipe sliders/axes (PSE-like)
  const cFactor = 1 + (recipe.contrast||0) * 0.12 * strength01;
  const sFactor = 1 + (recipe.sat||0) * 0.18 * strength01;
  const toneDeg = (recipe.tone||0) * 2.0 * strength01;
  const axisMap = buildAxisMap(recipe.axes || []);

  const points = enablePoints ? (recipe.specificPoints || []).slice(0, 12) : [];
  const hasPoints = points.length>0;

  // preview fx (ClassicNeg matrix/hsl)
  const fx = recipe.previewFx || null;
  const fxMatrix = fx?.rgbMatrix || null;
  const fxSatMul = (typeof fx?.satMul === "number") ? fx.satMul : 1.0;
  const fxRegions = fx?.hslRegions || null;

  for(let i=0;i<src.length;i+=4){
    let r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];

    // 1) tone curve LUT
    r = lut[r]; g = lut[g]; b = lut[b];

    // 2) RGB matrix cross-talk (preview only)
    if(fxMatrix){
      const rgb2 = applyRgbMatrixSRGB(r,g,b, fxMatrix);
      r = rgb2[0]; g = rgb2[1]; b = rgb2[2];
    }

    // 3) HSL stage (region deltas + satMul)
    let [hDeg, s, l] = rgbToHsl(r,g,b);
    // global sat mul (HSV S*0.85ë¥¼ HSL Sì— ê·¼ì‚¬ ì ìš©)
    s = clamp(s * fxSatMul, 0, 1);
    // region deltas
    [hDeg, s, l] = applyHslRegionDeltas(hDeg, s, l, fxRegions, strength01);

    // 4) PSE-like base/axes/points
    l = clamp(0.5 + (l - 0.5)*cFactor, 0, 1);
    s = clamp(s * sFactor, 0, 1);
    hDeg = (hDeg + toneDeg);

    const axK = axisFromHue(hDeg);
    const ax = axisMap[axK];
    if(ax){
      hDeg += ax.canonH * strength01;
      s = clamp(s * (1 + (ax.canonS/55) * strength01), 0, 1);
      l = clamp(l + (ax.canonL/220) * strength01, 0, 1);
    }

    if(hasPoints){
      for(let p=0;p<points.length;p++){
        const pt = points[p];
        const dh = Math.abs(circularHueDiffDeg(hDeg, pt.inH));
        if(dh > 18) continue;
        const ds = Math.abs(s - pt.inS);
        const dl = Math.abs(l - pt.inL);
        if(ds > 0.35 || dl > 0.35) continue;

        const wh = 1 - (dh/18);
        const ws = 1 - (ds/0.35);
        const wl = 1 - (dl/0.35);
        const wgt = clamp(wh*ws*wl, 0, 1) * 0.35 * strength01;

        hDeg = hDeg + circularHueDiffDeg(pt.outH, hDeg) * wgt;
        s = lerp(s, pt.outS, wgt);
        l = lerp(l, pt.outL, wgt);
      }
    }

    const rgb = hslToRgb(hDeg, s, l);
    dst[i]   = rgb[0];
    dst[i+1] = rgb[1];
    dst[i+2] = rgb[2];
    dst[i+3] = a;
  }
  return out;
}

/* =========================================================
   PREVIEW: split draw (cached)
========================================================= */
function drawSplitFromCache(){
  if(!previewCache) return;
  const canvas = document.getElementById("previewCanvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:true});

  const beforeImg = previewCache.before;
  const afterImg  = previewCache.after;
  const w = beforeImg.width, h = beforeImg.height;
  canvas.width = w; canvas.height = h;

  ctx.putImageData(afterImg, 0, 0);

  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = w; tmpCanvas.height = h;
  tmpCanvas.getContext("2d").putImageData(beforeImg, 0, 0);

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, Math.round(w * split01), h);
  ctx.clip();
  ctx.drawImage(tmpCanvas, 0, 0);
  ctx.restore();

  const x = Math.round(w*split01)+0.5;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.88)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();

  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.beginPath();
  ctx.arc(x, Math.min(22, h*0.12), 7, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  updatePreviewLabels();
}

/* =========================================================
   PREVIEW: render task
========================================================= */
let previewRenderToken = 0;
function queuePreviewRender(reason){
  if(!prevFileState) return;
  const token = ++previewRenderToken;
  setTimeout(()=>{ if(token===previewRenderToken) renderPreview(reason); }, 80);
}
async function renderPreview(reason){
  if(!prevFileState) return;
  if(previewBusy) return;
  previewBusy = true;

  try{
    const mode = document.getElementById("previewMode").value;
    const pd = parseInt(document.getElementById("previewDim").value, 10);
    const st01 = parseInt(document.getElementById("previewStrength").value,10)/100;

    const useRecipe = (mode === "recipe");
    if(useRecipe && !lastRecipe){
      setPvMeta("ë ˆì‹œí”¼ ì—†ìŒ(ë¨¼ì € ë¶„ì„í•˜ì„¸ìš”)");
      previewCache = null;
      return;
    }

    const ori = await getExifOrientation(prevFileState);
    const bm = await decodeToImageBitmap(prevFileState);

    const canvas = document.createElement("canvas");
    drawScaledToCanvas(canvas, bm, pd, ori);
    const before = getImageDataFromCanvas(canvas);

    let recipe;
    let meta;
    if(useRecipe){
      recipe = lastRecipe;
      meta = `Recipe Â· ${lastRecipe.baseHint || "Last"} Â· strength ${Math.round(st01*100)}%`;
    }else{
      const presetKey = document.getElementById("fujiPreset").value;
      const pStrength = parseInt(document.getElementById("presetStrength").value, 10)/100;
      recipe = buildPresetOnlyRecipe(presetKey, pStrength);
      meta = `${recipe.meta} Â· preview ${Math.round(st01*100)}%`;
    }

    const enablePoints = useRecipe;
    const after = applyRecipeToImageData(before, recipe, st01, enablePoints);

    previewCache = {before, after, w: before.width, h: before.height, metaText: meta};
    setPvMeta(`${meta} Â· ${before.width}x${before.height}`);

    drawSplitFromCache();
  }catch(e){
    console.error(e);
    setPvMeta("ë¯¸ë¦¬ë³´ê¸° ì˜¤ë¥˜: ì´ë¯¸ì§€/ë¸Œë¼ìš°ì € ì œí•œ í™•ì¸");
  }finally{
    previewBusy = false;
  }
}

/* =========================================================
   PREVIEW: drag interaction
========================================================= */
function setSplitFromClientX(clientX){
  const canvas = document.getElementById("previewCanvas");
  const rect = canvas.getBoundingClientRect();
  const x = clamp((clientX - rect.left) / Math.max(1, rect.width), 0, 1);
  split01 = x;
  drawSplitFromCache();
}
function bindPreviewDrag(){
  const canvas = document.getElementById("previewCanvas");
  let dragging = false;

  const onDown = (e)=>{
    if(!previewCache) return;
    dragging = true;
    if(e.pointerId !== undefined && canvas.setPointerCapture){
      try{ canvas.setPointerCapture(e.pointerId); }catch(_){}
    }
    setSplitFromClientX(e.clientX);
  };
  const onMove = (e)=>{
    if(!dragging) return;
    setSplitFromClientX(e.clientX);
  };
  const onUp = ()=>{ dragging = false; };

  canvas.addEventListener("pointerdown", onDown);
  canvas.addEventListener("pointermove", onMove);
  canvas.addEventListener("pointerup", onUp);
  canvas.addEventListener("pointercancel", onUp);
  canvas.addEventListener("pointerleave", onUp);
}

/* =========================================================
   PREVIEW: save PNG
========================================================= */
function savePreviewPNG(){
  const canvas = document.getElementById("previewCanvas");
  if(!prevFileState || !canvas.width || !canvas.height) return;
  const a = document.createElement("a");
  const ts = new Date();
  const name = `preview_v11.4_${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,"0")}${String(ts.getDate()).padStart(2,"0")}_${String(ts.getHours()).padStart(2,"0")}${String(ts.getMinutes()).padStart(2,"0")}.png`;
  a.download = name;
  a.href = canvas.toDataURL("image/png");
  a.click();
}

/* =========================================================
   Worker lifecycle
========================================================= */
function terminateWorker(){
  try{ if(worker){ worker.terminate(); worker = null; } }catch(e){}
  try{ if(workerUrl){ URL.revokeObjectURL(workerUrl); workerUrl = null; } }catch(e){}
}
window.addEventListener("beforeunload", ()=> terminateWorker());

function initWorker(){
  if(worker) return;

  const code = `
    function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

    function rgbToHsl01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0;
      const l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, l];
    }
    function rgbToHsv01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0;
      const s = max===0 ? 0 : d/max;
      const v = max;
      if(d!==0){
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, v];
    }

    function srgbToLin(u){
      u/=255;
      return (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
    }
    function linRgbToXyz(lr,lg,lb){
      const X = lr*0.4124564 + lg*0.3575761 + lb*0.1804375;
      const Y = lr*0.2126729 + lg*0.7151522 + lb*0.0721750;
      const Z = lr*0.0193339 + lg*0.1191920 + lb*0.9503041;
      return [X,Y,Z];
    }
    function xyToCct(x,y){
      const n = (x - 0.3320) / (y - 0.1858 + 1e-9);
      const cct = 449*n*n*n + 3525*n*n + 6823.3*n + 5520.33;
      return cct;
    }
    function xyToUv(x,y){
      const denom = (-2*x + 12*y + 3);
      const u = (4*x) / (denom + 1e-9);
      const v = (9*y) / (denom + 1e-9);
      return [u,v];
    }
    function wbShiftFromUv(u,v){
      const u0 = 0.1978398, v0 = 0.4683363;
      const du = u - u0;
      const dv = v - v0;
      let ab = clamp(Math.round(-du * 250), -9, 9);
      let gm = clamp(Math.round(dv * 250), -9, 9);
      const abLabel = (ab>0) ? ("A" + ab) : (ab<0 ? ("B" + (-ab)) : "0");
      const gmLabel = (gm>0) ? ("G" + gm) : (gm<0 ? ("M" + (-gm)) : "0");
      const mag = Math.sqrt(du*du + dv*dv);
      const rel = clamp((mag*120), 0.15, 1.0);
      return {ab, gm, abLabel, gmLabel, rel};
    }
    function circularHueDiff(h2,h1){
      let d=(h2-h1)%360;
      if(d>180) d-=360;
      if(d<=-180) d+=360;
      return d;
    }

    function luminanceHistFromRGBA(rgba, stridePx){
      const hist = new Uint32Array(256);
      let total=0, tooDark=0, tooBright=0;
      const step = 4 * Math.max(1, stridePx|0);
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) | 0;
        hist[lum]++; total++;
        if(lum<=10) tooDark++;
        if(lum>=245) tooBright++;
      }
      return {hist,total,tooDark,tooBright};
    }
    function uniformHist(){
      const hist = new Uint32Array(256);
      for(let i=0;i<256;i++) hist[i]=1;
      return {hist,total:256,tooDark:0,tooBright:0};
    }
    function cdfFromHist(hist,total){
      const cdf = new Float32Array(256);
      let acc=0;
      for(let i=0;i<256;i++){ acc += hist[i]; cdf[i] = acc/total; }
      return cdf;
    }
    function buildToneLUTByCDFMatch(cdfO,cdfR){
      const lut = new Uint8Array(256);
      let j=0;
      for(let i=0;i<256;i++){
        const p = cdfO[i];
        while(j<255 && cdfR[j] < p) j++;
        lut[i]=j;
      }
      return lut;
    }
    function percentileByHist(hist,total,p){
      const target = total*p;
      let acc=0;
      for(let i=0;i<256;i++){
        acc+=hist[i];
        if(acc>=target) return i;
      }
      return 255;
    }
    function applyBlackLiftCompensation(lut, refP02){
      const liftRaw = Math.max(0, refP02 - 10);
      const strength = Math.max(0, Math.min(1, liftRaw/22));
      const liftPx = Math.round(6 + 18*strength);
      const out = new Uint8Array(256);
      for(let i=0;i<256;i++){
        let boost = 0;
        if(i < 128) boost = liftPx * (1 - (i/128));
        out[i] = Math.min(255, lut[i] + boost);
        if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
      }
      return {lut: out, strength, liftPx, isLifted: strength>=0.20};
    }

    function estimateExposure(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sh=0, hi=0, mid=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 50) sh++;
        else if(y > 205) hi++;
        else mid++;
        n++;
      }
      if(n<=0) return {shadowRatio:0, highlightRatio:0, midRatio:0, note:"-"};
      const sr = sh/n, hr = hi/n, mr = mid/n;
      let note = "Balanced";
      if(hr>0.35) note = "Highlight heavy";
      if(sr>0.35) note = "Shadow heavy";
      if(hr>0.30 && sr>0.30) note = "Extreme contrast";
      return {shadowRatio:sr, highlightRatio:hr, midRatio:mr, note};
    }

    function estimateRegions(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sky=0, fol=0, skin=0, valid=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 18 || y > 245) continue;

        const hsv = rgbToHsv01(r,g,b);
        const hDeg = hsv[0]*360;
        const s = hsv[1], v = hsv[2];
        if(s < 0.10) continue;

        valid++;
        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        const isSky = (hDeg >= 190 && hDeg <= 245 && s >= 0.18 && v >= 0.22);
        const isFol = (hDeg >= 70 && hDeg <= 160 && s >= 0.18 && v >= 0.18);
        if(isSkin) skin++;
        if(isSky)  sky++;
        if(isFol)  fol++;
      }
      if(valid <= 0) return {sky:0, foliage:0, skin:0, valid:0};
      return { sky: clamp(sky/valid,0,1), foliage: clamp(fol/valid,0,1), skin: clamp(skin/valid,0,1), valid };
    }

    function estimateSkinGlobal(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let skin=0, total=0, hi=0, hiTotal=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 28 || y > 245) continue;
        const hsv = rgbToHsv01(r,g,b);
        if(hsv[1] < 0.10) continue;

        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;

        total++;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        if(isSkin){
          skin++;
          if(y >= 210) hi++;
        }
        if(y >= 210) hiTotal++;
      }
      const ratio = total>0 ? (skin/total) : 0;
      const highlightRisk = hiTotal>0 ? (hi/hiTotal) : 0;
      return {ratio: clamp(ratio,0,1), highlightRisk: clamp(highlightRisk,0,1), sampled: total, source:"global"};
    }

    function estimateWB(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sumX=0, sumY=0, sumZ=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(lum < 18 || lum > 245) continue;
        const xyz = linRgbToXyz(srgbToLin(r), srgbToLin(g), srgbToLin(b));
        sumX += xyz[0]; sumY += xyz[1]; sumZ += xyz[2]; n++;
      }
      if(n < 300) return {ok:false, kelvin: 0, abLabel:"0", gmLabel:"0", reliability:0.15, note:"ìƒ˜í”Œ ë¶€ì¡±"};
      const X = sumX/n, Y = sumY/n, Z = sumZ/n;
      const denom = (X+Y+Z) + 1e-9;
      let cct = xyToCct(X/denom, Y/denom);
      if(!isFinite(cct)) cct = 5200;
      const uv = xyToUv(X/denom, Y/denom);
      const sh = wbShiftFromUv(uv[0], uv[1]);
      const reliability = clamp(0.55*clamp(n/6000, 0.2, 1.0) + 0.45*sh.rel, 0.2, 1.0);
      return {ok:true, kelvin: clamp(Math.round(cct/10)*10, 2000, 10000), ab: sh.ab, gm: sh.gm, abLabel: sh.abLabel, gmLabel: sh.gmLabel, reliability, note: "íƒ€ê²Ÿ í‰ê·  ê¸°ë°˜" };
    }

    function getColorAxesDataWeighted(rgba, stridePx){
      const buckets = {
        R:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        Y:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        G:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        C:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        B:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        M:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      };

      let valid=0;
      let sumS=0, sumTone=0, toneN=0;
      const step = 4 * Math.max(1, stridePx|0);

      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const hsl = rgbToHsl01(r,g,b);
        let h=hsl[0]*360, s=hsl[1], l=hsl[2];

        if(s < 0.08) continue;
        if(l < 0.06 || l > 0.94) continue;

        let k='M';
        if(h>=340 || h<20) k='R';
        else if(h>=20 && h<80) k='Y';
        else if(h>=80 && h<150) k='G';
        else if(h>=150 && h<210) k='C';
        else if(h>=210 && h<280) k='B';
        else k='M';

        const wS = Math.pow(s, 1.5);
        const wL = 1.0 - Math.min(0.8, Math.abs(l-0.5)*1.6);
        const w = Math.max(0.01, wS*wL);

        const rad = h*Math.PI/180;
        const bk = buckets[k];
        bk.sumCos += Math.cos(rad)*w;
        bk.sumSin += Math.sin(rad)*w;
        bk.sumS += s*w;
        bk.sumL += l*w;
        bk.wSum += w;
        bk.count++;
        valid++;

        sumS += s;
        sumTone += Math.sin(rad);
        toneN++;
      }

      const out={};
      for(const k in buckets){
        const b=buckets[k];
        if(b.wSum>0){
          let hh = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
          if(hh<0) hh+=360;
          out[k]={H:hh, S:b.sumS/b.wSum, L:b.sumL/b.wSum, count:b.count};
        } else {
          out[k]={H:0,S:0,L:0,count:0};
        }
      }

      const avgS = toneN>0 ? (sumS/toneN) : 0;
      const avgTone = toneN>0 ? (sumTone/toneN) : 0;
      return {axes: out, validColored: valid, avgS, avgTone};
    }

    // Specific Points (2-shot only)
    function regionMaskType(r,g,b){
      const y = 0.299*r + 0.587*g + 0.114*b;
      const hsv = rgbToHsv01(r,g,b);
      const hDeg = hsv[0]*360;
      const s = hsv[1], v = hsv[2];

      const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
      const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
      const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173) && (s >= 0.10) && (v >= 0.12);

      const isSky = (hDeg >= 190 && hDeg <= 245 && s >= 0.18 && v >= 0.22);
      const isFol = (hDeg >= 70 && hDeg <= 160 && s >= 0.18 && v >= 0.18);

      if(isSkin) return 0;
      if(isSky)  return 1;
      if(isFol)  return 2;
      if(y < 60) return 3;
      if(y > 200) return 4;
      return 5;
    }
    function initBins(regionCount, hueBins){
      const bins = [];
      for(let r=0;r<regionCount;r++){
        const arr = [];
        for(let h=0;h<hueBins;h++){
          arr.push({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0});
        }
        bins.push(arr);
      }
      return bins;
    }
    function pushBin(bins, region, hueIdx, hDeg, s, l){
      const b = bins[region][hueIdx];
      const rad = hDeg*Math.PI/180;
      b.sumCos += Math.cos(rad);
      b.sumSin += Math.sin(rad);
      b.sumS += s;
      b.sumL += l;
      b.count += 1;
    }
    function binToMean(b){
      if(b.count<=0) return null;
      let hDeg = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
      if(hDeg < 0) hDeg += 360;
      return {hDeg, s01: b.sumS/b.count, l01: b.sumL/b.count, count: b.count};
    }
    function computeMinCount(stridePx, pixelCount){
      const base = (stridePx <= 8) ? 110 : 85;
      const scale = clamp(Math.sqrt(pixelCount / 700000), 0.75, 1.25);
      return Math.round(base * scale);
    }
    function buildSpecificPoints(origRGBA, refRGBA, stridePx){
      const regionCount = 6;
      const hueBins = 24;
      const binsO = initBins(regionCount, hueBins);
      const binsR = initBins(regionCount, hueBins);

      const stepPx = Math.max(1, stridePx|0);
      const step = 4 * stepPx;

      for(let i=0;i<origRGBA.length;i+=step){
        const r=origRGBA[i], g=origRGBA[i+1], b=origRGBA[i+2];
        const hsl = rgbToHsl01(r,g,b);
        const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
        if(s < 0.08 || l < 0.04 || l > 0.96) continue;
        const reg = regionMaskType(r,g,b);
        const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
        pushBin(binsO, reg, hi, hDeg, s, l);
      }
      for(let i=0;i<refRGBA.length;i+=step){
        const r=refRGBA[i], g=refRGBA[i+1], b=refRGBA[i+2];
        const hsl = rgbToHsl01(r,g,b);
        const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
        if(s < 0.08 || l < 0.04 || l > 0.96) continue;
        const reg = regionMaskType(r,g,b);
        const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
        pushBin(binsR, reg, hi, hDeg, s, l);
      }

      const pixelCount = Math.max(origRGBA.length, refRGBA.length) / 4;
      const minCount = computeMinCount(stepPx, pixelCount);

      const regionNames = ["SKIN","SKY","FOLIAGE","SHADOW","HIGHLIGHT","MID"];
      const regionPriority = {SKIN:0, SKY:1, FOLIAGE:2, MID:3, SHADOW:4, HIGHLIGHT:5};

      let candidates = 0;
      const points = [];
      for(let reg=0; reg<regionCount; reg++){
        for(let hi=0; hi<hueBins; hi++){
          const mo = binToMean(binsO[reg][hi]);
          const mr = binToMean(binsR[reg][hi]);
          if(!mo || !mr) continue;
          candidates++;
          if(mo.count < minCount || mr.count < minCount) continue;
          points.push({
            region: regionNames[reg],
            inH: mo.hDeg, inS: mo.s01, inL: mo.l01,
            outH: mr.hDeg, outS: mr.s01, outL: mr.l01,
            countO: mo.count, countR: mr.count,
            weight: (mo.count + mr.count) * 0.5
          });
        }
      }

      points.sort((a,b)=>{
        const pr = (regionPriority[a.region]||9) - (regionPriority[b.region]||9);
        if(pr!==0) return pr;
        return (b.weight||0) - (a.weight||0);
      });

      const picked = points.slice(0, 36);

      let fallbackPicked = [];
      if(picked.length < 6){
        const gO = new Array(hueBins).fill(0).map(()=>({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0}));
        const gR = new Array(hueBins).fill(0).map(()=>({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0}));

        for(let i=0;i<origRGBA.length;i+=step){
          const r=origRGBA[i], g=origRGBA[i+1], b=origRGBA[i+2];
          const hsl = rgbToHsl01(r,g,b);
          const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
          if(s < 0.08 || l < 0.05 || l > 0.95) continue;
          const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
          pushBin([gO], 0, hi, hDeg, s, l);
        }
        for(let i=0;i<refRGBA.length;i+=step){
          const r=refRGBA[i], g=refRGBA[i+1], b=refRGBA[i+2];
          const hsl = rgbToHsl01(r,g,b);
          const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
          if(s < 0.08 || l < 0.05 || l > 0.95) continue;
          const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
          pushBin([gR], 0, hi, hDeg, s, l);
        }

        const minCount2 = Math.max(35, Math.round(minCount * 0.55));
        const tmp = [];
        for(let hi=0; hi<hueBins; hi++){
          const mo = binToMean(gO[hi]);
          const mr = binToMean(gR[hi]);
          if(!mo || !mr) continue;
          if(mo.count < minCount2 || mr.count < minCount2) continue;
          tmp.push({
            region: "GLOBAL",
            inH: mo.hDeg, inS: mo.s01, inL: mo.l01,
            outH: mr.hDeg, outS: mr.s01, outL: mr.l01,
            countO: mo.count, countR: mr.count,
            weight: (mo.count + mr.count) * 0.5
          });
        }
        tmp.sort((a,b)=> (b.weight||0)-(a.weight||0));
        fallbackPicked = tmp.slice(0, 18);
      }

      const final = (picked.length >= 6) ? picked : (picked.concat(fallbackPicked)).slice(0, 24);
      const note =
        (picked.length>=6) ? "region OK"
        : (fallbackPicked.length>0 ? "fallback GLOBAL used" : "no valid bins");

      return { points: final, debug: {minCount, stepPx, candidates, picked: picked.length, fallbackPicked: fallbackPicked.length, note} };
    }

    function baseRecommend(mode, aiType, axesR, totalColored, contrast){
      if(mode !== "auto"){
        if(mode==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"ìˆ˜ë™"};
        if(mode==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"ìˆ˜ë™"};
        if(mode==="night") return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ìˆ˜ë™"};
        if(mode==="snap") return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
        return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
      }
      if(aiType==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"AI ê°ì§€"};
      if(aiType==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"AI ê°ì§€"};
      if(totalColored < 1500) return {base:"ëª¨ë…¸í¬ë¡¬ (Monochrome)", reason:"ìƒ‰ìƒ ë°ì´í„° ì ìŒ"};
      if((axesR.R.count + axesR.Y.count) > totalColored*0.55) return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"R/Y ë¹„ì¤‘"};
      if((axesR.G.count + axesR.B.count + axesR.C.count) > totalColored*0.45) return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"G/B/C ë¹„ì¤‘"};
      if(contrast <= -2) return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ê³„ì¡° í™•ë³´"};
      return {base:"í‘œì¤€ (Standard)", reason:"ë²”ìš©"};
    }

    self.onmessage = (e)=>{
      const {origBuf, refBuf, hasOrig, aiType, mode, stridePx, enableSpecPoints} = e.data;
      const stride = Math.max(1, stridePx|0);

      const refRGBA = new Uint8ClampedArray(refBuf);
      const origRGBA = hasOrig ? new Uint8ClampedArray(origBuf) : null;

      const r = luminanceHistFromRGBA(refRGBA, stride);
      const o = hasOrig ? luminanceHistFromRGBA(origRGBA, stride) : uniformHist();

      let lut = buildToneLUTByCDFMatch(cdfFromHist(o.hist, o.total), cdfFromHist(r.hist, r.total));
      const lift = applyBlackLiftCompensation(lut, percentileByHist(r.hist, r.total, 0.02));
      lut = lift.lut;

      const oRange = Math.max(1, percentileByHist(o.hist, o.total, 0.95) - percentileByHist(o.hist, o.total, 0.05));
      const rRange = Math.max(1, percentileByHist(r.hist, r.total, 0.95) - percentileByHist(r.hist, r.total, 0.05));
      let contrast = clamp(Math.round(((rRange/oRange)-1)*6), -4, 4);

      const exposure = estimateExposure(refRGBA, stride);
      if(exposure.note === "Extreme contrast") contrast = clamp(contrast - 1, -4, 4);

      const cR = getColorAxesDataWeighted(refRGBA, stride);
      const axesR = cR.axes;
      const axesO = hasOrig ? getColorAxesDataWeighted(origRGBA, stride).axes : {
        R:{H:0,S:0.24,L:0.50,count:9999},
        Y:{H:60,S:0.24,L:0.50,count:9999},
        G:{H:120,S:0.24,L:0.50,count:9999},
        C:{H:180,S:0.24,L:0.50,count:9999},
        B:{H:240,S:0.24,L:0.50,count:9999},
        M:{H:300,S:0.24,L:0.50,count:9999},
      };

      const keys = ['R','Y','G','C','B','M'];
      const axesOut = [];
      for(let i=0;i<6;i++){
        const k = keys[i];
        const rA = axesR[k];
        const oA = axesO[k];

        const countR = rA.count || 0;
        const reliability = clamp(Math.sqrt(countR / 2000), 0.20, 1.0);

        const diffH = circularHueDiff(rA.H, oA.H);
        const diffS = (rA.S - oA.S) * 100;
        const diffL = (rA.L - oA.L) * 100;

        axesOut.push({
          axis: k,
          canonH: clamp(Math.round((diffH/6.0) * reliability), -30, 30),
          canonS: clamp(Math.round((diffS/10.0) * reliability), -30, 30),
          canonL: clamp(Math.round((diffL/10.0) * reliability), -30, 30),
          avgL01: clamp(rA.L || 0.5, 0, 1),
          countR
        });
      }

      const baseRec = baseRecommend(mode, aiType, axesR, cR.validColored, contrast);
      const warnings = [];
      if((r.tooDark / r.total) > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ì–´ë‘¡ìŠµë‹ˆë‹¤(ì•”ë¶€ ë¹„ì¤‘â†‘).");
      if((r.tooBright / r.total) > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ë°ìŠµë‹ˆë‹¤(ëª…ë¶€ ë¹„ì¤‘â†‘).");
      if(cR.validColored < 1500) warnings.push("ìœ íš¨ ìƒ‰ìƒ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤(ì €ì±„ë„/ë¬´ì±„ìƒ‰). 6ìƒ‰ì¶•ì€ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.");

      const wb = estimateWB(refRGBA, stride);
      const skin = estimateSkinGlobal(refRGBA, stride);
      const regions = estimateRegions(refRGBA, stride);

      let specificPoints = [];
      let spDebug = null;
      if(enableSpecPoints && hasOrig){
        const res = buildSpecificPoints(origRGBA, refRGBA, stride);
        specificPoints = res.points || [];
        spDebug = res.debug || null;
        if(specificPoints.length === 0) warnings.push("Specific Points: í¬ì¸íŠ¸ 0ê°œ(ìƒ˜í”Œ ë¶€ì¡±).");
      }else if(enableSpecPoints && !hasOrig){
        warnings.push("Specific Points: 2ì¥ ëª¨ë“œì—ì„œë§Œ ìƒì„±ë©ë‹ˆë‹¤.");
      }

      self.postMessage({
        ok:true,
        contrast,
        sat: clamp(Math.round((cR.avgS - 0.45) * 10), -4, 4),
        tone: clamp(Math.round(cR.avgTone * 4), -4, 4),
        toneLUT: lut,
        lift: {isLifted: lift.isLifted, strength: lift.strength, liftPx: lift.liftPx},
        base: baseRec.base,
        baseReason: baseRec.reason,
        axes: axesOut,
        warnings,
        wb,
        skin,
        exposure,
        regions,
        specificPoints,
        spDebug,
        aiTypeDetected: aiType
      });
    };
  `;

  workerUrl = URL.createObjectURL(new Blob([code], {type:"application/javascript"}));
  worker = new Worker(workerUrl);
  Promise.resolve().then(()=>{ try{ URL.revokeObjectURL(workerUrl); workerUrl = null; }catch(e){} });
}

/* =========================================================
   AI detection
========================================================= */
async function detectAiType(canvas){
  if(userMode !== "auto") return {type:"manual", note:"ìˆ˜ë™"};
  if(!faceModel || !classifyModel) return {type:"fallback", note: aiStatusText};

  try{
    const faces = await faceModel.estimateFaces(canvas, false);
    if(faces && faces.length > 0) return {type:"portrait", note:`AI: ì–¼êµ´ ê°ì§€`};

    const preds = await classifyModel.classify(canvas);
    const lsKw = ['mountain','valley','ocean','sea','beach','tree','forest','sky','nature','landscape','lake','park'];
    const isLandscape = preds?.some(p => lsKw.some(kw => (p.className||"").toLowerCase().includes(kw)));
    if(isLandscape) return {type:"landscape", note:`AI: í’ê²½`};
    return {type:"standard", note:`AI: ì¼ë°˜`};
  }catch(e){
    return {type:"fallback", note:"AI íŒë³„ ì‹¤íŒ¨(ìš°íšŒ)"};
  }
}
async function cocoDetectTopIfEnabled(canvas){
  if(!cocoModel) return null;
  try{
    const preds = await cocoModel.detect(canvas);
    if(!preds || !preds.length) return null;
    preds.sort((a,b)=> (b.score||0)-(a.score||0));
    const top = preds[0];
    const bb = top.bbox || [0,0,0,0];
    const area = Math.max(0, bb[2]) * Math.max(0, bb[3]);
    const imgArea = Math.max(1, canvas.width * canvas.height);
    const areaRatio = clamp(area / imgArea, 0, 1);
    return {class: top.class, score: top.score || 0, bbox: bb, areaRatio};
  }catch(e){
    return null;
  }
}

/* =========================================================
   Specific points format
========================================================= */
function fmtPct01(x){ return `${Math.round(clamp(x,0,1)*100)}%`; }
function fmtDeg(x){ return `${Math.round(((x%360)+360)%360)}Â°`; }
function formatSpecificPoints(points){
  if(!points || !points.length) return {summary:"", full:""};
  const lines = points.slice(0, 10).map((p, idx)=>{
    const inS = pseClampPointS01(p.inS, p.inL);
    const outS = pseClampPointS01(p.outS, p.outL);
    return `${idx+1}) [${p.region}] IN(${fmtDeg(p.inH)}, ${fmtPct01(inS)}, ${fmtPct01(p.inL)}) â†’ OUT(${fmtDeg(p.outH)}, ${fmtPct01(outS)}, ${fmtPct01(p.outL)})`;
  });
  const full = points.map((p, idx)=>{
    const inS = pseClampPointS01(p.inS, p.inL);
    const outS = pseClampPointS01(p.outS, p.outL);
    return `${idx+1}) [${p.region}] IN(H ${fmtDeg(p.inH)} / S ${fmtPct01(inS)} / L ${fmtPct01(p.inL)})  â†’  OUT(H ${fmtDeg(p.outH)} / S ${fmtPct01(outS)} / L ${fmtPct01(p.outL)})`;
  }).join("\n");
  return {summary: lines.join("\n"), full};
}

/* =========================================================
   Analyze
========================================================= */
async function analyzeAll(){
  const btn = document.getElementById("btnAnalyze");
  const spin = document.getElementById("spin");
  const btnText = document.getElementById("btnText");

  if(!refFileState){ alert("íƒ€ê²Ÿ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
  if(shotMode==="two" && !origFileState){ alert("2ì¥ ëª¨ë“œì—ì„œëŠ” ì›ë³¸ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }

  btn.disabled = true;
  spin.style.display = "inline-block";
  btnText.textContent = "ë¶„ì„ ì¤‘â€¦";
  document.getElementById("resultCard").classList.add("hide");

  try{
    initWorker();

    const maxDim = parseInt(document.getElementById("maxDim").value, 10);
    const stridePx = (maxDim >= 1280) ? 8 : 10;
    const enableSpecPoints = (document.getElementById("specPoints").value === "on");

    const wc = document.getElementById("workCanvas");

    // ref
    const refOri = await getExifOrientation(refFileState);
    const bmR = await decodeToImageBitmap(refFileState);
    const refSize = drawScaledToCanvas(wc, bmR, maxDim, refOri);
    const refId = getImageDataFromCanvas(wc);

    let ai = {type:"fallback", note:"-"};
    let cocoTop = null;

    if(userMode === "auto"){
      await ensureAIModelsLoaded();
      await ensureCocoLoadedIfNeeded();

      ai = await detectAiType(wc);

      if(cocoModel){
        cocoTop = await cocoDetectTopIfEnabled(wc);
        if(cocoTop && cocoTop.class === "person"){
          const scoreOK = (cocoTop.score || 0) >= 0.65;
          const areaOK  = (cocoTop.areaRatio || 0) >= 0.08;
          if(scoreOK && areaOK){
            ai = {type:"portrait", note:`AI: ì‚¬ëŒ(person) ê°ì§€(ì•ˆì •)`};
          }
        }
      }
    }

    // orig (2-shot)
    let origId = null;
    if(shotMode === "two"){
      const origOri = await getExifOrientation(origFileState);
      const bmO = await decodeToImageBitmap(origFileState);

      const ctx = wc.getContext("2d", {willReadFrequently:true});
      wc.width = refSize.w; wc.height = refSize.h;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.clearRect(0,0,refSize.w, refSize.h);

      const tmp = document.createElement("canvas");
      drawScaledToCanvas(tmp, bmO, Math.max(refSize.w, refSize.h), origOri);
      ctx.drawImage(tmp, 0, 0, refSize.w, refSize.h);
      origId = ctx.getImageData(0,0,refSize.w, refSize.h);

      ctx.clearRect(0,0,refSize.w, refSize.h);
      ctx.drawImage(bmR, 0, 0, refSize.w, refSize.h);
    }

    const result = await new Promise((resolve, reject)=>{
      const onMsg = (ev)=>{ cleanup(); resolve(ev.data); };
      const onErr = (err)=>{ cleanup(); reject(err); };
      const cleanup = ()=>{
        worker.removeEventListener("message", onMsg);
        worker.removeEventListener("error", onErr);
      };
      worker.addEventListener("message", onMsg);
      worker.addEventListener("error", onErr);

      const refBuf = refId.data.buffer;
      if(origId){
        const origBuf = origId.data.buffer;
        worker.postMessage(
          { origBuf, refBuf, hasOrig:true, aiType:ai.type, mode:userMode, stridePx, enableSpecPoints },
          [origBuf, refBuf]
        );
      }else{
        worker.postMessage(
          { refBuf, hasOrig:false, aiType:ai.type, mode:userMode, stridePx, enableSpecPoints },
          [refBuf]
        );
      }
    });

    if(!result || !result.ok) throw new Error("Worker result invalid");

    // PSE guard
    if(Array.isArray(result.axes)){
      result.axes = result.axes.map(ax=>{
        const avgL01 = (typeof ax.avgL01 === "number") ? ax.avgL01 : 0.5;
        return pseGuardAxisAdjust(ax, avgL01);
      });
    }

    // overlay
    const presetKey = document.getElementById("fujiPreset").value;
    const strengthVal = parseInt(document.getElementById("presetStrength").value, 10);
    const strength01 = (presetKey === "off" || strengthVal===0) ? 0 : (strengthVal/100);

    let finalRes = result;

    // ê¸°ë³¸: PSE ë§¤í•‘ìš© blendëŠ” ìœ ì§€
    if(presetKey !== "off" && strength01 > 0){
      const p = FUJI_PRESETS[presetKey];

      finalRes.contrast = clamp(Math.round(lerp(finalRes.contrast, p.contrast, strength01)), -4, 4);
      finalRes.sat      = clamp(Math.round(lerp(finalRes.sat,      p.sat,      strength01)), -4, 4);
      finalRes.tone     = clamp(Math.round(lerp(finalRes.tone,     p.tone,     strength01)), -4, 4);

      const pLUT = curve5ToLUT(p.curve5);
      const outLUT = new Uint8Array(256);
      for(let i=0;i<256;i++){
        outLUT[i] = clamp(Math.round(lerp(finalRes.toneLUT[i], pLUT[i], strength01)), 0, 255);
      }
      for(let i=1;i<256;i++){ if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1]; }
      finalRes.toneLUT = outLUT;

      const m = {};
      (finalRes.axes||[]).forEach(a=> m[a.axis]=a);
      ["R","Y","G","C","B","M"].forEach(k=>{
        if(!m[k] || !p.axes[k]) return;
        m[k].canonH = clamp(Math.round(lerp(m[k].canonH, p.axes[k].H, strength01)), -30, 30);
        m[k].canonS = clamp(Math.round(lerp(m[k].canonS, p.axes[k].S, strength01)), -30, 30);
        m[k].canonL = clamp(Math.round(lerp(m[k].canonL, p.axes[k].L, strength01)), -30, 30);
        m[k] = pseGuardAxisAdjust(m[k], m[k].avgL01 ?? 0.5);
      });
      finalRes.axes = ["R","Y","G","C","B","M"].map(k=>m[k]).filter(Boolean);

      // âœ… Classic Negative: í”„ë¦¬ë·° ì „ìš© FXë¥¼ lastRecipeì— ì‹¤ì–´ì¤Œ (í”„ë¦¬ë·° ì •í™•ë„)
      if(presetKey === "classic_negative" && FUJI_PRESETS.classic_negative.previewFx){
        const fx = FUJI_PRESETS.classic_negative.previewFx;
        finalRes.previewFx = {
          rgbMatrix: fx.rgbMatrix,
          satMul: lerp(1.0, fx.satMul, strength01),
          hslRegions: fx.hslRegions
        };
      }else{
        finalRes.previewFx = null;
      }
    }else{
      finalRes.previewFx = null;
    }

    finalRes.aiTypeDetected = ai.type;
    finalRes.aiNote = ai.note;
    finalRes.cocoTop = cocoTop;

    finalRes.baseHint = `${finalRes.base || "í‘œì¤€"}${(presetKey!=="off" && strength01>0) ? (" + "+FUJI_PRESETS[presetKey].name+" "+Math.round(strength01*100)+"%") : ""}`;

    const curveTxt = [0,64,128,192,255].map(x=>`IN ${x} â†’ OUT ${finalRes.toneLUT[x]}`).join("\n");
    const axesTxt = (finalRes.axes||[]).map(a=>{
      const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
      const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
      const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
      return `${a.axis}: H${H}  S${S}  L${L}`;
    }).join("\n");

    const wb = finalRes.wb;
    const wbText = wb?.ok ? `K ${wb.kelvin} Â· Shift ${wb.abLabel} / ${wb.gmLabel}` : `WB ë¶„ì„ ë¶ˆê°€`;
    const wbRel = wb?.ok ? `${Math.round((wb.reliability||0.2)*100)}%` : `ë‚®ìŒ`;

    const skin = finalRes.skin || {ratio:0, highlightRisk:0, sampled:0, source:"none"};
    const exp  = finalRes.exposure || {shadowRatio:0, highlightRatio:0, midRatio:0, note:"-"};
    const reg  = finalRes.regions || {sky:0, foliage:0, skin:0, valid:0};

    const shotLabel = (shotMode==="one") ? "1ì¥" : "2ì¥";
    const modeLabel = `${shotLabel} / ${modeName(userMode)}${(userMode==="auto") ? (" ("+finalRes.aiNote+")") : ""}`;

    const sp = formatSpecificPoints(finalRes.specificPoints || []);
    document.getElementById("specPill").classList.toggle("hide", !enableSpecPoints);

    if(!enableSpecPoints){
      document.getElementById("sumSpecific").textContent = "-";
    }else if(shotMode !== "two"){
      document.getElementById("sumSpecific").textContent = "2ì¥ ëª¨ë“œì—ì„œë§Œ ìƒì„±ë©ë‹ˆë‹¤. (ì›ë³¸+íƒ€ê²Ÿ í•„ìš”)";
    }else if((finalRes.specificPoints||[]).length === 0){
      const dbg = finalRes.spDebug || {};
      document.getElementById("sumSpecific").textContent =
        `í¬ì¸íŠ¸ 0ê°œ\n- ë””ë²„ê·¸: minCount ${dbg.minCount ?? "?"}, cand ${dbg.candidates ?? "?"}, note ${dbg.note ?? "-"}`;
    }else{
      const dbg = finalRes.spDebug || {};
      document.getElementById("sumSpecific").textContent =
        sp.summary + `\n\n[dbg] minCount ${dbg.minCount}, cand ${dbg.candidates}, note ${dbg.note}`;
    }

    document.getElementById("sumMode").textContent = modeLabel;
    document.getElementById("sumBase").textContent = finalRes.baseHint;
    document.getElementById("sumBasic").textContent = `Contrast ${finalRes.contrast} Â· Saturation ${finalRes.sat} Â· Tone ${finalRes.tone}`;
    document.getElementById("sumLift").textContent = finalRes.lift?.isLifted ? `+${finalRes.lift.liftPx}px` : "ì—†ìŒ";
    document.getElementById("sumWB").textContent = wbText;
    document.getElementById("sumWBRel").textContent = wbRel;
    document.getElementById("sumCurve").textContent = curveTxt;
    document.getElementById("sumColors").textContent = axesTxt;

    const cocoLine = finalRes.cocoTop
      ? `COCO Top: ${finalRes.cocoTop.class} (${Math.round(finalRes.cocoTop.score*100)}%) area ${Math.round(finalRes.cocoTop.areaRatio*100)}%`
      : `COCO Top: -`;

    const fxLine = (presetKey==="classic_negative" && strength01>0)
      ? `ClassicNeg MatrixFX: ON (preview only)`
      : `ClassicNeg MatrixFX: -`;

    document.getElementById("sumExtra").textContent =
      `PSE-HSLGuard: ON Â· Skin ${Math.round((skin.ratio||0)*100)}% Â· ` +
      `Regions Sky ${Math.round((reg.sky||0)*100)}% / Fol ${Math.round((reg.foliage||0)*100)}% Â· ` +
      `Exposure: ${exp.note} (Hi ${Math.round(exp.highlightRatio*100)}%, Sh ${Math.round(exp.shadowRatio*100)}%) Â· ` +
      `${cocoLine} Â· ${fxLine}`;

    // Store lastRecipe for preview(Recipe mode)
    lastRecipe = {
      name: "LastRecipe",
      contrast: finalRes.contrast,
      sat: finalRes.sat,
      tone: finalRes.tone,
      toneLUT: finalRes.toneLUT,
      axes: (finalRes.axes||[]).map(a=>({axis:a.axis, canonH:a.canonH, canonS:a.canonS, canonL:a.canonL, avgL01:a.avgL01 ?? 0.5})),
      specificPoints: finalRes.specificPoints || [],
      baseHint: finalRes.baseHint,
      wb: finalRes.wb,
      previewFx: finalRes.previewFx || null, // âœ… í”„ë¦¬ë·° ë Œë”ì— ë°˜ì˜
      meta: `Last analysis (${modeLabel})`
    };
    refreshPreviewReady();

    if(prevFileState && document.getElementById("previewMode").value === "recipe"){
      queuePreviewRender("analysisComplete");
    }

    const presetLabel = (presetKey==="off" || strength01===0)
      ? "Look Overlay: OFF"
      : `Look Overlay: ${FUJI_PRESETS[presetKey].name} (${Math.round(strength01*100)}%)`;

    summaryText =
`[Canon Recipe Generator Pro v11.4]
- Mode: ${modeLabel}
- ${presetLabel}
- Base: ${finalRes.baseHint}
- Basic: Contrast ${finalRes.contrast}, Sat ${finalRes.sat}, Tone ${finalRes.tone}
- WB: ${wbText} (Rel ${wbRel})
- PSE-HSLGuard: ON
- ${fxLine}
- ${cocoLine}

[Curve]
${curveTxt}

[6-Axis]
${axesTxt}
${enableSpecPoints ? ("\n[Specific Colors Points - Top]\n"+sp.summary) : ""}
`;

    const warnBlock = (finalRes.warnings && finalRes.warnings.length)
      ? ("[âš ï¸ Warnings]\n" + finalRes.warnings.map((w,i)=>`${i+1}) ${w}`).join("\n") + "\n\n")
      : "";

    const spFullBlock = (enableSpecPoints && shotMode==="two" && (finalRes.specificPoints||[]).length)
      ? (`[Specific Colors Points]\n${sp.full}\n\n`)
      : "";

    fullText =
`==================================================
 Canon Recipe Generator Pro v11.4 (ClassicNeg Matrix)
==================================================
Shot: ${shotMode==="one"?"1-shot(target)":"2-shot(orig+target)"}
Mode: ${modeName(userMode)}${(userMode==="auto") ? (" / "+finalRes.aiNote) : ""}
${presetLabel}
${cocoLine}
PSE-HSLGuard: ON
${fxLine}

${warnBlock}[0) WB Suggest]
- ${wbText}
- Reliability: ${wbRel}

[1) Base]
- ${finalRes.baseHint}
- Reason: ${finalRes.baseReason || "-"}

[2) Basic]
- Contrast: ${finalRes.contrast}
- Saturation: ${finalRes.sat}
- Tone: ${finalRes.tone}
- Black Lift: ${finalRes.lift?.isLifted ? ("ON (+"+finalRes.lift.liftPx+"px)") : "OFF"}

[3) Tone Curve (INâ†’OUT)]
${curveTxt}

[4) 6-Axis (Canon PSE H/S/L)]
${finalRes.axes.map(a=>{
  const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
  const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
  const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
  return `[${a.axis}] H:${H}  S:${S}  L:${L}`;
}).join("\n")}

${spFullBlock}==================================================`;

    document.getElementById("reportBox").textContent = fullText;

    document.getElementById("resultCard").classList.remove("hide");
    setTab("sum");
    document.getElementById("resultCard").scrollIntoView({behavior:"smooth"});

  }catch(e){
    console.error(e);
    alert(
`ì˜¤ë¥˜ ë°œìƒ.

í™•ì¸:
- HEIC/HEIFë©´ JPGë¡œ ë³€í™˜
- ì„±ëŠ¥ ë¶€ì¡±ì´ë©´ 1024 + Specific Points OFF
ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.`
    );
  }finally{
    spin.style.display = "none";
    refreshReady();
  }
}

/* =========================================================
   Clipboard
========================================================= */
async function copyTextSafe(txt){
  try{
    await navigator.clipboard.writeText(txt);
    return true;
  }catch(e){
    try{
      const ta=document.createElement("textarea");
      ta.value=txt;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      ta.style.top="0";
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      return true;
    }catch(e2){
      return false;
    }
  }
}
async function copySummary(){
  if(!summaryText) return;
  const ok = await copyTextSafe(summaryText);
  alert(ok ? "ìš”ì•½ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}
async function copyFull(){
  if(!fullText) return;
  const ok = await copyTextSafe(fullText);
  alert(ok ? "ì „ì²´ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}

/* =========================================================
   Events
========================================================= */
document.getElementById("previewMode").addEventListener("change", ()=>{
  updatePreviewLabels();
  refreshPreviewReady();
  if(prevFileState) queuePreviewRender("previewModeChange");
});
document.getElementById("previewDim").addEventListener("change", ()=>{
  refreshPreviewReady();
  if(prevFileState) queuePreviewRender("previewDimChange");
});
document.getElementById("previewStrength").addEventListener("input", ()=>{
  updatePreviewLabels();
  if(prevFileState) queuePreviewRender("previewStrength");
});
document.getElementById("btnPreviewApply").addEventListener("click", ()=>{
  if(prevFileState) queuePreviewRender("manualClick");
});
document.getElementById("btnPreviewReset").addEventListener("click", ()=>{
  split01 = 0.5;
  drawSplitFromCache();
});
document.getElementById("btnPreviewSave").addEventListener("click", ()=>{
  savePreviewPNG();
});
document.getElementById("fujiPreset").addEventListener("change", ()=>{
  updatePresetLabel();
  refreshPreviewReady();
  if(prevFileState && document.getElementById("previewMode").value === "preset"){
    queuePreviewRender("presetChange");
  }
});
document.getElementById("presetStrength").addEventListener("input", ()=>{
  updateStrengthLabel();
  updatePresetLabel();
  if(prevFileState && document.getElementById("previewMode").value === "preset"){
    queuePreviewRender("presetStrength");
  }
});
document.getElementById("aiBoost").addEventListener("change", ()=>{
  document.getElementById("aiBoostLabel").textContent = (document.getElementById("aiBoost").value==="coco") ? "ACCURACY" : "FAST";
});
document.getElementById("specPoints").addEventListener("change", ()=>{
  document.getElementById("specPointsLabel").textContent = (document.getElementById("specPoints").value==="on") ? "ON" : "OFF";
});

/* =========================================================
   Boot
========================================================= */
window.onload = ()=>{
  setupDropZone("dropPrev","prevFile","thumbPrev","filePrev", f=>{ prevFileState=f; });
  setupDropZone("dropOrig","origFile","thumbOrig","fileOrig", f=>{ origFileState=f; });
  setupDropZone("dropRef","refFile","thumbRef","fileRef", f=>{ refFileState=f; });

  initWorker();
  bindPreviewDrag();

  // Look Overlay ê¸°ë³¸ê°’ OFF
  document.getElementById("fujiPreset").value = "off";
  updateStrengthLabel();
  updatePresetLabel();

  document.getElementById("aiBoostLabel").textContent = "FAST";
  document.getElementById("specPointsLabel").textContent = "ON";

  updatePreviewLabels();
  refreshPreviewReady();
  setPvMeta("ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ì„¸ìš”");

  setShot("one");
  setMode("auto");
  setTab("sum");

  setAIUI("idle", "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)");

  refreshReady();
};
</script>
</body>
</html>