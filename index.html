<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Canon Recipe & Look Overlay (v9.3 LazyAI+WorkerXfer+PresetUX)</title>

  <!-- AI (ì˜µì…˜ / ìë™ ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#94a3b8; --text:#f1f5f9;
      --line:#263456; --brand:#ff3f34; --ok:#10b981; --warn:#f59e0b;
      --cyan:#06b6d4; --black:#020617; --radius: 16px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0; font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Noto Sans KR", system-ui, sans-serif;
      background: radial-gradient(1100px 520px at 15% 0%, rgba(255,63,52,0.16), transparent 60%),
                  radial-gradient(900px 520px at 85% 0%, rgba(6,182,212,0.16), transparent 60%),
                  var(--bg);
      color:var(--text);
      padding: 16px;
      line-height: 1.5;
    }
    .app{ max-width: 1020px; margin: 0 auto; padding-bottom: 48px; }

    .header{ display:flex; flex-direction:column; gap:10px; margin-bottom:18px; }
    .title h1{ margin:0; font-size:20px; letter-spacing:-0.4px; }
    .title p{ margin:6px 0 0; color:var(--muted); font-size:13px; word-break: keep-all; }

    .badges{ display:flex; gap:8px; flex-wrap:wrap; }
    .badge{
      border:1px solid var(--line); background: rgba(18,26,51,0.7);
      padding:6px 12px; border-radius:999px; font-size:11px; font-weight:800;
      display:flex; gap:6px; align-items:center;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted); }
    .dot.ok{ background:var(--ok); } .dot.warn{ background:var(--warn); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 860px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background: rgba(18,26,51,0.86);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 12px 26px rgba(0,0,0,0.34);
      overflow:hidden;
    }
    .card-h{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--line);
      background: rgba(2,6,23,0.35);
    }
    .card-h strong{ font-size:14px; }
    .step{
      font-size:12px; color:var(--muted);
      padding:4px 10px; border:1px solid var(--line);
      border-radius:999px; background: rgba(2,6,23,0.35);
      font-weight:900;
      white-space:nowrap;
    }
    .card-b{ padding:16px; }

    .seg{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:14px;
      margin-bottom:12px;
    }
    .seg .label{ color:var(--muted); font-size:12px; font-weight:900; margin-bottom:8px; }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:10px 14px;
      border-radius:999px;
      font-size:13px;
      font-weight:900;
      cursor:pointer;
      transition:0.15s;
      flex: 1 1 auto;
      text-align:center;
      user-select:none;
    }
    .chip.active{
      border-color: var(--brand);
      background: rgba(255,63,52,0.15);
      color: #ff8b86;
      box-shadow: 0 0 0 2px rgba(255,63,52,0.10) inset;
    }

    .uploader{ display:flex; flex-direction:column; gap:12px; }
    .drop{
      border:2px dashed var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:18px;
      transition: 0.15s;
      cursor:pointer;
      min-height: 140px;
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      align-items:center;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .drop.dragover{ border-color: var(--ok); background: rgba(16,185,129,0.10); }
    .drop .label{ font-weight:950; font-size:14px; }
    .drop .hint{ color:var(--muted); font-size:12px; line-height:1.45; }
    .drop input{ display:none; }
    .thumb{
      width:100%;
      display:none;
      border-radius:10px;
      max-height:140px;
      object-fit:cover;
      border:1px solid var(--line);
    }
    .filename{
      font-size:12px;
      color: var(--cyan);
      font-weight:900;
      display:none;
      word-break:break-all;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 12px; }
    .kv{
      flex:1;
      display:flex; justify-content:space-between; align-items:center;
      font-size:13px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:10px 12px;
      border-radius:12px;
      gap:10px;
    }
    .kv b{ font-weight:950; }
    .kv select, .kv input[type="range"]{
      width: 54%;
      background: rgba(18,26,51,0.9);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-weight:800;
    }
    .kv .val{ color: var(--cyan); font-weight:950; white-space:nowrap; }

    .btn{
      border:0;
      border-radius:14px;
      padding:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      font-size:14px;
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
    }
    .btn.primary{ background: var(--brand); color:white; }
    .btn.primary:active{ filter: brightness(0.92); transform: scale(0.985); }
    .btn.ghost{ background: rgba(2,6,23,0.25); border:1px solid var(--line); color: var(--text); }
    .btn.lut{ background: var(--cyan); color: #001018; }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none !important; }

    .mini{
      color:var(--muted);
      font-size:12px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:12px;
      word-break: keep-all;
      line-height: 1.55;
    }

    /* Tabs */
    .tabs{
      display:flex; gap:8px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:8px;
      border-radius:14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .tabs .left{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:8px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      user-select:none;
    }
    .tab.active{
      border-color: var(--ok);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(16,185,129,0.12) inset;
    }
    .tabHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(2,6,23,0.35);
      white-space:nowrap;
    }

    .summaryCard{ display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px; }
    .pill{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:14px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .pill .k{ color:var(--muted); font-size:12px; margin-bottom:4px; }
    .pill .v{ font-weight:950; font-size: 14px; line-height:1.4; }
    .pill .v.ok{ color:var(--ok); } .pill .v.warn{ color:var(--warn); } .pill .v.cyan{ color:var(--cyan); }

    .report{
      margin-top:12px;
      background: var(--black);
      color: var(--ok);
      border:1px solid rgba(16,185,129,0.32);
      border-radius:14px;
      padding:16px;
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size:13px;
      overflow-x:auto;
      line-height:1.62;
    }

    .spinner{
      width:18px; height:18px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
      display:none;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }

    .hide{ display:none !important; }
    canvas{ display:none; }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <h1>ğŸ“· Canon Recipe Generator <span style="color:var(--cyan); font-size:14px;">v9.3 LazyAI+WorkerXfer</span></h1>
        <p>
          âœ… <b>1ì¥(íƒ€ê²Ÿë§Œ) / 2ì¥(ì›ë³¸+íƒ€ê²Ÿ)</b> ì§€ì› Â· âœ… AI ìë™(ì„ íƒ/ì§€ì—°ë¡œë”©) Â· âœ… <b>Look Overlay</b><br/>
          âœ… <b>EXIF íšŒì „ ë³´ì •</b> Â· âœ… <b>HEIC ì•ˆë‚´ ê°•í™”</b> Â· âœ… <b>WB(ì¼ˆë¹ˆ/Shift) ì¶”ì²œ</b><br/>
          â€œë£©(í•„ë¦„/ì‹œë„¤ë§ˆ)ì„ ìºë…¼ PSEë¡œ?â€ â†’ <b>ë¶„ì„ ê²°ê³¼ì— Look Preset ê°ì„±ì„ â€˜ì˜¤ë²„ë ˆì´â€™</b> í•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ì•ˆì „í•˜ê³  ê·¸ëŸ´ë“¯í•©ë‹ˆë‹¤.
        </p>
      </div>
      <div class="badges">
        <div class="badge"><span id="dotAI" class="dot warn"></span><span id="aiText">AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)</span></div>
        <div class="badge"><span id="dotO" class="dot"></span> ì›ë³¸(ì„ íƒ)</div>
        <div class="badge"><span id="dotR" class="dot"></span> íƒ€ê²Ÿ(í•„ìˆ˜)</div>
      </div>
    </div>

    <div class="grid">
      <!-- STEP 1 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 1. ì‚¬ì§„ ë„£ê¸°</strong>
          <span class="step">1/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ë°©ì‹</div>
            <div class="chips">
              <div class="chip active" data-shot="one" onclick="setShot('one')">1ì¥ ëª¨ë“œ (íƒ€ê²Ÿë§Œ)</div>
              <div class="chip" data-shot="two" onclick="setShot('two')">2ì¥ ëª¨ë“œ (ì›ë³¸+íƒ€ê²Ÿ)</div>
            </div>
          </div>

          <div class="uploader">
            <div class="drop hide" id="dropOrig">
              <div class="label">ì›ë³¸ (ì¶”ì²œ: Standard/Neutral)</div>
              <div class="hint">
                ê°™ì€ ì¥ì†Œ/í”¼ì‚¬ì²´ì˜ â€œê¸°ë³¸ í†¤â€ ì‚¬ì§„ì´ ê°€ì¥ ì¢‹ìŠµë‹ˆë‹¤.<br/>
                (ì˜ˆ: ìºë…¼ í‘œì¤€/ë‰´íŠ¸ëŸ´ë¡œ ì°ì€ ì›ë³¸)
              </div>
              <input id="origFile" type="file" accept="image/*"/>
              <img id="thumbOrig" class="thumb" alt="orig"/>
              <div id="fileOrig" class="filename"></div>
            </div>

            <div class="drop" id="dropRef">
              <div class="label">íƒ€ê²Ÿ (ì›í•˜ëŠ” ìƒ‰ê°)</div>
              <div class="hint">
                ë§Œë“¤ê³  ì‹¶ì€ ì˜í™”/í•„ë¦„ ëŠë‚Œì˜ ì°¸ê³  ì‚¬ì§„.<br/>
                <b>ì´ˆë³´ì íŒ:</b> ì¤‘ê°„í†¤ì´ ë§ê³ (í•˜ëŠ˜/ë²½/í”¼ë¶€) ê³¼í•œ ì—­ê´‘ì´ ì•„ë‹Œ ì‚¬ì§„ì´ ì•ˆì •ì ì…ë‹ˆë‹¤.<br/>
                <b>ì£¼ì˜:</b> iPhone <b>HEIC</b>ëŠ” ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦¬ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš” â†’ <b>JPGë¡œ ë³€í™˜</b> í›„ ì—…ë¡œë“œ ì¶”ì²œ.
              </div>
              <input id="refFile" type="file" accept="image/*"/>
              <img id="thumbRef" class="thumb" alt="ref"/>
              <div id="fileRef" class="filename"></div>
            </div>
          </div>

          <div class="mini" style="margin-top:12px;">
            <b>1ì¥ ëª¨ë“œ(íƒ€ê²Ÿë§Œ)</b>ëŠ” â€œëŒ€ëµì ì¸ ë£© ë ˆì‹œí”¼â€ë¥¼ ë¹ ë¥´ê²Œ ì–»ëŠ” ìš©ë„ì…ë‹ˆë‹¤.<br/>
            <b>2ì¥ ëª¨ë“œ</b>ëŠ” â€œë‚´ ì›ë³¸ â†’ íƒ€ê²Ÿâ€ ë§¤ì¹­ì´ë¼ ë” ì •êµí•©ë‹ˆë‹¤. (ê°€ëŠ¥í•˜ë©´ 2ì¥ ì¶”ì²œ)<br/>
            <b>v9.3</b>: AIëŠ” <b>ë¶„ì„ ë²„íŠ¼ ëˆ„ë¥¼ ë•Œë§Œ ë¡œë”©</b>í•©ë‹ˆë‹¤(ì²« ì§„ì… ì†ë„ ê°œì„ ).
          </div>
        </div>
      </div>

      <!-- STEP 2 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 2. ë¶„ì„ + Look Overlay + WB ì œì•ˆ</strong>
          <span class="step">2/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ëª¨ë“œ (í„°ì¹˜)</div>
            <div class="chips">
              <div class="chip active" data-mode="auto" onclick="setMode('auto')">AI ìë™</div>
              <div class="chip" data-mode="portrait" onclick="setMode('portrait')">ì¸ë¬¼</div>
              <div class="chip" data-mode="landscape" onclick="setMode('landscape')">í’ê²½</div>
              <div class="chip" data-mode="snap" onclick="setMode('snap')">ìŠ¤ëƒ…</div>
              <div class="chip" data-mode="night" onclick="setMode('night')">ì•¼ê²½</div>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í•´ìƒë„</b>
              <select id="maxDim">
                <option value="1024" selected>1024px (ê¶Œì¥)</option>
                <option value="1280">1280px (ì •ë°€)</option>
              </select>
              <span class="val">ë¦¬ì‚¬ì´ì¦ˆ ë¶„ì„</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Look Overlay</b>
              <select id="fujiPreset">
                <option value="off" selected>Off (ë¶„ì„ë§Œ)</option>
                <optgroup label="Fuji Looks">
                  <option value="provia">Fuji_Provia (í‘œì¤€/ë°¸ëŸ°ìŠ¤)</option>
                  <option value="astia">Fuji_Astia (ë¶€ë“œëŸ¬ìš´ ì¸ë¬¼)</option>
                  <option value="reala">Fuji_Reala (ìì—°ìŠ¤ëŸ¬ìš´ ì»¬ëŸ¬)</option>
                  <option value="reala_ace">Fuji_RealaAce (ì„ ëª…+í”¼ë¶€ ì•ˆì •)</option>
                  <option value="velvia">Fuji_Velvia (ê³ ì±„ë„ í’ê²½)</option>
                  <option value="classic_chrome">Fuji_ClassicChrome (ì €ì±„ë„ ì‹œë„¤ë§ˆ)</option>
                  <option value="classic_negative">Fuji_ClassicNegative (ë„¤ê±°í‹°ë¸Œ ê°ì„±)</option>
                </optgroup>
                <optgroup label="Ricoh GR Looks">
                  <option value="gr_positive">GR_Positive (Unified)</option>
                </optgroup>
              </select>
              <span class="val" id="presetLabel">OFF</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í”„ë¦¬ì…‹ ê°•ë„</b>
              <input id="presetStrength" type="range" min="0" max="100" value="35"
                     oninput="updateStrengthLabel(); updatePresetLabel(); refreshReady();"/>
              <span class="val" id="strengthLabel">35%</span>
            </div>
          </div>

          <button id="btnAnalyze" class="btn primary" onclick="analyzeAll()" disabled>
            <span id="btnText">ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”</span>
            <span id="spin" class="spinner"></span>
          </button>

          <div class="mini" style="margin-top:12px;">
            <b>Look Overlay</b> = (ë¶„ì„ ê²°ê³¼)ì™€ (ì„ íƒí•œ ë£© í”„ë¦¬ì…‹) ì‚¬ì´ë¥¼ <b>ê°•ë„%</b>ë¡œ ì„ìŠµë‹ˆë‹¤.<br/>
            ê³¼í•˜ë©´ ê°•ë„ë¥¼ ë‚®ì¶”ì„¸ìš”. ëŒ€ì²´ë¡œ <b>20~45%</b>ê°€ ì œì¼ â€œê·¸ëŸ´ë“¯â€í•©ë‹ˆë‹¤.<br/>
            <b>WB ì œì•ˆ</b>ì€ íƒ€ê²Ÿì˜ í‰ê·  ìƒ‰ì˜¨ë„ ê¸°ë°˜ìœ¼ë¡œ <b>K(ì¼ˆë¹ˆ) + Shift(A/B, G/M)</b>ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤. (ì°¸ê³ ê°’)
          </div>
        </div>
      </div>

      <!-- STEP 3 -->
      <div class="card hide" style="grid-column: 1 / -1;" id="resultCard">
        <div class="card-h">
          <strong>STEP 3. ê²°ê³¼</strong>
          <span class="step" style="color:var(--ok); border-color:var(--ok);">ì™„ë£Œ</span>
        </div>
        <div class="card-b">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; gap:10px;">
              <button class="btn ghost" onclick="copySummary()" style="flex:1;">ğŸ“‹ ìš”ì•½ ë³µì‚¬</button>
              <button class="btn ghost" onclick="copyFull()" style="flex:1;">ğŸ“‹ ì „ì²´ ë³µì‚¬</button>
            </div>
          </div>

          <div class="tabs">
            <div class="left">
              <div class="tab active" data-tab="sum" onclick="setTab('sum')">ìš”ì•½ ë³´ê¸°</div>
              <div class="tab" data-tab="full" onclick="setTab('full')">ì „ì²´ ë³´ê¸°</div>
            </div>
            <div class="tabHint" id="tabHint">ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.</div>
          </div>

          <div class="summaryCard" id="summaryBox">
            <div class="pill">
              <div>
                <div class="k">ë¶„ì„ ëª¨ë“œ</div>
                <div class="v cyan" id="sumMode">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì¶”ì²œ ë² ì´ìŠ¤</div>
                <div class="v ok" id="sumBase">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">ê¸°ë³¸ ì¡°ì •</div>
                <div class="v" id="sumBasic">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ë¸”ë™ ë¦¬í”„íŠ¸</div>
                <div class="v" id="sumLift">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">WB ì œì•ˆ (íƒ€ê²Ÿ í‰ê· )</div>
                <div class="v cyan" id="sumWB">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì‹ ë¢°ë„</div>
                <div class="v" id="sumWBRel">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">í†¤ ì»¤ë¸Œ (IN â†’ OUT)</div>
                <div class="v" id="sumCurve" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">6ìƒ‰ì¶• (H / S / L)</div>
                <div class="v" id="sumColors" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="mini">
              <b>ğŸ“· ì…ë ¥ ìˆœì„œ (ìš”ì•½)</b><br/>
              0) WB(ì°¸ê³ ) = <b id="sumWB2">-</b><br/>
              1) Base = <b id="sumBase2">-</b><br/>
              2) Contrast = <b id="sumC2">-</b> / Saturation = <b id="sumSat2">-</b> / Color Tone = <b id="sumTone2">-</b><br/>
              3) Tone Curve = 5í¬ì¸íŠ¸ (IN â†’ OUT) ì…ë ¥<br/>
              4) Specific Colors = 6ìƒ‰ì¶• H/S/L ì…ë ¥
            </div>
          </div>

          <div id="fullBox" class="hide">
            <div id="reportBox" class="report"></div>
          </div>

          <canvas id="canvas"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* =========================================================
   ìƒíƒœ
========================================================= */
let shotMode = "one";       // one | two
let userMode = "auto";      // auto | portrait | landscape | snap | night
let viewTab  = "sum";

let origFileState = null;
let refFileState  = null;

let summaryText = "";
let fullText = "";

let worker = null;

// Lazy AI states
let faceModel = null;
let classifyModel = null;
let aiState = "idle"; // idle | loading | ready | failed
let aiStatusText = "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)";

/* =========================================================
   Look Presets (Fuji + Ricoh GR)
   - Canon PSE ë²”ìœ„(ê°€ì •): Contrast/Sat/Tone: -4~+4, 6ì¶• H/S/L: -30~+30
   âœ… PATCH: Velvia + ClassicNegativeë§Œ ë¶„ì„ ê¸°ë°˜ìœ¼ë¡œ ì •ë°€ ë³´ì •(ê¸°ì¡´ ê¸°ëŠ¥ ìœ ì§€)
========================================================= */
const FUJI_PRESETS = {
  off: null,

  // -----------------------
  // Fuji (prefix: Fuji_)
  // -----------------------
  provia: {
    name: "Fuji_Provia",
    base: "í‘œì¤€ (Standard)",
    contrast: +1, sat: +1, tone: 0,
    curve5: {0:0, 64:66, 128:128, 192:194, 255:255},
    axes: {
      R:{H:0,S:0,L:0}, Y:{H:0,S:0,L:0}, G:{H:0,S:0,L:0},
      C:{H:0,S:0,L:0}, B:{H:0,S:-2,L:0}, M:{H:0,S:0,L:0},
    }
  },
  astia: {
    name: "Fuji_Astia",
    base: "ì¸ë¬¼ì‚¬ì§„ (Portrait) ë˜ëŠ” ë‰´íŠ¸ëŸ´ (Neutral)",
    contrast: -1, sat: +1, tone: +1,
    curve5: {0:6, 64:78, 128:132, 192:198, 255:255},
    axes: {
      R:{H:+2,S:-6,L:+6}, Y:{H:-2,S:-6,L:+6}, G:{H:0,S:0,L:0},
      C:{H:0,S:0,L:0},  B:{H:0,S:-6,L:0},  M:{H:0,S:0,L:0},
    }
  },
  reala: {
    name: "Fuji_Reala",
    base: "í‘œì¤€ (Standard)",
    contrast: +1, sat: +1, tone: 0,
    curve5: {0:2, 64:70, 128:130, 192:194, 255:255},
    axes: {
      R:{H:0,S:-2,L:+2}, Y:{H:0,S:-2,L:+2}, G:{H:0,S:0,L:0},
      C:{H:0,S:0,L:0},   B:{H:0,S:-2,L:0},  M:{H:0,S:0,L:0},
    }
  },
  reala_ace: {
    name: "Fuji_RealaAce",
    base: "í‘œì¤€ (Standard) / ì¸ë¬¼ì‚¬ì§„ (Portrait)",
    contrast: +2, sat: +1, tone: +1,
    curve5: {0:2, 64:66, 128:128, 192:198, 255:255},
    axes: {
      R:{H:0,S:-2,L:+2}, Y:{H:0,S:-2,L:+2}, G:{H:0,S:0,L:0},
      C:{H:0,S:0,L:0},   B:{H:0,S:-2,L:0},  M:{H:0,S:0,L:0},
    }
  },

  /* =======================
     âœ… PATCHED: Fuji_Velvia (analysis-based)
     - í•µì‹¬: G/Y ì±„ë„ í­ë°œ + ë¯¸ë“œí†¤ ëŒ€ë¹„ + í•˜ëŠ˜/ë¬¼ìƒ‰ ê³¼í˜•ê´‘ ë°©ì§€
  ======================= */
  velvia: {
    name: "Fuji_Velvia",
    base: "í’ê²½ì‚¬ì§„ (Landscape)",

    contrast: +3,
    sat: +4,
    tone: -1,

    // ë¯¸ë“œí†¤ ëŒ€ë¹„ ê°•í™” + í•˜ì´ë¼ì´íŠ¸ëŠ” ê³¼í´ë¦½ ë°©ì§€(ì™„ë§Œ)
    curve5: {0:0, 64:56, 128:126, 192:210, 255:255},

    // G/Y ê°•, C/BëŠ” í´ë¦°+ë”¥, Mì€ ê³¼ë§ˆì  íƒ€ ë°©ì§€ë¡œ ìµœì†Œ
    axes: {
      R:{H: 0,  S:+6,  L: 0},
      Y:{H: 0,  S:+10, L:+2},
      G:{H:-6,  S:+18, L:-6},
      C:{H:-2,  S:+12, L:-6},
      B:{H:-4,  S:+10, L:-8},
      M:{H: 0,  S:+4,  L: 0},
    }
  },

  classic_chrome: {
    name: "Fuji_ClassicChrome",
    base: "ë‰´íŠ¸ëŸ´ (Neutral)",
    contrast: +1, sat: -3, tone: -1,
    curve5: {0:8, 64:76, 128:128, 192:184, 255:248},
    axes: {
      R:{H:0,S:-10,L:+2}, Y:{H:0,S:-14,L:+2}, G:{H:0,S:-6,L:0},
      C:{H:0,S:-6,L:0},   B:{H:0,S:-6,L:0},  M:{H:0,S:-4,L:0},
    }
  },

  /* =======================
     âœ… PATCHED: Fuji_ClassicNegative (analysis-based)
     - í•µì‹¬: í•˜ì´ë¼ì´íŠ¸ íƒˆìƒ‰/ë¡¤ì˜¤í”„ + ë¸”ë™ ë¦¬í”„íŠ¸ + ì¿¨ ì„€ë„ìš° + ìƒ‰ ì •ë¦¬
  ======================= */
  classic_negative: {
    name: "Fuji_ClassicNegative",
    base: "ë‰´íŠ¸ëŸ´ (Neutral)",

    contrast: +1,
    sat: -2,
    tone: -2,

    // ë¸”ë™ ë¦¬í”„íŠ¸ + í•˜ì´ë¼ì´íŠ¸ ì••ì¶•(roll-off)
    curve5: {0:12, 64:78, 128:128, 192:176, 255:238},

    // ìƒ‰ì„ 'ë°€ê¸°'ê°€ ì•„ë‹ˆë¼ 'ì •ë¦¬'
    axes: {
      R:{H:-4, S:-10, L:+6},
      Y:{H:-4, S:-14, L:+8},
      G:{H:+6, S:+2,  L:-4},
      C:{H:+4, S:+6,  L:-6},
      B:{H:+2, S:-8,  L:-6},
      M:{H: 0, S:-6,  L: 0},
    }
  },

  // -----------------------
  // Ricoh GR (Unified Positive Film)
  // -----------------------
  gr_positive: {
    name: "GR_Positive (Unified)",
    base: "í‘œì¤€ (Standard) ë˜ëŠ” ë‰´íŠ¸ëŸ´ (Neutral)",
    contrast: +2, sat: +2, tone: 0,
    curve5: {0:0, 64:60, 128:132, 192:198, 255:252},
    axes: {
      R:{H:0,  S:+8,  L:0},
      Y:{H:-2, S:+6,  L:+2},
      G:{H:-6, S:+2,  L:-6},
      C:{H:+2, S:+6,  L:-4},
      B:{H:-4, S:+10, L:-8},
      M:{H:0,  S:0,   L:0},
    }
  }
};

/* =========================================================
   UI helpers
========================================================= */
function setDot(id, state){
  const el = document.getElementById(id);
  el.className = "dot" + (state ? (" " + state) : "");
}
function clamp(v, a, b){ return v < a ? a : (v > b ? b : v); }
function lerp(a,b,t){ return a + (b-a)*t; }

function setTab(tab){
  viewTab = tab;
  document.querySelectorAll(".tab").forEach(el=>{
    el.classList.toggle("active", el.dataset.tab === tab);
  });
  const hint = document.getElementById("tabHint");
  if(tab === "sum"){
    hint.textContent = "ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.remove("hide");
    document.getElementById("fullBox").classList.add("hide");
  }else{
    hint.textContent = "ìƒì„¸ ë ˆì‹œí”¼ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.add("hide");
    document.getElementById("fullBox").classList.remove("hide");
  }
}

function setMode(mode){
  userMode = mode;
  document.querySelectorAll(".chip[data-mode]").forEach(el=>{
    el.classList.toggle("active", el.dataset.mode === mode);
  });
  refreshReady();
}

function setShot(mode){
  shotMode = mode; // one|two
  document.querySelectorAll(".chip[data-shot]").forEach(el=>{
    el.classList.toggle("active", el.dataset.shot === mode);
  });
  document.getElementById("dropOrig").classList.toggle("hide", shotMode !== "two");
  refreshReady();
}

function updateStrengthLabel(){
  const v = parseInt(document.getElementById("presetStrength").value, 10);
  document.getElementById("strengthLabel").textContent = v + "%";
}

function setStrengthEnabled(enabled){
  const s = document.getElementById("presetStrength");
  s.disabled = !enabled;
  s.style.opacity = enabled ? "1" : "0.5";
}

/* =========================================================
   í”„ë¦¬ì…‹ ë¼ë²¨/ìŠ¬ë¼ì´ë” UX ì•ˆì •í™”
========================================================= */
function updatePresetLabel(){
  const key = document.getElementById("fujiPreset").value;
  const strength = parseInt(document.getElementById("presetStrength").value, 10);

  if(key === "off"){
    document.getElementById("presetLabel").textContent = "OFF";
    setStrengthEnabled(false);
    return;
  }

  setStrengthEnabled(true);
  const name = FUJI_PRESETS[key]?.name || "LookPreset";
  document.getElementById("presetLabel").textContent = `ON: ${name} (${strength}%)`;
}

document.getElementById("fujiPreset").addEventListener("change", ()=>{
  updatePresetLabel();
  refreshReady();
});

/* =========================================================
   HEIC ì•ˆë‚´ ê°•í™”: ì„ íƒ ì‹œ ì¦‰ì‹œ ê²½ê³ 
========================================================= */
function isHeicFile(file){
  const name = (file?.name || "").toLowerCase();
  const type = (file?.type || "").toLowerCase();
  return (
    name.endsWith(".heic") || name.endsWith(".heif") ||
    type.includes("heic") || type.includes("heif")
  );
}
function maybeWarnHeic(file){
  if(isHeicFile(file)){
    alert(
`âš ï¸ HEIC/HEIF íŒŒì¼ì€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦¬ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.

ê¶Œì¥ í•´ê²°:
- iPhone: ì„¤ì • â†’ ì‚¬ì§„ â†’ 'ì „ì†¡ ë˜ëŠ” ì €ì¥' â†’ 'í˜¸í™˜ì„± ìš°ì„ '
- ë˜ëŠ” ì‚¬ì§„ ì•±ì—ì„œ ê³µìœ /ì €ì¥ ì‹œ JPGë¡œ ë³€í™˜ í›„ ì—…ë¡œë“œ

ê°€ëŠ¥í•˜ë©´ JPGë¡œ ë³€í™˜ í›„ ì¬ì‹œë„í•´ ì£¼ì„¸ìš”.`
    );
  }
}

/* =========================================================
   EXIF Orientation ì½ê¸° (JPEG í•œì • / ê²½ëŸ‰ íŒŒì„œ)
========================================================= */
async function getExifOrientation(file){
  try{
    const name = (file?.name || "").toLowerCase();
    const type = (file?.type || "").toLowerCase();
    const isJpeg = type.includes("jpeg") || type.includes("jpg") || name.endsWith(".jpg") || name.endsWith(".jpeg");
    if(!isJpeg) return 1;

    const buf = await file.slice(0, 256 * 1024).arrayBuffer();
    const view = new DataView(buf);

    if(view.getUint16(0, false) !== 0xFFD8) return 1;

    let offset = 2;
    const length = view.byteLength;

    while(offset < length){
      if(view.getUint8(offset) !== 0xFF) break;
      const marker = view.getUint8(offset + 1);
      offset += 2;

      if(marker === 0xD9 || marker === 0xDA) break;

      const segLen = view.getUint16(offset, false);
      if(segLen < 2) break;

      if(marker === 0xE1){
        const start = offset + 2;
        if(start + 6 <= length){
          const isExif =
            view.getUint8(start+0)===0x45 && view.getUint8(start+1)===0x78 &&
            view.getUint8(start+2)===0x69 && view.getUint8(start+3)===0x66 &&
            view.getUint8(start+4)===0x00 && view.getUint8(start+5)===0x00;

          if(isExif){
            const tiff = start + 6;
            if(tiff + 8 > length) return 1;

            const endian = view.getUint16(tiff, false);
            const little = (endian === 0x4949);
            const getU16 = (o)=> view.getUint16(o, little);
            const getU32 = (o)=> view.getUint32(o, little);

            const magic = getU16(tiff + 2);
            if(magic !== 0x002A) return 1;

            const ifd0Offset = getU32(tiff + 4);
            let ifd0 = tiff + ifd0Offset;
            if(ifd0 + 2 > length) return 1;

            const entries = getU16(ifd0);
            ifd0 += 2;
            for(let i=0;i<entries;i++){
              const ent = ifd0 + i*12;
              if(ent + 12 > length) break;
              const tag = getU16(ent + 0);
              if(tag === 0x0112){
                const type = getU16(ent + 2);
                const count = getU32(ent + 4);
                if(type === 3 && count === 1){
                  const val = getU16(ent + 8);
                  return val || 1;
                }
                return 1;
              }
            }
          }
        }
      }
      offset += segLen;
    }
    return 1;
  }catch(e){
    return 1;
  }
}

/* =========================================================
   ì—…ë¡œë“œ
========================================================= */
function setupDropZone(dropId, inputId, thumbId, nameId, onSetFile){
  const drop = document.getElementById(dropId);
  const input = document.getElementById(inputId);
  const thumb = document.getElementById(thumbId);
  const nameEl = document.getElementById(nameId);

  drop.addEventListener("click", ()=> input.click());
  drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("dragover"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("dragover"));
  drop.addEventListener("drop", (e)=>{
    e.preventDefault();
    drop.classList.remove("dragover");
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f); updatePreview(f, thumb, nameEl); refreshReady();
    }
  });
  input.addEventListener("change", ()=>{
    const f = input.files && input.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f); updatePreview(f, thumb, nameEl); refreshReady();
    }
  });
}
function updatePreview(file, imgEl, nameEl){
  nameEl.textContent = "âœ… " + file.name;
  nameEl.style.display = "block";
  const r = new FileReader();
  r.onload = (e)=>{ imgEl.src = e.target.result; imgEl.style.display = "block"; };
  r.readAsDataURL(file);
}

/* =========================================================
   AI ë¡œë”© ì§€ì—°(í•„ìš” ì‹œì—ë§Œ)
========================================================= */
function setAIUI(state, text){
  const dot = document.getElementById("dotAI");
  const label = document.getElementById("aiText");
  aiState = state;
  aiStatusText = text || aiStatusText;

  if(state === "ready"){
    dot.className = "dot ok";
  }else{
    dot.className = "dot warn";
  }
  label.textContent = aiStatusText;
}

async function ensureAIModelsLoaded(){
  if(aiState === "ready") return true;
  if(aiState === "loading") return false;

  setAIUI("loading", "AI ë¡œë”©ì¤‘â€¦(ìë™ ëª¨ë“œ)");
  try{
    await tf.ready();
    faceModel = await blazeface.load();
    classifyModel = await mobilenet.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ");
    return true;
  }catch(e){
    console.warn("AI ë¡œë”© ì‹¤íŒ¨(ìš°íšŒ):", e);
    setAIUI("failed", "AI ì‹¤íŒ¨(ìš°íšŒ) Â· ìˆ˜ë™/ëŒ€ì²´ë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}

/* =========================================================
   Ready ìƒíƒœ
========================================================= */
function refreshReady(){
  const hasRef = !!refFileState;
  const hasOrig = !!origFileState;

  setDot("dotR", hasRef ? "ok" : "");
  setDot("dotO", (shotMode === "two" && hasOrig) ? "ok" : "");

  const btn = document.getElementById("btnAnalyze");
  const btnText = document.getElementById("btnText");

  const readyForShot = (shotMode === "one") ? hasRef : (hasRef && hasOrig);
  btn.disabled = !readyForShot;

  if(!readyForShot){
    btnText.textContent = "ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”";
    return;
  }

  if(userMode === "auto" && aiState !== "ready"){
    btnText.textContent = "âš¡ ë¶„ì„ ì‹œì‘ (í•„ìš” ì‹œ AI ë¡œë”©)";
  }else{
    btnText.textContent = "âš¡ ë¶„ì„ ì‹œì‘";
  }
}

/* =========================================================
   ì´ë¯¸ì§€ ë””ì½”ë“œ + ë¦¬ì‚¬ì´ì¦ˆ
========================================================= */
async function fileToHTMLImage(file){
  return await new Promise((resolve, reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = (e)=>{
      URL.revokeObjectURL(url);
      reject(e);
    };
    img.src = url;
  });
}

async function decodeToImageBitmap(file){
  try{
    if(typeof createImageBitmap === "function"){
      return await createImageBitmap(file);
    }
    throw new Error("createImageBitmap not available");
  }catch(e){
    console.warn("createImageBitmap ì‹¤íŒ¨ â†’ fallback(Image):", e);
    return await fileToHTMLImage(file);
  }
}

function applyOrientationTransform(ctx, orientation, w, h){
  switch(orientation){
    case 2: ctx.translate(w, 0); ctx.scale(-1, 1); break;
    case 3: ctx.translate(w, h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0, h); ctx.scale(1, -1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1); break;
    case 6: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); break;
    case 7: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); ctx.scale(-1, 1); break;
    case 8: ctx.translate(0, h); ctx.rotate(-0.5*Math.PI); break;
    default: break;
  }
}

function drawScaledToImageData(bitmapOrImg, maxDim, orientation=1){
  const ow = bitmapOrImg.width;
  const oh = bitmapOrImg.height;

  if(orientation === 5 || orientation === 7) orientation = 1;

  const swapWH = (orientation>=5 && orientation<=8);
  const rw = swapWH ? oh : ow;
  const rh = swapWH ? ow : oh;

  const scale = Math.min(1, maxDim / Math.max(rw, rh));
  const tw = Math.max(1, Math.round(rw * scale));
  const th = Math.max(1, Math.round(rh * scale));

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  canvas.width = tw; canvas.height = th;

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,tw,th);

  ctx.save();
  applyOrientationTransform(ctx, orientation, tw, th);

  if(swapWH){
    ctx.drawImage(bitmapOrImg, 0, 0, th, tw);
  }else{
    ctx.drawImage(bitmapOrImg, 0, 0, tw, th);
  }

  ctx.restore();
  ctx.restore();

  return ctx.getImageData(0,0,tw,th);
}

/* =========================================================
   ToneCurve5pt -> LUT(256)
========================================================= */
function curve5ToLUT(curve5){
  const xs = [0,64,128,192,255];
  const ys = xs.map(x => clamp(Math.round(curve5[x]), 0, 255));
  const lut = new Uint8Array(256);

  for(let i=0;i<xs.length-1;i++){
    const x0=xs[i], x1=xs[i+1];
    const y0=ys[i], y1=ys[i+1];
    const dx = (x1 - x0);
    for(let x=x0; x<=x1; x++){
      const t = dx === 0 ? 0 : (x - x0) / dx;
      lut[x] = clamp(Math.round(lerp(y0, y1, t)), 0, 255);
    }
  }
  for(let i=1;i<256;i++){
    if(lut[i] < lut[i-1]) lut[i] = lut[i-1];
  }
  return lut;
}

/* =========================================================
   LUT/6ì¶•/ê¸°ë³¸ìŠ¬ë¼ì´ë” ì˜¤ë²„ë ˆì´
========================================================= */
function applyFujiOverlay(analysis, presetKey, strength01){
  if(!presetKey || presetKey === "off" || !FUJI_PRESETS[presetKey] || strength01 <= 0){
    return analysis;
  }
  const p = FUJI_PRESETS[presetKey];

  const outContrast = clamp(Math.round(lerp(analysis.contrast, p.contrast, strength01)), -4, 4);
  const outSat      = clamp(Math.round(lerp(analysis.sat,      p.sat,      strength01)), -4, 4);
  const outTone     = clamp(Math.round(lerp(analysis.tone,     p.tone,     strength01)), -4, 4);

  const pLUT = curve5ToLUT(p.curve5);
  const outLUT = new Uint8Array(256);
  for(let i=0;i<256;i++){
    outLUT[i] = clamp(Math.round(lerp(analysis.toneLUT[i], pLUT[i], strength01)), 0, 255);
  }
  for(let i=1;i<256;i++){
    if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1];
  }

  const outAxes = analysis.axes.map(ax=>{
    const key = ax.axis;
    const pa = p.axes[key];
    if(!pa) return {...ax};
    return {
      ...ax,
      canonH: clamp(Math.round(lerp(ax.canonH, pa.H, strength01)), -30, 30),
      canonS: clamp(Math.round(lerp(ax.canonS, pa.S, strength01)), -30, 30),
      canonL: clamp(Math.round(lerp(ax.canonL, pa.L, strength01)), -30, 30),
    };
  });

  const baseHint = `${analysis.base} + ${p.name} ${Math.round(strength01*100)}%`;

  return {
    ...analysis,
    contrast: outContrast,
    sat: outSat,
    tone: outTone,
    toneLUT: outLUT,
    axes: outAxes,
    baseHint
  };
}

/* =========================================================
   Worker (1ì¥/2ì¥ ëª¨ë‘ ì§€ì›)
========================================================= */
function initWorker(){
  if(worker) return;

  const code = `
    function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0;
      const l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h*360, s, l];
    }

    function srgbToLin(u){
      u/=255;
      return (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
    }

    function linRgbToXyz(lr,lg,lb){
      const X = lr*0.4124564 + lg*0.3575761 + lb*0.1804375;
      const Y = lr*0.2126729 + lg*0.7151522 + lb*0.0721750;
      const Z = lr*0.0193339 + lg*0.1191920 + lb*0.9503041;
      return [X,Y,Z];
    }

    function xyToCct(x,y){
      const n = (x - 0.3320) / (y - 0.1858 + 1e-9);
      const cct = 449*n*n*n + 3525*n*n + 6823.3*n + 5520.33;
      return cct;
    }

    function xyToUv(x,y){
      const denom = (-2*x + 12*y + 3);
      const u = (4*x) / (denom + 1e-9);
      const v = (9*y) / (denom + 1e-9);
      return [u,v];
    }

    function wbShiftFromUv(u,v){
      const u0 = 0.1978398, v0 = 0.4683363;
      const du = u - u0;
      const dv = v - v0;

      let ab = clamp(Math.round(-du * 250), -9, 9);
      let gm = clamp(Math.round(dv * 250), -9, 9);

      const abLabel = (ab>0) ? ("A" + ab) : (ab<0 ? ("B" + (-ab)) : "0");
      const gmLabel = (gm>0) ? ("G" + gm) : (gm<0 ? ("M" + (-gm)) : "0");

      const mag = Math.sqrt(du*du + dv*dv);
      const rel = clamp((mag*120), 0.15, 1.0);

      return {ab, gm, abLabel, gmLabel, rel};
    }

    function circularHueDiff(h2,h1){
      let d=(h2-h1)%360;
      if(d>180) d-=360;
      if(d<=-180) d+=360;
      return d;
    }

    function luminanceHistFromRGBA(rgba, stridePx){
      const hist = new Uint32Array(256);
      let total=0, tooDark=0, tooBright=0;
      const step = 4 * Math.max(1, stridePx|0);
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) | 0;
        hist[lum]++; total++;
        if(lum<=5) tooDark++;
        if(lum>=250) tooBright++;
      }
      return {hist,total,tooDark,tooBright};
    }

    function uniformHist(){
      const hist = new Uint32Array(256);
      for(let i=0;i<256;i++) hist[i]=1;
      return {hist,total:256,tooDark:0,tooBright:0};
    }

    function cdfFromHist(hist,total){
      const cdf = new Float32Array(256);
      let acc=0;
      for(let i=0;i<256;i++){ acc += hist[i]; cdf[i] = acc/total; }
      return cdf;
    }

    function buildToneLUTByCDFMatch(cdfO,cdfR){
      const lut = new Uint8Array(256);
      let j=0;
      for(let i=0;i<256;i++){
        const p = cdfO[i];
        while(j<255 && cdfR[j] < p) j++;
        lut[i]=j;
      }
      return lut;
    }

    function percentileByHist(hist,total,p){
      const target = total*p;
      let acc=0;
      for(let i=0;i<256;i++){
        acc+=hist[i];
        if(acc>=target) return i;
      }
      return 255;
    }

    function applyBlackLiftCompensation(lut, refP02){
      const liftRaw = Math.max(0, refP02 - 8);
      const strength = Math.max(0, Math.min(1, liftRaw/22));
      const liftPx = Math.round(6 + 18*strength);

      const out = new Uint8Array(256);
      for(let i=0;i<256;i++){
        let boost = 0;
        if(i < 128) boost = liftPx * (1 - (i/128));
        out[i] = Math.min(255, lut[i] + boost);
        if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
      }
      return {lut: out, strength, liftPx, isLifted: strength>=0.20};
    }

    function getColorAxesDataWeighted(rgba, stridePx){
      const buckets = {
        R:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        Y:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        G:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        C:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        B:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        M:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      };

      let valid=0;
      let sumS=0, sumTone=0, toneN=0;

      const step = 4 * Math.max(1, stridePx|0);

      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const hsl = rgbToHsl(r,g,b);
        let h=hsl[0], s=hsl[1], l=hsl[2];

        if(s < 0.08) continue;
        if(l < 0.06 || l > 0.94) continue;

        let k='M';
        if(h>=340 || h<20) k='R';
        else if(h>=20 && h<80) k='Y';
        else if(h>=80 && h<150) k='G';
        else if(h>=150 && h<210) k='C';
        else if(h>=210 && h<280) k='B';
        else k='M';

        const wS = Math.pow(s, 1.5);
        const wL = 1.0 - Math.min(0.8, Math.abs(l-0.5)*1.6);
        const w = Math.max(0.01, wS*wL);

        const rad = h*Math.PI/180;
        const bk = buckets[k];
        bk.sumCos += Math.cos(rad)*w;
        bk.sumSin += Math.sin(rad)*w;
        bk.sumS += s*w;
        bk.sumL += l*w;
        bk.wSum += w;
        bk.count++;
        valid++;

        sumS += s;
        sumTone += Math.sin(rad);
        toneN++;
      }

      const out={};
      for(const k in buckets){
        const b=buckets[k];
        if(b.wSum>0){
          let h = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
          if(h<0) h+=360;
          out[k]={H:h, S:b.sumS/b.wSum, L:b.sumL/b.wSum, count:b.count};
        } else {
          out[k]={H:0,S:0,L:0,count:0};
        }
      }

      const avgS = toneN>0 ? (sumS/toneN) : 0;
      const avgTone = toneN>0 ? (sumTone/toneN) : 0;

      return {axes: out, validColored: valid, avgS, avgTone};
    }

    function baseRecommend(mode, aiType, axesR, totalColored, contrast){
      if(mode !== "auto"){
        if(mode==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"ìˆ˜ë™ ëª¨ë“œ(ì¸ë¬¼) ì„ íƒ"};
        if(mode==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"ìˆ˜ë™ ëª¨ë“œ(í’ê²½) ì„ íƒ"};
        if(mode==="night") return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ìˆ˜ë™ ëª¨ë“œ(ì•¼ê²½): ê³„ì¡° í™•ë³´ ìš°ì„ "};
        if(mode==="snap") return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™ ëª¨ë“œ(ìŠ¤ëƒ…): ë²”ìš© ìš°ì„ "};
        return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™ ëª¨ë“œ"};
      }

      if(aiType==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"AI: ì–¼êµ´ ê°ì§€"};
      if(aiType==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"AI: í’ê²½ ê°ì§€"};

      if(totalColored < 1500) return {base:"ëª¨ë…¸í¬ë¡¬ (Monochrome)", reason:"ìœ íš¨ ìƒ‰ìƒ ë°ì´í„°ê°€ ë§¤ìš° ì ìŒ"};
      if((axesR.R.count + axesR.Y.count) > totalColored*0.55) return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"R/Y ë¹„ì¤‘ì´ í¼"};
      if((axesR.G.count + axesR.B.count + axesR.C.count) > totalColored*0.45) return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"G/B/C ë¹„ì¤‘ì´ í¼"};
      if(contrast <= -2) return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ëŒ€ë¹„ê°€ ë‚®ìŒ(ê³„ì¡° í™•ë³´)"};
      return {base:"í‘œì¤€ (Standard)", reason:"ë²”ìš©"};
    }

    function estimateWB(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sumX=0, sumY=0, sumZ=0;
      let n=0;

      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(lum < 18 || lum > 245) continue;

        const lr = srgbToLin(r);
        const lg = srgbToLin(g);
        const lb = srgbToLin(b);
        const xyz = linRgbToXyz(lr,lg,lb);
        sumX += xyz[0]; sumY += xyz[1]; sumZ += xyz[2];
        n++;
      }

      if(n < 300){
        return {ok:false, kelvin: 0, abLabel:"0", gmLabel:"0", reliability:0.15, note:"ìƒ˜í”Œ ë¶€ì¡±(ì €ì±„ë„/ê·¹ë‹¨ ë…¸ì¶œ)"};
      }

      const X = sumX/n, Y = sumY/n, Z = sumZ/n;
      const denom = (X+Y+Z) + 1e-9;
      const x = X/denom;
      const y = Y/denom;

      let cct = xyToCct(x,y);
      if(!isFinite(cct)) cct = 5200;
      cct = clamp(Math.round(cct/10)*10, 2000, 10000);

      const uv = xyToUv(x,y);
      const sh = wbShiftFromUv(uv[0], uv[1]);

      const relN = clamp(n / 6000, 0.20, 1.0);
      const reliability = clamp(0.55*relN + 0.45*sh.rel, 0.20, 1.0);

      return {
        ok:true,
        kelvin: cct,
        ab: sh.ab, gm: sh.gm,
        abLabel: sh.abLabel,
        gmLabel: sh.gmLabel,
        reliability,
        note: "íƒ€ê²Ÿ í‰ê·  ê¸°ë°˜(ì°¸ê³ ê°’)"
      };
    }

    self.onmessage = (e)=>{
      const {origBuf, refBuf, hasOrig, aiType, mode, stridePx} = e.data;

      const stride = Math.max(1, stridePx|0);

      const refRGBA = new Uint8ClampedArray(refBuf);
      const origRGBA = hasOrig ? new Uint8ClampedArray(origBuf) : null;

      const r = luminanceHistFromRGBA(refRGBA, stride);
      const o = hasOrig ? luminanceHistFromRGBA(origRGBA, stride) : uniformHist();

      const cdfR = cdfFromHist(r.hist, r.total);
      const cdfO = cdfFromHist(o.hist, o.total);
      let lut = buildToneLUTByCDFMatch(cdfO, cdfR);

      const rP02 = percentileByHist(r.hist, r.total, 0.02);
      const lift = applyBlackLiftCompensation(lut, rP02);
      lut = lift.lut;

      const oP05 = percentileByHist(o.hist, o.total, 0.05);
      const oP95 = percentileByHist(o.hist, o.total, 0.95);
      const rP05 = percentileByHist(r.hist, r.total, 0.05);
      const rP95 = percentileByHist(r.hist, r.total, 0.95);
      const oRange = Math.max(1, oP95 - oP05);
      const rRange = Math.max(1, rP95 - rP05);
      let contrast = clamp(Math.round(((rRange/oRange)-1)*6), -4, 4);

      const cR = getColorAxesDataWeighted(refRGBA, stride);
      const axesR = cR.axes;

      const axesO = hasOrig ? getColorAxesDataWeighted(origRGBA, stride).axes : {
        R:{H:0,S:0.24,L:0.50,count:9999},
        Y:{H:60,S:0.24,L:0.50,count:9999},
        G:{H:120,S:0.24,L:0.50,count:9999},
        C:{H:180,S:0.24,L:0.50,count:9999},
        B:{H:240,S:0.24,L:0.50,count:9999},
        M:{H:300,S:0.24,L:0.50,count:9999},
      };

      const keys = ['R','Y','G','C','B','M'];
      const names = ["Red(ë¹¨ê°•)","Yellow(ë…¸ë‘)","Green(ì´ˆë¡)","Cyan(ì‹œì•ˆ)","Blue(íŒŒë‘)","Magenta(ë§ˆì  íƒ€)"];

      const axesOut = [];
      for(let i=0;i<6;i++){
        const k = keys[i];
        const rA = axesR[k];
        const oA = axesO[k];

        const countR = rA.count || 0;
        const reliability = clamp(Math.sqrt(countR / 2000), 0.20, 1.0);

        const diffH = circularHueDiff(rA.H, oA.H);
        const diffS = (rA.S - oA.S) * 100;
        const diffL = (rA.L - oA.L) * 100;

        const canonH = clamp(Math.round((diffH/6.0) * reliability), -30, 30);
        const canonS = clamp(Math.round((diffS/10.0) * reliability), -30, 30);
        const canonL = clamp(Math.round((diffL/10.0) * reliability), -30, 30);

        axesOut.push({
          axis: k,
          label: names[i],
          canonH, canonS, canonL,
          countR
        });
      }

      let sat = clamp(Math.round((cR.avgS - 0.45) * 10), -4, 4);
      let tone = clamp(Math.round(cR.avgTone * 4), -4, 4);

      const baseRec = baseRecommend(mode, aiType, axesR, cR.validColored, contrast);

      const warnings = [];
      const darkRatio = r.tooDark / r.total;
      const brightRatio = r.tooBright / r.total;
      if(darkRatio > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ì–´ë‘¡ìŠµë‹ˆë‹¤(ì•”ë¶€ ë¹„ì¤‘â†‘). ê²°ê³¼ ì‹ ë¢°ë„ê°€ ë‚®ì•„ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      if(brightRatio > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ë°ìŠµë‹ˆë‹¤(ëª…ë¶€ ë¹„ì¤‘â†‘). í†¤ì»¤ë¸Œê°€ ë‹¨ìˆœí™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      if(cR.validColored < 1500) warnings.push("ìœ íš¨ ìƒ‰ìƒ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤(ì €ì±„ë„/ë¬´ì±„ìƒ‰). 6ìƒ‰ì¶•ì€ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.");

      const wb = estimateWB(refRGBA, stride);

      self.postMessage({
        ok:true,
        contrast,
        sat,
        tone,
        toneLUT: lut,
        lift: {isLifted: lift.isLifted, strength: lift.strength, liftPx: lift.liftPx, rP02},
        base: baseRec.base,
        baseReason: baseRec.reason,
        axes: axesOut,
        warnings,
        wb
      });
    };
  `;

  const url = URL.createObjectURL(new Blob([code], {type:"application/javascript"}));
  worker = new Worker(url);
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

/* =========================================================
   AI í”¼ì‚¬ì²´ íŒë³„ (autoì¼ ë•Œë§Œ)
========================================================= */
async function detectAiType(){
  if(userMode !== "auto") return {type:"manual", note:"ìˆ˜ë™"};

  if(!faceModel || !classifyModel){
    return {type:"fallback", note: aiStatusText};
  }

  const canvas = document.getElementById("canvas");
  try{
    const faces = await faceModel.estimateFaces(canvas, false);
    if(faces && faces.length > 0) return {type:"portrait", note:`AI: ì–¼êµ´ ${faces.length}ê°œ ê°ì§€`};

    const preds = await classifyModel.classify(canvas);
    const lsKw = ['mountain','valley','ocean','sea','beach','tree','forest','sky','nature','landscape','lake','park'];
    const isLandscape = preds?.some(p => lsKw.some(kw => p.className.toLowerCase().includes(kw)));
    if(isLandscape) return {type:"landscape", note:`AI: í’ê²½(${preds[0].className})`};
    return {type:"standard", note:`AI: ì¼ë°˜(${preds[0].className})`};
  }catch(e){
    console.warn("AI íŒë³„ ì‹¤íŒ¨:", e);
    return {type:"fallback", note:"AI íŒë³„ ì‹¤íŒ¨(ìš°íšŒ)"};
  }
}

/* =========================================================
   ë¶„ì„ ë©”ì¸
========================================================= */
async function analyzeAll(){
  const btn = document.getElementById("btnAnalyze");
  const spin = document.getElementById("spin");
  const btnText = document.getElementById("btnText");

  if(!refFileState){
    alert("íƒ€ê²Ÿ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    return;
  }
  if(shotMode==="two" && !origFileState){
    alert("2ì¥ ëª¨ë“œì—ì„œëŠ” ì›ë³¸ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤.");
    return;
  }

  btn.disabled = true;
  spin.style.display = "inline-block";
  btnText.textContent = "ë¶„ì„ ì¤‘â€¦";
  document.getElementById("resultCard").classList.add("hide");

  try{
    const maxDim = parseInt(document.getElementById("maxDim").value, 10);
    const stridePx = (maxDim >= 1280) ? 8 : 10;

    // 1) íƒ€ê²Ÿ(ref) ë¨¼ì € draw (canvas = ref)
    const refOri = await getExifOrientation(refFileState);
    const bmR = await decodeToImageBitmap(refFileState);
    const idR = drawScaledToImageData(bmR, maxDim, refOri);

    // auto ëª¨ë“œë©´ ì—¬ê¸°ì„œ AI ë¡œë”©(í•„ìš” ì‹œ)
    if(userMode === "auto" && aiState !== "ready"){
      await ensureAIModelsLoaded();
    }

    // 2) íƒ€ê²Ÿì„ ë³´ê³  AI íŒë³„
    const ai = await detectAiType();
    const aiType = (userMode==="auto")
      ? (ai.type==="manual" ? "fallback" : ai.type)
      : "fallback";

    // 3) 2ì¥ ëª¨ë“œë©´ ì›ë³¸(orig) drawí•´ì„œ idO ì¶”ì¶œ
    let idO = null;
    if(shotMode === "two"){
      const origOri = await getExifOrientation(origFileState);
      const bmO = await decodeToImageBitmap(origFileState);
      idO = drawScaledToImageData(bmO, maxDim, origOri);
    }

    // Worker transfer
    const refArr = idR.data;
    const refBuf = refArr.buffer;

    const hasOrig = (shotMode==="two");
    let origBuf = null;
    if(hasOrig){
      const origArr = idO.data;
      origBuf = origArr.buffer;
    }

    const result = await new Promise((resolve, reject)=>{
      const onMsg = (ev)=>{ cleanup(); resolve(ev.data); };
      const onErr = (err)=>{ cleanup(); reject(err); };
      const cleanup = ()=>{
        worker.removeEventListener("message", onMsg);
        worker.removeEventListener("error", onErr);
      };
      worker.addEventListener("message", onMsg);
      worker.addEventListener("error", onErr);

      if(hasOrig){
        worker.postMessage({
          origBuf, refBuf,
          hasOrig: true,
          aiType,
          mode: userMode,
          stridePx
        }, [origBuf, refBuf]);
      }else{
        worker.postMessage({
          refBuf,
          hasOrig: false,
          aiType,
          mode: userMode,
          stridePx
        }, [refBuf]);
      }
    });

    if(!result || !result.ok) throw new Error("Worker result invalid");

    // Look overlay
    const presetKey = document.getElementById("fujiPreset").value;
    const strengthUI = parseInt(document.getElementById("presetStrength").value, 10);
    const strength01 = (presetKey === "off" || strengthUI===0) ? 0 : (strengthUI / 100);

    const analysis = {
      contrast: result.contrast,
      sat: result.sat,
      tone: result.tone,
      toneLUT: result.toneLUT,
      axes: result.axes,
      lift: result.lift,
      base: result.base,
      baseReason: result.baseReason,
      warnings: result.warnings || [],
      baseHint: result.base,
      wb: result.wb || {ok:false, kelvin:0, abLabel:"0", gmLabel:"0", reliability:0.2, note:"-" }
    };

    const finalRes = applyFujiOverlay(analysis, presetKey, strength01);

    const pts = [0,64,128,192,255].map(x=>{
      const y = finalRes.toneLUT[x];
      return {x, y};
    });

    const curveMultiline = pts.map(p=>`IN ${p.x} â†’ OUT ${p.y}`).join("\n");

    const axesText = finalRes.axes.map(a=>{
      const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
      const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
      const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
      return `${a.axis}: H${H}  S${S}  L${L}`;
    }).join("\n");

    const modeLabel = (userMode==="auto")
      ? `AI ìë™ (${ai.note})`
      : `ìˆ˜ë™ (${userMode})`;

    const shotLabel = (shotMode==="one") ? "1ì¥(íƒ€ê²Ÿë§Œ)" : "2ì¥(ì›ë³¸+íƒ€ê²Ÿ)";

    const presetLabel = (presetKey==="off" || strength01===0)
      ? "Look Overlay: OFF"
      : `Look Overlay: ${FUJI_PRESETS[presetKey].name} (${Math.round(strength01*100)}%)`;

    const wb = finalRes.wb || analysis.wb;
    const wbText = wb?.ok
      ? `K ${wb.kelvin} Â· Shift ${wb.abLabel} / ${wb.gmLabel}`
      : `WB ë¶„ì„ ë¶ˆê°€(ì°¸ê³ ìš©)`;
    const wbRel = wb?.ok ? `${Math.round((wb.reliability||0.2)*100)}%` : "ë‚®ìŒ";

    summaryText =
`[Canon Recipe - SUMMARY v9.3 LazyAI+WorkerXfer]
- Shot: ${shotLabel}
- Mode: ${modeLabel}
- ${presetLabel}

0) WB Suggest: ${wbText} (Rel ${wbRel})
1) Base: ${finalRes.baseHint}
2) Basic: Contrast ${finalRes.contrast}, Saturation ${finalRes.sat}, ColorTone ${finalRes.tone}
3) ToneCurve(5pt, INâ†’OUT):
${curveMultiline}
4) Specific Colors(6-axis, H/S/L):
${axesText}
`;

    const warnBlock = (finalRes.warnings && finalRes.warnings.length)
      ? ("[ âš ï¸ ê²½ê³ /ì£¼ì˜ ]\n" + finalRes.warnings.map((w,i)=>`${i+1}) ${w}`).join("\n") + "\n\n")
      : "";

    fullText =
`==================================================
 ğŸ“· CANON RECIPE REPORT (v9.3 LazyAI+WorkerXfer)
==================================================
* Shot: ${shotLabel}
* Mode: ${modeLabel}
* ${presetLabel}

${warnBlock}[ 0) WB Suggest (Target Avg) ]
â–¶ ${wbText}
â–¶ Reliability: ${wbRel}
â–¶ Note: ${(wb && wb.note) ? wb.note : "-"}

--------------------------------------------------
[ 1) ì¶”ì²œ ë² ì´ìŠ¤ ]
â–¶ Base: ${finalRes.baseHint}
â–¶ Reason(ë¶„ì„): ${analysis.baseReason}

--------------------------------------------------
[ 2) Basic Settings ]
â–¶ Contrast   : ${finalRes.contrast}
â–¶ Saturation : ${finalRes.sat}
â–¶ Color Tone : ${finalRes.tone}
â–¶ Black Lift : ${finalRes.lift.isLifted ? "ê°ì§€ë¨" : "ì•½í•¨/ì—†ìŒ"} (ê°•ë„ ${Math.round(finalRes.lift.strength*100)}%, +${finalRes.lift.liftPx}px)

--------------------------------------------------
[ 3) Tone Curve (IN â†’ OUT) ]
${pts.map(p=>`â€¢ IN ${p.x}  â†’  OUT ${p.y}`).join("\n")}

--------------------------------------------------
[ 4) Specific Colors (6-axis H/S/L) ]
${finalRes.axes.map(a=>{
  const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
  const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
  const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
  return `[ ${a.axis} / ${a.label} ]  H:${H}  S:${S}  L:${L}`;
}).join("\n")}

==================================================`;

    // Render UI
    document.getElementById("sumMode").textContent = `${shotLabel} / ${modeLabel}\n${presetLabel}`;
    document.getElementById("sumBase").textContent = finalRes.baseHint;
    document.getElementById("sumBase2").textContent = finalRes.baseHint;

    document.getElementById("sumBasic").textContent =
      `Contrast ${finalRes.contrast} Â· Saturation ${finalRes.sat} Â· ColorTone ${finalRes.tone}`;

    document.getElementById("sumLift").textContent = finalRes.lift.isLifted ? "ê°ì§€ë¨" : "ì—†ìŒ";
    document.getElementById("sumLift").className = "v " + (finalRes.lift.isLifted ? "warn" : "ok");

    document.getElementById("sumWB").textContent = wbText;
    document.getElementById("sumWB2").textContent = wbText;
    document.getElementById("sumWBRel").textContent = wbRel;
    document.getElementById("sumWBRel").className = "v " + ((wb && wb.ok && wb.reliability>=0.6) ? "ok" : "warn");

    document.getElementById("sumCurve").textContent = curveMultiline;
    document.getElementById("sumColors").textContent = axesText;

    document.getElementById("sumC2").textContent = String(finalRes.contrast);
    document.getElementById("sumSat2").textContent = String(finalRes.sat);
    document.getElementById("sumTone2").textContent = String(finalRes.tone);

    document.getElementById("reportBox").textContent = fullText;

    document.getElementById("resultCard").classList.remove("hide");
    setTab("sum");
    document.getElementById("resultCard").scrollIntoView({behavior:"smooth"});
  }catch(e){
    console.error(e);
    const msg =
`ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

ê°€ëŠ¥ ì›ì¸:
- HEIC/HEIF(ì•„ì´í° ì›ë³¸) â†’ ë¸Œë¼ìš°ì € ë¯¸ì§€ì›ì¼ ìˆ˜ ìˆìŒ (JPGë¡œ ë³€í™˜ í›„ ì¬ì‹œë„)
- ì´ë¯¸ì§€ ì†ìƒ
- ë¸Œë¼ìš°ì €ì—ì„œ Worker/ImageBitmap ì œí•œ

ë‹¤ë¥¸ ì´ë¯¸ì§€ë¡œ ì¬ì‹œë„í•´ ì£¼ì„¸ìš”.`;
    alert(msg);
  }finally{
    spin.style.display = "none";
    refreshReady();
  }
}

/* =========================================================
   Copy
========================================================= */
async function copySummary(){
  if(!summaryText) return;
  try{
    await navigator.clipboard.writeText(summaryText);
    alert("ìš”ì•½ì„ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!");
  }catch(e){
    const ta=document.createElement("textarea");
    ta.value=summaryText;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    alert("ìš”ì•½ì„ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!");
  }
}
async function copyFull(){
  if(!fullText) return;
  try{
    await navigator.clipboard.writeText(fullText);
    alert("ì „ì²´ ë ˆì‹œí”¼ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!");
  }catch(e){
    const ta=document.createElement("textarea");
    ta.value=fullText;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    alert("ì „ì²´ ë ˆì‹œí”¼ë¥¼ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤!");
  }
}

/* =========================================================
   Boot
========================================================= */
window.onload = ()=>{
  setupDropZone("dropOrig","origFile","thumbOrig","fileOrig", f=>origFileState=f);
  setupDropZone("dropRef","refFile","thumbRef","fileRef", f=>refFileState=f);

  initWorker();

  updateStrengthLabel();
  updatePresetLabel();

  setShot("one");
  setMode("auto");
  setTab("sum");

  setAIUI("idle", "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)");

  refreshReady();
};
</script>
</body>
</html>