<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Canon Recipe Generator Pro (v11.5.2 Auto FilmSim + Preview EV AfterOnly)</title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#94a3b8; --text:#f1f5f9;
      --line:#263456; --brand:#ff3f34; --ok:#10b981; --warn:#f59e0b;
      --cyan:#06b6d4; --black:#020617; --radius: 16px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0; font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Noto Sans KR", system-ui, sans-serif;
      background: radial-gradient(1100px 520px at 15% 0%, rgba(255,63,52,0.16), transparent 60%),
                  radial-gradient(900px 520px at 85% 0%, rgba(6,182,212,0.16), transparent 60%),
                  var(--bg);
      color:var(--text);
      padding: 16px;
      line-height: 1.5;
    }
    .app{ max-width: 1120px; margin: 0 auto; padding-bottom: 48px; }
    .header{ display:flex; flex-direction:column; gap:10px; margin-bottom:18px; }
    .title h1{ margin:0; font-size:20px; letter-spacing:-0.4px; }
    .title p{ margin:6px 0 0; color:var(--muted); font-size:13px; word-break: keep-all; }

    .badges{ display:flex; gap:8px; flex-wrap:wrap; }
    .badge{
      border:1px solid var(--line); background: rgba(18,26,51,0.7);
      padding:6px 12px; border-radius:999px; font-size:11px; font-weight:800;
      display:flex; gap:6px; align-items:center;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted); }
    .dot.ok{ background:var(--ok); } .dot.warn{ background:var(--warn); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 920px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background: rgba(18,26,51,0.86);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 12px 26px rgba(0,0,0,0.34);
      overflow:hidden;
    }
    .card-h{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--line);
      background: rgba(2,6,23,0.35);
    }
    .card-h strong{ font-size:14px; }
    .step{
      font-size:12px; color:var(--muted);
      padding:4px 10px; border:1px solid var(--line);
      border-radius:999px; background: rgba(2,6,23,0.35);
      font-weight:900;
      white-space:nowrap;
    }
    .card-b{ padding:16px; }

    .seg{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:14px;
      margin-bottom:12px;
    }
    .seg .label{ color:var(--muted); font-size:12px; font-weight:900; margin-bottom:8px; }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:10px 14px;
      border-radius:999px;
      font-size:13px;
      font-weight:900;
      cursor:pointer;
      transition:0.15s;
      flex: 1 1 auto;
      text-align:center;
      user-select:none;
    }
    .chip.active{
      border-color: var(--brand);
      background: rgba(255,63,52,0.15);
      color: #ff8b86;
      box-shadow: 0 0 0 2px rgba(255,63,52,0.10) inset;
    }

    .uploader{ display:flex; flex-direction:column; gap:12px; }
    .drop{
      border:2px dashed var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:18px;
      transition: 0.15s;
      cursor:pointer;
      min-height: 140px;
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      align-items:center;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .drop.dragover{ border-color: var(--ok); background: rgba(16,185,129,0.10); }
    .drop .label{ font-weight:950; font-size:14px; }
    .drop .hint{ color:var(--muted); font-size:12px; line-height:1.45; }
    .drop input{ display:none; }
    .thumb{
      width:100%;
      display:none;
      border-radius:10px;
      max-height:140px;
      object-fit:cover;
      border:1px solid var(--line);
    }
    .filename{
      font-size:12px;
      color: var(--cyan);
      font-weight:900;
      display:none;
      word-break:break-all;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 12px; }
    .kv{
      flex:1;
      display:flex; justify-content:space-between; align-items:center;
      font-size:13px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:10px 12px;
      border-radius:12px;
      gap:10px;
    }
    .kv b{ font-weight:950; }
    .kv select, .kv input[type="range"]{
      width: 54%;
      background: rgba(18,26,51,0.9);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-weight:800;
    }
    .kv .val{ color: var(--cyan); font-weight:950; white-space:nowrap; }

    .btn{
      border:0;
      border-radius:14px;
      padding:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      font-size:14px;
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
    }
    .btn.primary{ background: var(--brand); color:white; }
    .btn.primary:active{ filter: brightness(0.92); transform: scale(0.985); }
    .btn.ghost{ background: rgba(2,6,23,0.25); border:1px solid var(--line); color: var(--text); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none !important; }

    .mini{
      color:var(--muted);
      font-size:12px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:12px;
      word-break: keep-all;
      line-height: 1.55;
    }

    .tabs{
      display:flex; gap:8px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:8px;
      border-radius:14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .tabs .left{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:8px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      user-select:none;
    }
    .tab.active{
      border-color: var(--ok);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(16,185,129,0.12) inset;
    }
    .tabHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(2,6,23,0.35);
      white-space:nowrap;
    }

    .summaryCard{ display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px; }
    .pill{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:14px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .pill .k{ color:var(--muted); font-size:12px; margin-bottom:4px; }
    .pill .v{ font-weight:950; font-size: 14px; line-height:1.4; }
    .pill .v.ok{ color:var(--ok); } .pill .v.warn{ color:var(--warn); } .pill .v.cyan{ color:var(--cyan); }

    .report{
      margin-top:12px;
      background: var(--black);
      color: var(--ok);
      border:1px solid rgba(16,185,129,0.32);
      border-radius:14px;
      padding:16px;
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size:13px;
      overflow-x:auto;
      line-height:1.62;
    }

    .spinner{
      width:18px; height:18px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
      display:none;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }
    .hide{ display:none !important; }

    /* Preview */
    .pvWrap{ display:flex; flex-direction:column; gap:12px; }
    #previewCanvas{
      width:100%;
      display:block;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      max-height: 520px;
      touch-action: none;
      cursor: ew-resize;
    }
    .pvLegend{
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      color:var(--muted); font-size:12px; font-weight:900;
    }
    .pvLegend b{ color: var(--text); }
    .pvHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .pvHint .badge2{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.7);
      padding:6px 10px;
      border-radius:999px;
      font-size:11px;
      font-weight:950;
      color: var(--cyan);
    }
    .pvActions{
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .pvActions .btn{ width:auto; padding:10px 12px; font-size:12px; border-radius:12px; }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <h1>ğŸ“· Canon Recipe Generator Pro <span style="color:var(--cyan); font-size:14px;">v11.5.2 Auto FilmSim + Preview EV (After Only)</span></h1>
        <p>
          âœ… Auto FilmSim(íƒ€ê²Ÿë§Œ) Â· âœ… 2ì¥ ì •ë ¬ ì•ˆì • Â· âœ… Preview EV ë…¸ì¶œ ë³´ì •(-5~+5)<br/>
          Preview EVëŠ” <b>ìš°ì¸¡(ì ìš© ê²°ê³¼)</b>ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. (ì¢Œì¸¡ ì›ë³¸ì€ ê³ ì •)
        </p>
      </div>
      <div class="badges">
        <div class="badge"><span id="dotAI" class="dot warn"></span><span id="aiText">AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)</span></div>
        <div class="badge"><span id="dotP" class="dot"></span> ë¯¸ë¦¬ë³´ê¸°(ì„ íƒ)</div>
        <div class="badge"><span id="dotO" class="dot"></span> ì›ë³¸(ì„ íƒ)</div>
        <div class="badge"><span id="dotR" class="dot"></span> íƒ€ê²Ÿ(í•„ìˆ˜)</div>
      </div>
    </div>

    <div class="grid">

      <!-- PREVIEW -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <strong>PREVIEW. ë‚´ ìºë…¼ ì‚¬ì§„ì— ì ìš©í•´ë³´ê¸°</strong>
          <span class="step">ë“œë˜ê·¸ Split</span>
        </div>
        <div class="card-b">
          <div class="pvWrap">
            <div class="seg">
              <div class="label">ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„(ë‚´ ìºë…¼ JPG)</div>
              <div class="uploader">
                <div class="drop" id="dropPrev">
                  <div class="label">ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„ ì—…ë¡œë“œ</div>
                  <div class="hint">í”„ë¦¬ì…‹/ë ˆì‹œí”¼ë¥¼ ì ìš©í•´ Before/Afterë¥¼ í™•ì¸í•©ë‹ˆë‹¤.</div>
                  <input id="prevFile" type="file" accept="image/*"/>
                  <img id="thumbPrev" class="thumb" alt="preview"/>
                  <div id="filePrev" class="filename"></div>
                </div>
              </div>

              <div class="mini" style="margin-top:12px;">
                âœ… <b>Split ì¡°ì ˆ:</b> ì•„ë˜ í”„ë¦¬ë·° ì´ë¯¸ì§€ ìœ„ì—ì„œ ì¢Œìš°ë¡œ <b>ë“œë˜ê·¸</b>í•˜ì„¸ìš”.<br/>
                (ì¢Œ: ì›ë³¸ / ìš°: ì ìš© ê²°ê³¼)
              </div>
            </div>

            <div class="row">
              <div class="kv">
                <b>ë¯¸ë¦¬ë³´ê¸° ì†ŒìŠ¤</b>
                <select id="previewMode">
                  <option value="preset" selected>í”„ë¦¬ì…‹ë§Œ ì ìš©(ë¹ ë¦„)</option>
                  <option value="recipe">ë§ˆì§€ë§‰ ë¶„ì„ ë ˆì‹œí”¼ ì ìš©(ì •ë°€)</option>
                </select>
                <span class="val" id="previewModeLabel">PRESET</span>
              </div>
              <div class="kv">
                <b>ë¯¸ë¦¬ë³´ê¸° í•´ìƒë„</b>
                <select id="previewDim">
                  <option value="720">720px (ìµœê³ ì†)</option>
                  <option value="1024" selected>1024px (ê¶Œì¥)</option>
                  <option value="1280">1280px (ì •ë°€)</option>
                </select>
                <span class="val">Render</span>
              </div>
            </div>

            <div class="row">
              <div class="kv">
                <b>ì ìš© ê°•ë„</b>
                <input id="previewStrength" type="range" min="0" max="100" value="70" />
                <span class="val" id="previewStrengthLabel">70%</span>
              </div>

              <div class="kv">
                <b>EV ë…¸ì¶œ(ìš°ì¸¡ë§Œ)</b>
                <input id="previewEV" type="range" min="-5" max="5" step="0.1" value="0" />
                <span class="val" id="previewEVLabel">+0.0</span>
              </div>

              <div class="kv">
                <b>Split ìœ„ì¹˜</b>
                <span class="val" id="splitLabel">50%</span>
                <span class="val" style="color:var(--muted); font-weight:900;">(ë“œë˜ê·¸)</span>
              </div>
            </div>

            <div class="pvHint">
              <div class="badge2" id="pvMeta">-</div>
              <div class="pvActions">
                <button id="btnPreviewApply" class="btn ghost" disabled>ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸</button>
                <button id="btnPreviewReset" class="btn ghost" disabled>â†”ï¸ Split 50%</button>
                <button id="btnPreviewSave" class="btn ghost" disabled>â¬‡ï¸ PNG ì €ì¥</button>
              </div>
            </div>

            <canvas id="previewCanvas"></canvas>
            <div class="pvLegend">
              <div>ì¢Œì¸¡ <b>ì›ë³¸</b></div>
              <div>ìš°ì¸¡ <b>ì ìš© ê²°ê³¼</b></div>
            </div>

            <div class="mini">
              <b>ì¤‘ìš”:</b> Preview EVëŠ” <b>ìš°ì¸¡(ì ìš© ê²°ê³¼)</b>ë§Œ ë³´ì •í•˜ë©°, ë¶„ì„ ë ˆì‹œí”¼(ì»¤ë¸Œ/6ìƒ‰ì¶•)ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 1 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 1. ì‚¬ì§„ ë„£ê¸°</strong>
          <span class="step">1/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ë°©ì‹</div>
            <div class="chips">
              <div class="chip active" data-shot="one" onclick="setShot('one')">1ì¥ ëª¨ë“œ (íƒ€ê²Ÿë§Œ)</div>
              <div class="chip" data-shot="two" onclick="setShot('two')">2ì¥ ëª¨ë“œ (ì›ë³¸+íƒ€ê²Ÿ)</div>
            </div>
          </div>

          <div class="uploader">
            <div class="drop hide" id="dropOrig">
              <div class="label">ì›ë³¸ (ì¶”ì²œ: Standard/Neutral)</div>
              <div class="hint">ìºë…¼ í‘œì¤€/ë‰´íŠ¸ëŸ´ë¡œ ì°ì€ ì›ë³¸ ì‚¬ì§„</div>
              <input id="origFile" type="file" accept="image/*"/>
              <img id="thumbOrig" class="thumb" alt="orig"/>
              <div id="fileOrig" class="filename"></div>
            </div>

            <div class="drop" id="dropRef">
              <div class="label">íƒ€ê²Ÿ (ì›í•˜ëŠ” ìƒ‰ê°)</div>
              <div class="hint">
                ë§Œë“¤ê³  ì‹¶ì€ ì˜í™”/í•„ë¦„ ëŠë‚Œì˜ ì°¸ê³  ì‚¬ì§„.<br/>
                <b>ì£¼ì˜:</b> iPhone <b>HEIC</b>ëŠ” <b>JPGë¡œ ë³€í™˜</b> í›„ ì—…ë¡œë“œ ê¶Œì¥.
              </div>
              <input id="refFile" type="file" accept="image/*"/>
              <img id="thumbRef" class="thumb" alt="ref"/>
              <div id="fileRef" class="filename"></div>
            </div>
          </div>

          <div class="mini" style="margin-top:12px;">
            2ì¥ ëª¨ë“œê°€ â€œì§„ì§œ ë§¤ì¹­â€ì…ë‹ˆë‹¤. (ê°€ëŠ¥í•˜ë©´ 2ì¥ ì¶”ì²œ)
          </div>
        </div>
      </div>

      <!-- STEP 2 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 2. ì„¤ì •</strong>
          <span class="step">2/3</span>
        </div>
        <div class="card-b">

          <div class="seg">
            <div class="label">ë¶„ì„ ëª¨ë“œ (í„°ì¹˜)</div>
            <div class="chips">
              <div class="chip active" data-mode="auto" onclick="setMode('auto')">AI ìë™</div>
              <div class="chip" data-mode="portrait" onclick="setMode('portrait')">ì¸ë¬¼</div>
              <div class="chip" data-mode="landscape" onclick="setMode('landscape')">í’ê²½</div>
              <div class="chip" data-mode="snap" onclick="setMode('snap')">ìŠ¤ëƒ…</div>
              <div class="chip" data-mode="night" onclick="setMode('night')">ì•¼ê²½</div>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í•´ìƒë„</b>
              <select id="maxDim">
                <option value="1024" selected>1024px (ê¶Œì¥)</option>
                <option value="1280">1280px (ì •ë°€)</option>
              </select>
              <span class="val">ë¦¬ì‚¬ì´ì¦ˆ ë¶„ì„</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>AI ê°•í™”(ì„ íƒ)</b>
              <select id="aiBoost">
                <option value="off" selected>OFF (ë¹ ë¦„)</option>
                <option value="coco">ON: COCO-SSD (ì •í™•â†‘, ë¬´ê±°ì›€)</option>
              </select>
              <span class="val" id="aiBoostLabel">FAST</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Specific Points</b>
              <select id="specPoints">
                <option value="on" selected>ON (ê¶Œì¥)</option>
                <option value="off">OFF</option>
              </select>
              <span class="val" id="specPointsLabel">ON</span>
            </div>
          </div>

          <!-- Auto FilmSim -->
          <div class="seg">
            <div class="label">Auto FilmSim (íƒ€ê²Ÿë§Œ) â€” í•„ìš”í•  ë•Œë§Œ</div>
            <div class="row" style="margin-bottom:0;">
              <div class="kv">
                <b>ìë™ ì¶”ì²œ</b>
                <select id="autoFilmSim">
                  <option value="off" selected>OFF (ìˆ˜ë™)</option>
                  <option value="on">ON (ë¶„ì„ ì‹œ ìë™ ì ìš©)</option>
                </select>
                <span class="val" id="autoFilmSimLabel">OFF</span>
              </div>
              <div class="kv">
                <b>ì¦‰ì‹œ ì¶”ì²œ</b>
                <button id="btnAutoPick" class="btn ghost" style="width:auto; padding:10px 12px; font-size:12px; border-radius:12px;" disabled>ğŸï¸ íƒ€ê²Ÿë§Œ ì¶”ì²œ</button>
                <span class="val" style="color:var(--muted); font-weight:900;">(1ì¥)</span>
              </div>
            </div>
            <div class="mini" id="autoSuggestText" style="margin-top:10px;">
              Auto FilmSim: OFF â€” íƒ€ê²Ÿë§Œ ì—…ë¡œë“œí•˜ë©´ â€œì¶”ì²œâ€ ë²„íŠ¼ì´ í™œì„±í™”ë©ë‹ˆë‹¤.
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Look Overlay</b>
              <select id="fujiPreset">
                <option value="off" selected>Off (ë¶„ì„ë§Œ)</option>
                <optgroup label="Fuji 5th Gen Looks">
                  <option value="classic_chrome">Fuji_ClassicChrome</option>
                  <option value="classic_negative">Fuji_ClassicNegative</option>
                  <option value="reala_ace">Fuji_RealaAce</option>
                  <option value="nostalgic_negative">Fuji_NostalgicNeg</option>
                  <option value="provia">Fuji_Provia</option>
                  <option value="astia">Fuji_Astia</option>
                  <option value="velvia">Fuji_Velvia</option>
                  <option value="eterna">Fuji_Eterna</option>
                </optgroup>
                <optgroup label="Ricoh GR Looks">
                  <option value="gr_positive">GR_Positive</option>
                </optgroup>
              </select>
              <span class="val" id="presetLabel">OFF</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í”„ë¦¬ì…‹ ê°•ë„</b>
              <input id="presetStrength" type="range" min="0" max="100" value="50" />
              <span class="val" id="strengthLabel">50%</span>
            </div>
          </div>

          <button id="btnAnalyze" class="btn primary" onclick="analyzeAll()" disabled>
            <span id="btnText">ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”</span>
            <span id="spin" class="spinner"></span>
          </button>

          <div class="mini" style="margin-top:12px;">
            ë¶„ì„ í›„ PREVIEWì—ì„œ â€œë§ˆì§€ë§‰ ë¶„ì„ ë ˆì‹œí”¼ ì ìš©â€ìœ¼ë¡œ ë°”ë¡œ ê²€ì¦ ê°€ëŠ¥í•©ë‹ˆë‹¤.
          </div>
        </div>
      </div>

      <!-- STEP 3 -->
      <div class="card hide" style="grid-column: 1 / -1;" id="resultCard">
        <div class="card-h">
          <strong>STEP 3. ê²°ê³¼</strong>
          <span class="step" style="color:var(--ok); border-color:var(--ok);">ì™„ë£Œ</span>
        </div>
        <div class="card-b">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; gap:10px;">
              <button class="btn ghost" onclick="copySummary()" style="flex:1;">ğŸ“‹ ìš”ì•½ ë³µì‚¬</button>
              <button class="btn ghost" onclick="copyFull()" style="flex:1;">ğŸ“‹ ì „ì²´ ë³µì‚¬</button>
            </div>
          </div>

          <div class="tabs">
            <div class="left">
              <div class="tab active" data-tab="sum" onclick="setTab('sum')">ìš”ì•½ ë³´ê¸°</div>
              <div class="tab" data-tab="full" onclick="setTab('full')">ì „ì²´ ë³´ê¸°</div>
            </div>
            <div class="tabHint" id="tabHint">ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.</div>
          </div>

          <div class="summaryCard" id="summaryBox">
            <div class="pill">
              <div>
                <div class="k">ë¶„ì„ ëª¨ë“œ</div>
                <div class="v cyan" id="sumMode">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì¶”ì²œ ë² ì´ìŠ¤</div>
                <div class="v ok" id="sumBase">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">ê¸°ë³¸ ì¡°ì •</div>
                <div class="v" id="sumBasic">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ë¸”ë™ ë¦¬í”„íŠ¸</div>
                <div class="v" id="sumLift">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">WB ì œì•ˆ</div>
                <div class="v cyan" id="sumWB">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì‹ ë¢°ë„</div>
                <div class="v" id="sumWBRel">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">í†¤ ì»¤ë¸Œ (IN â†’ OUT)</div>
                <div class="v" id="sumCurve" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">6ìƒ‰ì¶• (H / S / L)</div>
                <div class="v" id="sumColors" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill" id="specPill">
              <div style="width:100%;">
                <div class="k">Specific Colors Points (ìš”ì•½)</div>
                <div class="v" id="sumSpecific" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="mini" id="sumExtra">-</div>
          </div>

          <div id="fullBox" class="hide">
            <div id="reportBox" class="report"></div>
          </div>

          <canvas id="workCanvas" class="hide"></canvas>
        </div>
      </div>

    </div>
  </div>

<script>
/* =========================================================
   State
========================================================= */
let shotMode = "one";
let userMode = "auto";
let viewTab  = "sum";

let origFileState = null;
let refFileState  = null;
let prevFileState = null;

let summaryText = "";
let fullText = "";

let lastRecipe = null;

let worker = null;
let workerUrl = null;

// Lazy AI
let faceModel = null;
let classifyModel = null;
let cocoModel = null;
let aiState = "idle";
let aiStatusText = "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)";

// Preview caches
let split01 = 0.50;
let previewCache = null; // {w,h,metaText}
let previewBusy = false;

let pvBeforeCanvas = null;
let pvAfterCanvas  = null;
let pvSourceCache  = null; // {key, before, w, h}

let pvDragging = false;

// Auto FilmSim
let lastAutoSuggest = null;

// Preview EV LUTs
let SRGB_TO_LIN_256 = null;
let LIN_TO_SRGB_4096 = null;

/* =========================================================
   Presets
========================================================= */
const FUJI_PRESETS = {
  off: null,

  provia: {
    name:"Fuji_Provia",
    contrast:+1, sat:+1, tone:0,
    curve5:{0:2,64:66,128:128,192:194,255:252},
    axes:{ R:{H:0,S:0,L:0},Y:{H:0,S:0,L:0},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-2,L:0},M:{H:0,S:0,L:0} },
    matrix: null, satDamp: null, colorChrome: null,
  },

  astia: {
    name:"Fuji_Astia",
    contrast:-1, sat:+1, tone:+1,
    curve5:{0:8,64:78,128:132,192:198,255:255},
    axes:{ R:{H:+2,S:-6,L:+6},Y:{H:-2,S:-6,L:+6},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-6,L:0},M:{H:0,S:0,L:0} },
    matrix: null,
    satDamp: { hiStart:0.82, hiStrength:0.14, satStart:0.70, satStrength:0.10, floor:0.65 },
    colorChrome: null,
  },

  classic_chrome: {
    name:"Fuji_ClassicChrome",
    contrast:+2, sat:-2, tone:-1,
    curve5:{0:12,64:72,128:126,192:186,255:242},
    axes:{
      R:{H:+2,S:-10,L:+4},
      Y:{H:-2,S:-16,L:+4},
      G:{H:+4,S:-10,L:-2},
      C:{H:-6,S:-6, L:-2},
      B:{H:-10,S:-10,L:-4},
      M:{H:+2,S:-6, L:0}
    },
    matrix: [
      [0.98,  0.03, -0.01],
      [-0.02, 0.98,  0.04],
      [0.02,  0.10,  0.88],
    ],
    satDamp: { hiStart:0.78, hiStrength:0.22, satStart:0.62, satStrength:0.18, floor:0.58 },
    colorChrome: null,
  },

  classic_negative: {
    name:"Fuji_ClassicNegative",
    contrast:+3, sat:-1, tone:-2,
    curve5:{0:10,64:45,128:125,192:205,255:240},
    axes:{
      R:{H:+4, S:-12, L:-2},
      Y:{H:-2, S:-10, L: 0},
      G:{H:+18,S:-20, L:-14},
      C:{H:+8, S:-10, L:-10},
      B:{H:-10,S:-10, L:-10},
      M:{H:+4, S:-6,  L:+2}
    },
    matrix: [
      [1.05, -0.10,  0.05],
      [0.00,  0.90,  0.10],
      [-0.05, 0.15,  0.90],
    ],
    satDamp: { hiStart:0.80, hiStrength:0.16, satStart:0.70, satStrength:0.14, floor:0.60 },
    colorChrome: null,
    splitToning: { shHue: 190, shAmt: 0.08, hiHue: 25, hiAmt: 0.06, pivot: 0.55 },
  },

  reala_ace: {
    name:"Fuji_RealaAce",
    skinProtect:true,
    contrast:+2, sat:+1, tone:+1,
    curve5:{0:4,64:68,128:130,192:200,255:248},
    axes:{
      R:{H:0,S:-4,L:+3},
      Y:{H:0,S:-6,L:+3},
      G:{H:0,S:-2,L:0},
      C:{H:+2,S:0,L:-2},
      B:{H:+2,S:-2,L:-4},
      M:{H:0,S:-2,L:0},
    },
    matrix: [
      [1.00, -0.02,  0.02],
      [0.00,  0.98,  0.02],
      [-0.01, 0.06,  0.95],
    ],
    satDamp: { hiStart:0.74, hiStrength:0.30, satStart:0.58, satStrength:0.22, floor:0.56 },
    colorChrome: null,
  },

  nostalgic_negative: {
    name:"Fuji_NostalgicNeg",
    contrast:+1, sat:-1, tone:+2,
    curve5:{0:14,64:84,128:136,192:194,255:244},
    axes:{ R:{H:-4,S:+2,L:+6},Y:{H:-6,S:+4,L:+8},G:{H:+4,S:-8,L:0},C:{H:+6,S:-8,L:-2},B:{H:+8,S:-12,L:-4},M:{H:0,S:-4,L:0} },
    matrix: null,
    satDamp: { hiStart:0.82, hiStrength:0.18, satStart:0.70, satStrength:0.12, floor:0.60 },
    colorChrome: null,
  },

  velvia: {
    name:"Fuji_Velvia",
    contrast:+3, sat:+4, tone:-1,
    curve5:{0:0,64:56,128:126,192:210,255:255},
    axes:{ R:{H:0,S:+6,L:0},Y:{H:0,S:+10,L:+2},G:{H:-6,S:+18,L:-6},C:{H:-2,S:+12,L:-6},B:{H:-4,S:+10,L:-8},M:{H:0,S:+4,L:0} },
    matrix: null,
    satDamp: { hiStart:0.86, hiStrength:0.10, satStart:0.78, satStrength:0.12, floor:0.65 },
    colorChrome: { satStart:0.62, strength:0.28, lumaMid:0.60, lumaRange:0.35 },
  },

  eterna: {
    name:"Fuji_Eterna",
    contrast:-2, sat:-3, tone:-1,
    curve5:{0:16,64:88,128:132,192:180,255:238},
    axes:{ R:{H:0,S:-10,L:+2},Y:{H:0,S:-12,L:+2},G:{H:0,S:-8,L:0},C:{H:+2,S:-8,L:0},B:{H:+2,S:-8,L:0},M:{H:0,S:-8,L:0} },
    matrix: [
      [1.00, 0.00, 0.00],
      [0.00, 0.98, 0.02],
      [0.01, 0.06,  0.93],
    ],
    satDamp: { hiStart:0.72, hiStrength:0.22, satStart:0.55, satStrength:0.18, floor:0.55 },
    colorChrome: null,
  },

  gr_positive: {
    name:"GR_Positive",
    contrast:+2, sat:+2, tone:0,
    curve5:{0:0,64:60,128:132,192:198,255:252},
    axes:{ R:{H:0,S:+8,L:0},Y:{H:-2,S:+6,L:+2},G:{H:-6,S:+2,L:-6},C:{H:+2,S:+6,L:-4},B:{H:-4,S:+10,L:-8},M:{H:0,S:0,L:0} },
    matrix: null, satDamp: null, colorChrome: null,
  }
};

/* =========================================================
   Utils
========================================================= */
function clamp(v,a,b){ return v<a?a:(v>b?b:v); }
function lerp(a,b,t){ return a+(b-a)*t; }
function smoothstep(e0,e1,x){
  const t = clamp((x-e0)/Math.max(1e-6,(e1-e0)), 0, 1);
  return t*t*(3-2*t);
}
function setDot(id, state){
  const el = document.getElementById(id);
  el.className = "dot" + (state ? (" " + state) : "");
}
function modeName(mode){
  if(mode==="auto") return "AIìë™";
  if(mode==="portrait") return "ì¸ë¬¼";
  if(mode==="landscape") return "í’ê²½";
  if(mode==="snap") return "ìŠ¤ëƒ…";
  if(mode==="night") return "ì•¼ê²½";
  return "ìˆ˜ë™";
}
function fileSig(file){
  if(!file) return "-";
  const n = file.name || "";
  const s = file.size || 0;
  const t = file.lastModified || 0;
  return `${n}|${s}|${t}`;
}
function presetDisplayName(key){
  if(!key || key==="off") return "OFF";
  return FUJI_PRESETS[key]?.name || key;
}

/* =========================================================
   Tabs / Shot / Mode
========================================================= */
function setTab(tab){
  viewTab = tab;
  document.querySelectorAll(".tab").forEach(el=> el.classList.toggle("active", el.dataset.tab === tab));
  const hint = document.getElementById("tabHint");
  if(tab === "sum"){
    hint.textContent = "ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.remove("hide");
    document.getElementById("fullBox").classList.add("hide");
  }else{
    hint.textContent = "ìƒì„¸ ë ˆì‹œí”¼ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.add("hide");
    document.getElementById("fullBox").classList.remove("hide");
  }
}
function setMode(mode){
  userMode = mode;
  document.querySelectorAll(".chip[data-mode]").forEach(el=> el.classList.toggle("active", el.dataset.mode === mode));
  refreshReady();
}
function setShot(mode){
  shotMode = mode;
  document.querySelectorAll(".chip[data-shot]").forEach(el=> el.classList.toggle("active", el.dataset.shot === mode));
  document.getElementById("dropOrig").classList.toggle("hide", shotMode !== "two");
  refreshReady();
  refreshAutoPickReady();
}

/* =========================================================
   Preset label
========================================================= */
function updateStrengthLabel(){
  const v = parseInt(document.getElementById("presetStrength").value, 10);
  document.getElementById("strengthLabel").textContent = v + "%";
}
function setStrengthEnabled(enabled){
  const s = document.getElementById("presetStrength");
  s.disabled = !enabled;
  s.style.opacity = enabled ? "1" : "0.5";
}
function updatePresetLabel(){
  const key = document.getElementById("fujiPreset").value;
  const strength = parseInt(document.getElementById("presetStrength").value, 10);
  if(key === "off"){
    document.getElementById("presetLabel").textContent = "OFF";
    setStrengthEnabled(false);
    return;
  }
  setStrengthEnabled(true);
  const name = FUJI_PRESETS[key]?.name || "LookPreset";
  const extra = FUJI_PRESETS[key]?.skinProtect ? " Â· SkinSafe" : "";
  document.getElementById("presetLabel").textContent = `ON: ${name}${extra} (${strength}%)`;
}

/* =========================================================
   Auto FilmSim UI
========================================================= */
function updateAutoFilmSimLabel(){
  const v = document.getElementById("autoFilmSim").value;
  document.getElementById("autoFilmSimLabel").textContent = (v==="on") ? "ON" : "OFF";
}
function refreshAutoPickReady(){
  const btn = document.getElementById("btnAutoPick");
  const ok = !!refFileState && (shotMode === "one");
  btn.disabled = !ok;
  const hint = document.getElementById("autoSuggestText");
  if(!refFileState){
    hint.textContent = "Auto FilmSim: OFF â€” íƒ€ê²Ÿë§Œ ì—…ë¡œë“œí•˜ë©´ â€œì¶”ì²œâ€ ë²„íŠ¼ì´ í™œì„±í™”ë©ë‹ˆë‹¤.";
    return;
  }
  if(shotMode !== "one"){
    hint.textContent = "Auto FilmSim: íƒ€ê²Ÿë§Œ ë¶„ì„ ëª¨ë“œì…ë‹ˆë‹¤. (1ì¥ ëª¨ë“œì—ì„œ ì‚¬ìš©)";
    return;
  }
  if(lastAutoSuggest){
    hint.textContent = `ìµœê·¼ ì¶”ì²œ: ${presetDisplayName(lastAutoSuggest.key)} Â· ${lastAutoSuggest.strength}% (ì‹ ë¢° ${Math.round(lastAutoSuggest.confidence*100)}%) â€” ${lastAutoSuggest.reason}`;
  }else{
    hint.textContent = "íƒ€ê²Ÿë§Œìœ¼ë¡œ FilmSim + ê°•ë„ ì¶”ì²œ ê°€ëŠ¥. (ë²„íŠ¼ í´ë¦­ ë˜ëŠ” ON í›„ ë¶„ì„)";
  }
}

/* =========================================================
   Preview labels / readiness
========================================================= */
function updatePreviewLabels(){
  document.getElementById("splitLabel").textContent = Math.round(split01*100) + "%";
  const st = parseInt(document.getElementById("previewStrength").value,10);
  document.getElementById("previewStrengthLabel").textContent = st + "%";

  const ev = parseFloat(document.getElementById("previewEV").value || "0");
  const evTxt = (ev >= 0 ? "+" : "") + ev.toFixed(1);
  document.getElementById("previewEVLabel").textContent = evTxt;

  const pm = document.getElementById("previewMode").value;
  document.getElementById("previewModeLabel").textContent = (pm==="preset") ? "PRESET" : "RECIPE";
}
function refreshPreviewReady(){
  const btn = document.getElementById("btnPreviewApply");
  const btnReset = document.getElementById("btnPreviewReset");
  const btnSave = document.getElementById("btnPreviewSave");

  const okPrev = !!prevFileState;
  const pm = document.getElementById("previewMode").value;
  const okRecipe = (pm==="recipe") ? !!lastRecipe : true;

  btn.disabled = !(okPrev && okRecipe);
  btnReset.disabled = !okPrev;
  btnSave.disabled = !okPrev;

  setDot("dotP", okPrev ? "ok" : "");
  if(pm==="recipe" && okPrev && !okRecipe){
    setPvMeta("ë ˆì‹œí”¼ ì—†ìŒ(ë¨¼ì € ë¶„ì„í•˜ì„¸ìš”)");
  }
}
function setPvMeta(t){
  document.getElementById("pvMeta").textContent = t || "-";
}

/* =========================================================
   HEIC / EXIF
========================================================= */
function isHeicFile(file){
  const name = (file?.name || "").toLowerCase();
  const type = (file?.type || "").toLowerCase();
  return (name.endsWith(".heic") || name.endsWith(".heif") || type.includes("heic") || type.includes("heif"));
}
function maybeWarnHeic(file){
  if(isHeicFile(file)){
    alert("âš ï¸ HEIC/HEIF íŒŒì¼ì€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦¬ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.\nJPGë¡œ ë³€í™˜ í›„ ì¬ì‹œë„í•´ ì£¼ì„¸ìš”.");
  }
}
async function getExifOrientation(file){
  try{
    const name = (file?.name || "").toLowerCase();
    const type = (file?.type || "").toLowerCase();
    const isJpeg = type.includes("jpeg") || type.includes("jpg") || name.endsWith(".jpg") || name.endsWith(".jpeg");
    if(!isJpeg) return 1;

    const buf = await file.slice(0, 256 * 1024).arrayBuffer();
    const view = new DataView(buf);
    if(view.getUint16(0, false) !== 0xFFD8) return 1;

    let offset = 2;
    const length = view.byteLength;
    while(offset < length){
      if(view.getUint8(offset) !== 0xFF) break;
      const marker = view.getUint8(offset + 1);
      offset += 2;
      if(marker === 0xD9 || marker === 0xDA) break;

      const segLen = view.getUint16(offset, false);
      if(segLen < 2) break;

      if(marker === 0xE1){
        const start = offset + 2;
        if(start + 6 <= length){
          const isExif = view.getUint8(start+0)===0x45 && view.getUint8(start+1)===0x78 && view.getUint8(start+2)===0x69 && view.getUint8(start+3)===0x66;
          if(isExif){
            const tiff = start + 6;
            const endian = view.getUint16(tiff, false);
            const little = (endian === 0x4949);
            const getU16 = (o)=> view.getUint16(o, little);
            const getU32 = (o)=> view.getUint32(o, little);
            const magic = getU16(tiff + 2);
            if(magic !== 0x002A) return 1;
            const ifd0Offset = getU32(tiff + 4);
            let ifd0 = tiff + ifd0Offset;
            const entries = getU16(ifd0);
            ifd0 += 2;
            for(let i=0;i<entries;i++){
              const ent = ifd0 + i*12;
              const tag = getU16(ent + 0);
              if(tag === 0x0112){
                const val = getU16(ent + 8);
                return val || 1;
              }
            }
          }
        }
      }
      offset += segLen;
    }
    return 1;
  }catch(e){ return 1; }
}

/* =========================================================
   Upload
========================================================= */
function setupDropZone(dropId, inputId, thumbId, nameId, onSetFile){
  const drop = document.getElementById(dropId);
  const input = document.getElementById(inputId);
  const thumb = document.getElementById(thumbId);
  const nameEl = document.getElementById(nameId);

  drop.addEventListener("click", ()=> input.click());
  drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("dragover"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("dragover"));
  drop.addEventListener("drop", (e)=>{
    e.preventDefault(); drop.classList.remove("dragover");
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreviewThumb(f, thumb, nameEl);
      refreshReady();
      refreshPreviewReady();
      refreshAutoPickReady();
      if(dropId==="dropPrev"){
        pvSourceCache = null;
        previewCache = null;
        if(pvBeforeCanvas) pvBeforeCanvas.width = pvBeforeCanvas.height = 0;
        if(pvAfterCanvas)  pvAfterCanvas.width  = pvAfterCanvas.height  = 0;
        queuePreviewRender("upload");
      }
    }
  });
  input.addEventListener("change", ()=>{
    const f = input.files && input.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreviewThumb(f, thumb, nameEl);
      refreshReady();
      refreshPreviewReady();
      refreshAutoPickReady();
      if(dropId==="dropPrev"){
        pvSourceCache = null;
        previewCache = null;
        if(pvBeforeCanvas) pvBeforeCanvas.width = pvBeforeCanvas.height = 0;
        if(pvAfterCanvas)  pvAfterCanvas.width  = pvAfterCanvas.height  = 0;
        queuePreviewRender("upload");
      }
    }
  });
}
function updatePreviewThumb(file, imgEl, nameEl){
  nameEl.textContent = "âœ… " + file.name;
  nameEl.style.display = "block";
  const r = new FileReader();
  r.onload = (e)=>{ imgEl.src = e.target.result; imgEl.style.display = "block"; };
  r.readAsDataURL(file);
}

/* =========================================================
   AI load
========================================================= */
function setAIUI(state, text){
  const dot = document.getElementById("dotAI");
  const label = document.getElementById("aiText");
  aiState = state;
  aiStatusText = text || aiStatusText;
  dot.className = (state === "ready") ? "dot ok" : "dot warn";
  label.textContent = aiStatusText;
}
async function ensureAIModelsLoaded(){
  if(aiState === "ready") return true;
  if(aiState === "loading") return false;

  setAIUI("loading", "AI ë¡œë”©ì¤‘â€¦(ìë™ ëª¨ë“œ)");
  try{
    await tf.ready();
    faceModel = await blazeface.load();
    classifyModel = await mobilenet.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ");
    return true;
  }catch(e){
    setAIUI("failed", "AI ì‹¤íŒ¨(ìš°íšŒ) Â· ìˆ˜ë™/ëŒ€ì²´ë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}
async function ensureCocoLoadedIfNeeded(){
  const need = (document.getElementById("aiBoost").value === "coco");
  if(!need) return false;
  if(cocoModel) return true;
  try{
    setAIUI("loading", "AI+ (COCO-SSD) ë¡œë”©ì¤‘â€¦");
    await new Promise((resolve, reject)=>{
      const s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js";
      s.onload = resolve;
      s.onerror = reject;
      document.head.appendChild(s);
    });
    cocoModel = await cocoSsd.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ + COCO-SSD");
    return true;
  }catch(e){
    setAIUI("failed", "COCO-SSD ì‹¤íŒ¨(ìš°íšŒ) Â· ê¸°ë³¸ AIë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}

/* =========================================================
   Ready
========================================================= */
function refreshReady(){
  const hasRef = !!refFileState;
  const hasOrig = !!origFileState;

  setDot("dotR", hasRef ? "ok" : "");
  setDot("dotO", (shotMode === "two" && hasOrig) ? "ok" : "");

  const btn = document.getElementById("btnAnalyze");
  const btnText = document.getElementById("btnText");

  const readyForShot = (shotMode === "one") ? hasRef : (hasRef && hasOrig);
  btn.disabled = !readyForShot;

  if(!readyForShot){ btnText.textContent = "ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”"; return; }
  btnText.textContent = (userMode === "auto" && aiState !== "ready") ? "âš¡ ë¶„ì„ ì‹œì‘ (í•„ìš” ì‹œ AI ë¡œë”©)" : "âš¡ ë¶„ì„ ì‹œì‘";
}

/* =========================================================
   Image decode + draw
========================================================= */
async function fileToHTMLImage(file){
  return await new Promise((resolve, reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}
async function decodeToImageBitmap(file){
  try{
    if(typeof createImageBitmap === "function") return await createImageBitmap(file);
    throw new Error("createImageBitmap not available");
  }catch(e){
    return await fileToHTMLImage(file);
  }
}
function applyOrientationTransform(ctx, orientation, w, h){
  switch(orientation){
    case 2: ctx.translate(w, 0); ctx.scale(-1, 1); break;
    case 3: ctx.translate(w, h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0, h); ctx.scale(1, -1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1); break;
    case 6: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); break;
    case 7: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); ctx.scale(-1, 1); break;
    case 8: ctx.translate(0, h); ctx.rotate(-0.5*Math.PI); break;
  }
}
function drawScaledToCanvas(canvas, bitmapOrImg, maxDim, orientation=1){
  const ow = bitmapOrImg.width;
  const oh = bitmapOrImg.height;

  const swapWH = (orientation>=5 && orientation<=8);
  const rw = swapWH ? oh : ow;
  const rh = swapWH ? ow : oh;

  const scale = Math.min(1, maxDim / Math.max(rw, rh));
  const tw = Math.max(1, Math.round(rw * scale));
  const th = Math.max(1, Math.round(rh * scale));

  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  canvas.width = tw; canvas.height = th;

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,tw,th);

  ctx.save();
  applyOrientationTransform(ctx, orientation, tw, th);
  if(swapWH) ctx.drawImage(bitmapOrImg, 0, 0, th, tw);
  else ctx.drawImage(bitmapOrImg, 0, 0, tw, th);
  ctx.restore();
  ctx.restore();

  return {w:tw, h:th};
}
function getImageDataFromCanvas(canvas){
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  return ctx.getImageData(0,0,canvas.width, canvas.height);
}
async function fileToOrientedCanvas(file, maxDim){
  const ori = await getExifOrientation(file);
  const bm  = await decodeToImageBitmap(file);
  const c = document.createElement("canvas");
  drawScaledToCanvas(c, bm, maxDim, ori);
  return c;
}
function resampleCanvasToSize(srcCanvas, w, h){
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  const ctx = c.getContext("2d", {willReadFrequently:true});
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(srcCanvas, 0,0, w,h);
  return c;
}

/* =========================================================
   PSE HSL Guard
========================================================= */
function pseConeMaxS01(l01){
  const t = Math.abs(2*l01 - 1);
  return clamp(1 - t, 0, 1);
}
function pseGuardAxisAdjust(axis, avgL01){
  const cone = pseConeMaxS01(avgL01);
  const scale = clamp(0.35 + 0.65*cone, 0.35, 1.0);

  let s = axis.canonS;
  const absS = Math.abs(s);
  const softCap = Math.round(30 * clamp(cone*1.15, 0.15, 1.0));
  if(absS > softCap){
    s = Math.round(Math.sign(s) * (softCap + (absS-softCap)*0.25));
  }
  s = Math.round(s * scale);

  let l = axis.canonL;
  const lScale = clamp(0.55 + 0.45*cone, 0.55, 1.0);
  l = Math.round(l * lScale);

  return {...axis, canonS: clamp(s,-30,30), canonL: clamp(l,-30,30)};
}

/* =========================================================
   Curve helper
========================================================= */
function curve5ToLUT(curve5){
  const xs = [0,64,128,192,255];
  const ys = xs.map(x => clamp(Math.round(curve5[x]), 0, 255));
  const lut = new Uint8Array(256);
  for(let i=0;i<xs.length-1;i++){
    const x0=xs[i], x1=xs[i+1];
    const y0=ys[i], y1=ys[i+1];
    const dx = (x1 - x0);
    for(let x=x0; x<=x1; x++){
      const t = dx === 0 ? 0 : (x - x0) / dx;
      lut[x] = clamp(Math.round(lerp(y0, y1, t)), 0, 255);
    }
  }
  for(let i=1;i<256;i++){ if(lut[i] < lut[i-1]) lut[i] = lut[i-1]; }
  return lut;
}
function identityLUT(){
  const lut = new Uint8Array(256);
  for(let i=0;i<256;i++) lut[i]=i;
  return lut;
}

/* =========================================================
   PREVIEW: preset-only recipe
========================================================= */
function buildPresetOnlyRecipe(presetKey, presetStrength01){
  const idLUT = identityLUT();
  if(!presetKey || presetKey==="off" || !FUJI_PRESETS[presetKey] || presetStrength01<=0){
    return {
      name: "Identity",
      contrast: 0, sat: 0, tone: 0,
      toneLUT: idLUT,
      axes: ["R","Y","G","C","B","M"].map(k=>({axis:k,canonH:0,canonS:0,canonL:0,avgL01:0.5})),
      specificPoints: [],
      meta: "Preset OFF",
      matrix: null, satDamp: null, colorChrome: null, splitToning: null,
    };
  }

  const p = FUJI_PRESETS[presetKey];
  const pLUT = curve5ToLUT(p.curve5);
  const outLUT = new Uint8Array(256);
  for(let i=0;i<256;i++){
    outLUT[i] = clamp(Math.round(lerp(idLUT[i], pLUT[i], presetStrength01)), 0, 255);
  }
  for(let i=1;i<256;i++){ if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1]; }

  const axes = ["R","Y","G","C","B","M"].map(k=>{
    const a = p.axes[k];
    const base = {axis:k,
      canonH: clamp(Math.round(a.H * presetStrength01), -30, 30),
      canonS: clamp(Math.round(a.S * presetStrength01), -30, 30),
      canonL: clamp(Math.round(a.L * presetStrength01), -30, 30),
      avgL01: 0.5
    };
    return pseGuardAxisAdjust(base, 0.5);
  });

  return {
    name: p.name,
    contrast: clamp(Math.round(p.contrast * presetStrength01), -4, 4),
    sat:      clamp(Math.round(p.sat * presetStrength01), -4, 4),
    tone:     clamp(Math.round(p.tone * presetStrength01), -4, 4),
    toneLUT: outLUT,
    axes,
    specificPoints: [],
    meta: `PresetOnly ${p.name} ${Math.round(presetStrength01*100)}%`,
    matrix: p.matrix || null,
    satDamp: p.satDamp || null,
    colorChrome: p.colorChrome || null,
    splitToning: p.splitToning || null,
  };
}

/* =========================================================
   Preview EV apply (linear domain, LUT)
========================================================= */
function buildGammaTables(){
  if(SRGB_TO_LIN_256 && LIN_TO_SRGB_4096) return;

  SRGB_TO_LIN_256 = new Float32Array(256);
  for(let i=0;i<256;i++){
    const u = i/255;
    SRGB_TO_LIN_256[i] = (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
  }

  LIN_TO_SRGB_4096 = new Uint8Array(4096);
  for(let i=0;i<4096;i++){
    const x = i/4095;
    const u = (x <= 0.0031308) ? (12.92*x) : (1.055*Math.pow(x, 1/2.4) - 0.055);
    LIN_TO_SRGB_4096[i] = clamp(Math.round(u*255), 0, 255);
  }
}
function lin01ToSrgb255(x){
  const idx = clamp(Math.round(x * 4095), 0, 4095);
  return LIN_TO_SRGB_4096[idx];
}
function applyExposureEVToImageData(srcImageData, ev){
  buildGammaTables();

  const w = srcImageData.width, h = srcImageData.height;
  const src = srcImageData.data;
  const out = new ImageData(w,h);
  const dst = out.data;

  const mul = Math.pow(2, clamp(ev, -5, 5));
  for(let i=0;i<src.length;i+=4){
    const a = src[i+3];

    const rl = SRGB_TO_LIN_256[src[i]]   * mul;
    const gl = SRGB_TO_LIN_256[src[i+1]] * mul;
    const bl = SRGB_TO_LIN_256[src[i+2]] * mul;

    dst[i]   = lin01ToSrgb255(clamp(rl,0,1));
    dst[i+1] = lin01ToSrgb255(clamp(gl,0,1));
    dst[i+2] = lin01ToSrgb255(clamp(bl,0,1));
    dst[i+3] = a;
  }
  return out;
}

/* =========================================================
   PREVIEW: apply recipe to ImageData (Engine)
========================================================= */
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h=0,s=0;
  const l=(max+min)/2;
  if(max!==min){
    const d=max-min;
    s = l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  return [h*360, s, l];
}
function hue2rgb(p, q, t){
  if(t<0) t+=1;
  if(t>1) t-=1;
  if(t<1/6) return p + (q-p)*6*t;
  if(t<1/2) return q;
  if(t<2/3) return p + (q-p)*(2/3 - t)*6;
  return p;
}
function hslToRgb(hDeg, s, l){
  let r,g,b;
  const h = ((hDeg%360)+360)%360 / 360;
  if(s===0){
    r=g=b=l;
  }else{
    const q = l < 0.5 ? l*(1+s) : l + s - l*s;
    const p = 2*l - q;
    r = hue2rgb(p,q,h + 1/3);
    g = hue2rgb(p,q,h);
    b = hue2rgb(p,q,h - 1/3);
  }
  return [Math.round(clamp(r,0,1)*255), Math.round(clamp(g,0,1)*255), Math.round(clamp(b,0,1)*255)];
}
function circularHueDiffDeg(a,b){
  let d=(a-b)%360;
  if(d>180) d-=360;
  if(d<=-180) d+=360;
  return d;
}
function axisFromHue(h){
  if(h>=340 || h<20) return "R";
  if(h>=20 && h<80) return "Y";
  if(h>=80 && h<150) return "G";
  if(h>=150 && h<210) return "C";
  if(h>=210 && h<280) return "B";
  return "M";
}
function buildAxisMap(axes){
  const m = {};
  (axes||[]).forEach(a=> m[a.axis] = a);
  return m;
}
function applyMatrixRGB255(r,g,b, m){
  const rf = r/255, gf = g/255, bf = b/255;
  const r2 = rf*m[0][0] + gf*m[0][1] + bf*m[0][2];
  const g2 = rf*m[1][0] + gf*m[1][1] + bf*m[1][2];
  const b2 = rf*m[2][0] + gf*m[2][1] + bf*m[2][2];
  return [
    Math.round(clamp(r2,0,1)*255),
    Math.round(clamp(g2,0,1)*255),
    Math.round(clamp(b2,0,1)*255),
  ];
}
function applySatLumaDamp(s, l, cfg, strength01){
  if(!cfg) return s;
  const hi = smoothstep(cfg.hiStart ?? 0.80, 1.0, l);
  const hs = smoothstep(cfg.satStart ?? 0.70, 1.0, s);
  const damp = 1.0
    - (cfg.hiStrength ?? 0.0) * hi * strength01
    - (cfg.satStrength ?? 0.0) * hs * strength01;
  const floor = cfg.floor ?? 0.60;
  return clamp(s * clamp(damp, floor, 1.0), 0, 1);
}
function applyVelviaColorChrome(s, l, cfg, strength01){
  if(!cfg) return {s,l};
  const satStart = cfg.satStart ?? 0.62;
  const tSat = smoothstep(satStart, 1.0, s);
  const mid = cfg.lumaMid ?? 0.60;
  const range = cfg.lumaRange ?? 0.35;
  const tLum = 1.0 - clamp(Math.abs(l - mid) / Math.max(1e-6, range), 0, 1);
  const t = tSat * tLum;
  const k = (cfg.strength ?? 0.25) * strength01;

  const l2 = clamp(l - (0.12*k)*t, 0, 1);
  const s2 = clamp(s - (0.10*k)*t, 0, 1);
  return {s:s2, l:l2};
}
function applySplitToning(hDeg, s, l, stCfg, strength01){
  if(!stCfg) return {hDeg,s,l};
  const pivot = stCfg.pivot ?? 0.55;
  const shT = smoothstep(0.0, pivot, pivot - l);
  const hiT = smoothstep(pivot, 1.0, l);

  const shAmt = (stCfg.shAmt ?? 0.06) * strength01 * shT;
  const hiAmt = (stCfg.hiAmt ?? 0.05) * strength01 * hiT;

  const h1 = hDeg + circularHueDiffDeg(stCfg.shHue ?? 190, hDeg) * shAmt;
  const h2 = h1   + circularHueDiffDeg(stCfg.hiHue ?? 25,  h1)   * hiAmt;

  const s2 = clamp(s * (1 + 0.08*(shAmt + hiAmt)), 0, 1);
  return {hDeg:h2, s:s2, l};
}
function applyRecipeToImageData(srcImageData, recipe, strength01, enablePoints){
  const w = srcImageData.width, h = srcImageData.height;
  const src = srcImageData.data;
  const out = new ImageData(w,h);
  const dst = out.data;

  const lut = recipe.toneLUT || identityLUT();
  const cFactor = 1 + (recipe.contrast||0) * 0.12 * strength01;
  const sFactor = 1 + (recipe.sat||0) * 0.18 * strength01;
  const toneDeg = (recipe.tone||0) * 2.0 * strength01;

  const axisMap = buildAxisMap(recipe.axes || []);
  const points = enablePoints ? (recipe.specificPoints || []).slice(0, 12) : [];
  const hasPoints = points.length>0;

  const mtx = recipe.matrix || null;
  const satDamp = recipe.satDamp || null;
  const chrome = recipe.colorChrome || null;
  const splitToning = recipe.splitToning || null;

  for(let i=0;i<src.length;i+=4){
    let r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];

    r = lut[r]; g = lut[g]; b = lut[b];

    if(mtx){
      const rr = applyMatrixRGB255(r,g,b, mtx);
      r = rr[0]; g = rr[1]; b = rr[2];
    }

    let [hDeg, s, l] = rgbToHsl(r,g,b);

    l = clamp(0.5 + (l - 0.5)*cFactor, 0, 1);
    s = clamp(s * sFactor, 0, 1);
    hDeg = (hDeg + toneDeg);

    const axK = axisFromHue(hDeg);
    const ax = axisMap[axK];
    if(ax){
      hDeg += ax.canonH * strength01;
      s = clamp(s * (1 + (ax.canonS/55) * strength01), 0, 1);
      l = clamp(l + (ax.canonL/220) * strength01, 0, 1);
    }

    s = applySatLumaDamp(s, l, satDamp, strength01);

    if(chrome){
      const rr = applyVelviaColorChrome(s, l, chrome, strength01);
      s = rr.s; l = rr.l;
    }

    if(splitToning){
      const rr = applySplitToning(hDeg, s, l, splitToning, strength01);
      hDeg = rr.hDeg; s = rr.s; l = rr.l;
    }

    if(hasPoints){
      for(let p=0;p<points.length;p++){
        const pt = points[p];
        const dh = Math.abs(circularHueDiffDeg(hDeg, pt.inH));
        if(dh > 18) continue;
        const ds = Math.abs(s - pt.inS);
        const dl = Math.abs(l - pt.inL);
        if(ds > 0.35 || dl > 0.35) continue;

        const wh = 1 - (dh/18);
        const ws = 1 - (ds/0.35);
        const wl = 1 - (dl/0.35);
        const wgt = clamp(wh*ws*wl, 0, 1) * 0.35 * strength01;

        hDeg = hDeg + circularHueDiffDeg(pt.outH, hDeg) * wgt;
        s = lerp(s, pt.outS, wgt);
        l = lerp(l, pt.outL, wgt);
      }
    }

    const rgb = hslToRgb(hDeg, s, l);
    dst[i]   = rgb[0];
    dst[i+1] = rgb[1];
    dst[i+2] = rgb[2];
    dst[i+3] = a;
  }
  return out;
}

/* =========================================================
   PREVIEW: internal canvases (cache)
========================================================= */
function ensurePvCanvases(w,h){
  if(!pvBeforeCanvas) pvBeforeCanvas = document.createElement("canvas");
  if(!pvAfterCanvas)  pvAfterCanvas  = document.createElement("canvas");
  if(pvBeforeCanvas.width !== w || pvBeforeCanvas.height !== h){
    pvBeforeCanvas.width = w; pvBeforeCanvas.height = h;
  }
  if(pvAfterCanvas.width !== w || pvAfterCanvas.height !== h){
    pvAfterCanvas.width = w; pvAfterCanvas.height = h;
  }
}

/* =========================================================
   PREVIEW: split draw (cached canvases)
========================================================= */
function drawSplitFromCache(){
  if(!previewCache || !pvBeforeCanvas || !pvAfterCanvas) return;

  const canvas = document.getElementById("previewCanvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:false});

  const w = previewCache.w, h = previewCache.h;
  canvas.width = w; canvas.height = h;

  ctx.drawImage(pvAfterCanvas, 0, 0);

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, Math.round(w * split01), h);
  ctx.clip();
  ctx.drawImage(pvBeforeCanvas, 0, 0);
  ctx.restore();

  const x = Math.round(w*split01)+0.5;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.88)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
  ctx.fillStyle = "rgba(255,255,255,0.88)";
  ctx.beginPath();
  ctx.arc(x, Math.min(22, h*0.12), 7, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  updatePreviewLabels();
}

/* =========================================================
   PREVIEW: render task (throttled)
========================================================= */
let previewRenderToken = 0;
function queuePreviewRender(reason){
  if(!prevFileState) return;

  if(pvDragging){
    const allow = (reason==="manualClick" || reason==="upload" || reason==="analysisComplete" || reason==="presetChange" || reason==="previewModeChange" || reason==="previewDimChange");
    if(!allow) return;
  }

  const token = ++previewRenderToken;
  setTimeout(()=>{ if(token===previewRenderToken) renderPreview(reason); }, 90);
}

/* =========================================================
   âœ… v11.5.2: EVëŠ” "ìš°ì¸¡(ì ìš© ê²°ê³¼)"ì—ë§Œ ì ìš©
========================================================= */
async function renderPreview(reason){
  if(!prevFileState) return;
  if(previewBusy) return;
  previewBusy = true;

  try{
    const mode = document.getElementById("previewMode").value;
    const pd = parseInt(document.getElementById("previewDim").value, 10);
    const st01 = parseInt(document.getElementById("previewStrength").value,10)/100;
    const ev = parseFloat(document.getElementById("previewEV").value || "0");

    const useRecipe = (mode === "recipe");
    if(useRecipe && !lastRecipe){
      setPvMeta("ë ˆì‹œí”¼ ì—†ìŒ(ë¨¼ì € ë¶„ì„í•˜ì„¸ìš”)");
      previewCache = null;
      return;
    }

    const sig = fileSig(prevFileState);
    const srcKey = `${sig}|${pd}`;

    let before;
    if(pvSourceCache && pvSourceCache.key === srcKey && pvSourceCache.before){
      before = pvSourceCache.before;
    }else{
      const ori = await getExifOrientation(prevFileState);
      const bm = await decodeToImageBitmap(prevFileState);
      const canvas = document.createElement("canvas");
      drawScaledToCanvas(canvas, bm, pd, ori);
      before = getImageDataFromCanvas(canvas);
      pvSourceCache = { key: srcKey, before, w: before.width, h: before.height };
    }

    let recipe;
    let meta;
    if(useRecipe){
      recipe = lastRecipe;
      meta = `Recipe Â· ${lastRecipe.baseHint || "Last"} Â· preview ${Math.round(st01*100)}%`;
    }else{
      const presetKey = document.getElementById("fujiPreset").value;
      const pStrength = parseInt(document.getElementById("presetStrength").value, 10)/100;
      recipe = buildPresetOnlyRecipe(presetKey, pStrength);
      meta = `${recipe.meta} Â· preview ${Math.round(st01*100)}%`;
    }

    // (1) after = recipe ì ìš©
    const enablePoints = useRecipe;
    let after = applyRecipeToImageData(before, recipe, st01, enablePoints);

    // (2) EVëŠ” afterì—ë§Œ ì ìš©
    if(Math.abs(ev) >= 1e-6){
      after = applyExposureEVToImageData(after, ev);
    }

    ensurePvCanvases(before.width, before.height);
    pvBeforeCanvas.getContext("2d", {willReadFrequently:true}).putImageData(before, 0, 0);
    pvAfterCanvas.getContext("2d", {willReadFrequently:true}).putImageData(after, 0, 0);

    const evTxt = (ev>=0?"+":"") + ev.toFixed(1);
    previewCache = { w: before.width, h: before.height, metaText: meta };
    setPvMeta(`${meta} Â· EV(after) ${evTxt} Â· ${before.width}x${before.height}`);

    drawSplitFromCache();
  }catch(e){
    console.error(e);
    setPvMeta("ë¯¸ë¦¬ë³´ê¸° ì˜¤ë¥˜: ì´ë¯¸ì§€/ë¸Œë¼ìš°ì € ì œí•œ í™•ì¸");
  }finally{
    previewBusy = false;
  }
}

/* =========================================================
   PREVIEW: drag interaction
========================================================= */
function setSplitFromClientX(clientX){
  const canvas = document.getElementById("previewCanvas");
  const rect = canvas.getBoundingClientRect();
  const x = clamp((clientX - rect.left) / Math.max(1, rect.width), 0, 1);
  split01 = x;
  drawSplitFromCache();
}
function bindPreviewDrag(){
  const canvas = document.getElementById("previewCanvas");
  let dragging = false;

  const onDown = (e)=>{
    if(!previewCache) return;
    dragging = true;
    pvDragging = true;
    if(e.pointerId !== undefined && canvas.setPointerCapture){
      try{ canvas.setPointerCapture(e.pointerId); }catch(_){}
    }
    setSplitFromClientX(e.clientX);
  };
  const onMove = (e)=>{
    if(!dragging) return;
    setSplitFromClientX(e.clientX);
  };
  const onUp = ()=>{
    dragging = false;
    pvDragging = false;
  };

  canvas.addEventListener("pointerdown", onDown);
  canvas.addEventListener("pointermove", onMove);
  canvas.addEventListener("pointerup", onUp);
  canvas.addEventListener("pointercancel", onUp);
  canvas.addEventListener("pointerleave", onUp);
}

/* =========================================================
   PREVIEW: save PNG
========================================================= */
function savePreviewPNG(){
  const canvas = document.getElementById("previewCanvas");
  if(!prevFileState || !canvas.width || !canvas.height) return;
  const a = document.createElement("a");
  const ts = new Date();
  const name = `preview_v11.5.2_${ts.getFullYear()}${String(ts.getMonth()+1).padStart(2,"0")}${String(ts.getDate()).padStart(2,"0")}_${String(ts.getHours()).padStart(2,"0")}${String(ts.getMinutes()).padStart(2,"0")}.png`;
  a.download = name;
  a.href = canvas.toDataURL("image/png");
  a.click();
}

/* =========================================================
   Worker lifecycle
========================================================= */
function terminateWorker(){
  try{ if(worker){ worker.terminate(); worker = null; } }catch(e){}
  try{ if(workerUrl){ URL.revokeObjectURL(workerUrl); workerUrl = null; } }catch(e){}
}
window.addEventListener("beforeunload", ()=> terminateWorker());

function initWorker(){
  if(worker) return;

  // Worker code (kept compact; returns extra stats for Auto FilmSim)
  const workerCode = `
    function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

    function rgbToHsl01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0;
      const l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, l];
    }
    function rgbToHsv01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0;
      const s = max===0 ? 0 : d/max;
      const v = max;
      if(d!==0){
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, v];
    }
    function srgbToLin(u){
      u/=255;
      return (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
    }
    function linRgbToXyz(lr,lg,lb){
      const X = lr*0.4124564 + lg*0.3575761 + lb*0.1804375;
      const Y = lr*0.2126729 + lg*0.7151522 + lb*0.0721750;
      const Z = lr*0.0193339 + lg*0.1191920 + lb*0.9503041;
      return [X,Y,Z];
    }
    function xyToCct(x,y){
      const n = (x - 0.3320) / (y - 0.1858 + 1e-9);
      const cct = 449*n*n*n + 3525*n*n + 6823.3*n + 5520.33;
      return cct;
    }
    function xyToUv(x,y){
      const denom = (-2*x + 12*y + 3);
      const u = (4*x) / (denom + 1e-9);
      const v = (9*y) / (denom + 1e-9);
      return [u,v];
    }
    function wbShiftFromUv(u,v){
      const u0 = 0.1978398, v0 = 0.4683363;
      const du = u - u0;
      const dv = v - v0;
      let ab = clamp(Math.round(-du * 250), -9, 9);
      let gm = clamp(Math.round(dv * 250), -9, 9);
      const abLabel = (ab>0) ? ("A" + ab) : (ab<0 ? ("B" + (-ab)) : "0");
      const gmLabel = (gm>0) ? ("G" + gm) : (gm<0 ? ("M" + (-gm)) : "0");
      const mag = Math.sqrt(du*du + dv*dv);
      const rel = clamp((mag*120), 0.15, 1.0);
      return {ab, gm, abLabel, gmLabel, rel};
    }
    function circularHueDiff(h2,h1){
      let d=(h2-h1)%360;
      if(d>180) d-=360;
      if(d<=-180) d+=360;
      return d;
    }

    function luminanceHistFromRGBA(rgba, stridePx){
      const hist = new Uint32Array(256);
      let total=0, tooDark=0, tooBright=0;
      const step = 4 * Math.max(1, stridePx|0);
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) | 0;
        hist[lum]++; total++;
        if(lum<=10) tooDark++;
        if(lum>=245) tooBright++;
      }
      return {hist,total,tooDark,tooBright};
    }
    function uniformHist(){
      const hist = new Uint32Array(256);
      for(let i=0;i<256;i++) hist[i]=1;
      return {hist,total:256,tooDark:0,tooBright:0};
    }
    function cdfFromHist(hist,total){
      const cdf = new Float32Array(256);
      let acc=0;
      for(let i=0;i<256;i++){ acc += hist[i]; cdf[i] = acc/total; }
      return cdf;
    }
    function buildToneLUTByCDFMatch(cdfO,cdfR){
      const lut = new Uint8Array(256);
      let j=0;
      for(let i=0;i<256;i++){
        const p = cdfO[i];
        while(j<255 && cdfR[j] < p) j++;
        lut[i]=j;
      }
      return lut;
    }
    function percentileByHist(hist,total,p){
      const target = total*p;
      let acc=0;
      for(let i=0;i<256;i++){
        acc+=hist[i];
        if(acc>=target) return i;
      }
      return 255;
    }
    function applyBlackLiftCompensation(lut, refP02){
      const liftRaw = Math.max(0, refP02 - 10);
      const strength = Math.max(0, Math.min(1, liftRaw/22));
      const liftPx = Math.round(6 + 18*strength);
      const out = new Uint8Array(256);
      for(let i=0;i<256;i++){
        let boost = 0;
        if(i < 128) boost = liftPx * (1 - (i/128));
        out[i] = Math.min(255, lut[i] + boost);
        if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
      }
      return {lut: out, strength, liftPx, isLifted: strength>=0.20};
    }

    function estimateExposure(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sh=0, hi=0, mid=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 50) sh++;
        else if(y > 205) hi++;
        else mid++;
        n++;
      }
      if(n<=0) return {shadowRatio:0, highlightRatio:0, midRatio:0, note:"-"};
      const sr = sh/n, hr = hi/n, mr = mid/n;
      let note = "Balanced";
      if(hr>0.35) note = "Highlight heavy";
      if(sr>0.35) note = "Shadow heavy";
      if(hr>0.30 && sr>0.30) note = "Extreme contrast";
      return {shadowRatio:sr, highlightRatio:hr, midRatio:mr, note};
    }

    function estimateRegions(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sky=0, fol=0, skin=0, valid=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 18 || y > 245) continue;

        const hsv = rgbToHsv01(r,g,b);
        const hDeg = hsv[0]*360;
        const s = hsv[1], v = hsv[2];
        if(s < 0.10) continue;

        valid++;
        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        const isSky = (hDeg >= 190 && hDeg <= 245 && s >= 0.18 && v >= 0.22);
        const isFol = (hDeg >= 70 && hDeg <= 160 && s >= 0.18 && v >= 0.18);
        if(isSkin) skin++;
        if(isSky)  sky++;
        if(isFol)  fol++;
      }
      if(valid <= 0) return {sky:0, foliage:0, skin:0, valid:0};
      return { sky: clamp(sky/valid,0,1), foliage: clamp(fol/valid,0,1), skin: clamp(skin/valid,0,1), valid };
    }

    function estimateSkinGlobal(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let skin=0, total=0, hi=0, hiTotal=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 28 || y > 245) continue;
        const hsv = rgbToHsv01(r,g,b);
        if(hsv[1] < 0.10) continue;

        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;

        total++;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        if(isSkin){
          skin++;
          if(y >= 210) hi++;
        }
        if(y >= 210) hiTotal++;
      }
      const ratio = total>0 ? (skin/total) : 0;
      const highlightRisk = hiTotal>0 ? (hi/hiTotal) : 0;
      return {ratio: clamp(ratio,0,1), highlightRisk: clamp(highlightRisk,0,1), sampled: total, source:"global"};
    }

    function estimateWB(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sumX=0, sumY=0, sumZ=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(lum < 18 || lum > 245) continue;
        const xyz = linRgbToXyz(srgbToLin(r), srgbToLin(g), srgbToLin(b));
        sumX += xyz[0]; sumY += xyz[1]; sumZ += xyz[2]; n++;
      }
      if(n < 300) return {ok:false, kelvin: 0, abLabel:"0", gmLabel:"0", reliability:0.15, note:"ìƒ˜í”Œ ë¶€ì¡±"};
      const X = sumX/n, Y = sumY/n, Z = sumZ/n;
      const denom = (X+Y+Z) + 1e-9;
      let cct = xyToCct(X/denom, Y/denom);
      if(!isFinite(cct)) cct = 5200;
      const uv = xyToUv(X/denom, Y/denom);
      const sh = wbShiftFromUv(uv[0], uv[1]);
      const reliability = clamp(0.55*clamp(n/6000, 0.2, 1.0) + 0.45*sh.rel, 0.2, 1.0);
      return {ok:true, kelvin: clamp(Math.round(cct/10)*10, 2000, 10000), ab: sh.ab, gm: sh.gm, abLabel: sh.abLabel, gmLabel: sh.gmLabel, reliability, note: "íƒ€ê²Ÿ í‰ê·  ê¸°ë°˜" };
    }

    function getColorAxesDataWeighted(rgba, stridePx){
      const buckets = {
        R:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        Y:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        G:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        C:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        B:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        M:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      };

      let valid=0;
      let sumS=0, sumTone=0, toneN=0;
      const step = 4 * Math.max(1, stridePx|0);

      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const hsl = rgbToHsl01(r,g,b);
        let h=hsl[0]*360, s=hsl[1], l=hsl[2];

        if(s < 0.08) continue;
        if(l < 0.06 || l > 0.94) continue;

        let k='M';
        if(h>=340 || h<20) k='R';
        else if(h>=20 && h<80) k='Y';
        else if(h>=80 && h<150) k='G';
        else if(h>=150 && h<210) k='C';
        else if(h>=210 && h<280) k='B';
        else k='M';

        const wS = Math.pow(s, 1.5);
        const wL = 1.0 - Math.min(0.8, Math.abs(l-0.5)*1.6);
        const w = Math.max(0.01, wS*wL);

        const rad = h*Math.PI/180;
        const bk = buckets[k];
        bk.sumCos += Math.cos(rad)*w;
        bk.sumSin += Math.sin(rad)*w;
        bk.sumS += s*w;
        bk.sumL += l*w;
        bk.wSum += w;
        bk.count++;
        valid++;

        sumS += s;
        sumTone += Math.sin(rad);
        toneN++;
      }

      const out={};
      for(const k in buckets){
        const b=buckets[k];
        if(b.wSum>0){
          let hh = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
          if(hh<0) hh+=360;
          out[k]={H:hh, S:b.sumS/b.wSum, L:b.sumL/b.wSum, count:b.count};
        } else {
          out[k]={H:0,S:0,L:0,count:0};
        }
      }

      const avgS = toneN>0 ? (sumS/toneN) : 0;
      const avgTone = toneN>0 ? (sumTone/toneN) : 0;
      return {axes: out, validColored: valid, avgS, avgTone};
    }

    function baseRecommend(mode, aiType, axesR, totalColored, contrast){
      if(mode !== "auto"){
        if(mode==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"ìˆ˜ë™"};
        if(mode==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"ìˆ˜ë™"};
        if(mode==="night") return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ìˆ˜ë™"};
        if(mode==="snap") return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
        return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
      }
      if(aiType==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"AI ê°ì§€"};
      if(aiType==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"AI ê°ì§€"};
      if(totalColored < 1500) return {base:"ëª¨ë…¸í¬ë¡¬ (Monochrome)", reason:"ìƒ‰ìƒ ë°ì´í„° ì ìŒ"};
      if((axesR.R.count + axesR.Y.count) > totalColored*0.55) return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"R/Y ë¹„ì¤‘"};
      if((axesR.G.count + axesR.B.count + axesR.C.count) > totalColored*0.45) return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"G/B/C ë¹„ì¤‘"};
      if(contrast <= -2) return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ê³„ì¡° í™•ë³´"};
      return {base:"í‘œì¤€ (Standard)", reason:"ë²”ìš©"};
    }

    self.onmessage = (e)=>{
      const {origBuf, refBuf, hasOrig, aiType, mode, stridePx, enableSpecPoints} = e.data;
      const stride = Math.max(1, stridePx|0);

      const refRGBA = new Uint8ClampedArray(refBuf);
      const origRGBA = hasOrig ? new Uint8ClampedArray(origBuf) : null;

      const r = luminanceHistFromRGBA(refRGBA, stride);
      const o = hasOrig ? luminanceHistFromRGBA(origRGBA, stride) : uniformHist();

      let lut = buildToneLUTByCDFMatch(cdfFromHist(o.hist, o.total), cdfFromHist(r.hist, r.total));
      const lift = applyBlackLiftCompensation(lut, percentileByHist(r.hist, r.total, 0.02));
      lut = lift.lut;

      const oRange = Math.max(1, percentileByHist(o.hist, o.total, 0.95) - percentileByHist(o.hist, o.total, 0.05));
      const rRange = Math.max(1, percentileByHist(r.hist, r.total, 0.95) - percentileByHist(r.hist, r.total, 0.05));
      let contrast = clamp(Math.round(((rRange/oRange)-1)*6), -4, 4);

      const exposure = estimateExposure(refRGBA, stride);
      if(exposure.note === "Extreme contrast") contrast = clamp(contrast - 1, -4, 4);

      const cR = getColorAxesDataWeighted(refRGBA, stride);
      const axesR = cR.axes;
      const axesO = hasOrig ? getColorAxesDataWeighted(origRGBA, stride).axes : {
        R:{H:0,S:0.24,L:0.50,count:9999},
        Y:{H:60,S:0.24,L:0.50,count:9999},
        G:{H:120,S:0.24,L:0.50,count:9999},
        C:{H:180,S:0.24,L:0.50,count:9999},
        B:{H:240,S:0.24,L:0.50,count:9999},
        M:{H:300,S:0.24,L:0.50,count:9999},
      };

      const keys = ['R','Y','G','C','B','M'];
      const axesOut = [];
      for(let i=0;i<6;i++){
        const k = keys[i];
        const rA = axesR[k];
        const oA = axesO[k];

        const countR = rA.count || 0;
        const reliability = clamp(Math.sqrt(countR / 2000), 0.20, 1.0);

        const diffH = circularHueDiff(rA.H, oA.H);
        const diffS = (rA.S - oA.S) * 100;
        const diffL = (rA.L - oA.L) * 100;

        axesOut.push({
          axis: k,
          canonH: clamp(Math.round((diffH/6.0) * reliability), -30, 30),
          canonS: clamp(Math.round((diffS/10.0) * reliability), -30, 30),
          canonL: clamp(Math.round((diffL/10.0) * reliability), -30, 30),
          avgL01: clamp(rA.L || 0.5, 0, 1),
          countR
        });
      }

      const baseRec = baseRecommend(mode, aiType, axesR, cR.validColored, contrast);
      const warnings = [];
      if((r.tooDark / r.total) > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ì–´ë‘¡ìŠµë‹ˆë‹¤(ì•”ë¶€ ë¹„ì¤‘â†‘).");
      if((r.tooBright / r.total) > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ë°ìŠµë‹ˆë‹¤(ëª…ë¶€ ë¹„ì¤‘â†‘).");
      if(cR.validColored < 1500) warnings.push("ìœ íš¨ ìƒ‰ìƒ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤(ì €ì±„ë„/ë¬´ì±„ìƒ‰). 6ìƒ‰ì¶•ì€ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.");

      const wb = estimateWB(refRGBA, stride);
      const skin = estimateSkinGlobal(refRGBA, stride);
      const regions = estimateRegions(refRGBA, stride);

      let specificPoints = [];
      let spDebug = null;
      if(enableSpecPoints && hasOrig){
        // ì´ ë¹Œë“œëŠ” Worker ë‚´ë¶€ í¬ì¸íŠ¸ ê³„ì‚°ì„ ìƒëµ (í•„ìš”ì‹œ í™•ì¥ ê°€ëŠ¥)
        specificPoints = [];
        spDebug = {minCount:0,candidates:0,note:"(disabled in worker for size)"}; 
        warnings.push("Specific Points: (ì´ ë¹Œë“œì—ì„œëŠ” Worker ë‚´ë¶€ í¬ì¸íŠ¸ ê³„ì‚°ì„ ìƒëµí–ˆìŠµë‹ˆë‹¤. í•„ìš”í•˜ë©´ ë§ì”€í•´ ì£¼ì„¸ìš”.)");
      }else if(enableSpecPoints && !hasOrig){
        warnings.push("Specific Points: 2ì¥ ëª¨ë“œì—ì„œë§Œ ìƒì„±ë©ë‹ˆë‹¤.");
      }

      self.postMessage({
        ok:true,
        contrast,
        sat: clamp(Math.round((cR.avgS - 0.45) * 10), -4, 4),
        tone: clamp(Math.round(cR.avgTone * 4), -4, 4),
        toneLUT: lut,
        lift: {isLifted: lift.isLifted, strength: lift.strength, liftPx: lift.liftPx},
        base: baseRec.base,
        baseReason: baseRec.reason,
        axes: axesOut,
        warnings,
        wb,
        skin,
        exposure,
        regions,
        specificPoints,
        spDebug,
        aiTypeDetected: aiType,

        avgS01: cR.avgS,
        avgToneRaw: cR.avgTone,
        validColored: cR.validColored,
        tooDarkRatio: (r.total>0 ? (r.tooDark/r.total) : 0),
        tooBrightRatio: (r.total>0 ? (r.tooBright/r.total) : 0),
      });
    };
  `;

  workerUrl = URL.createObjectURL(new Blob([workerCode], {type:"application/javascript"}));
  worker = new Worker(workerUrl);
}

/* =========================================================
   Auto FilmSim Picker (target-only)
========================================================= */
function scoreClamp01(x){ return clamp(x, 0, 1); }

function recommendFilmSimFromTarget(res){
  const avgS   = clamp(res?.avgS01 ?? 0.45, 0, 1);
  const sky    = clamp(res?.regions?.sky ?? 0, 0, 1);
  const fol    = clamp(res?.regions?.foliage ?? 0, 0, 1);
  const skinR  = clamp(res?.skin?.ratio ?? 0, 0, 1);
  const hiR    = clamp(res?.exposure?.highlightRatio ?? 0, 0, 1);
  const shR    = clamp(res?.exposure?.shadowRatio ?? 0, 0, 1);
  const expNote= (res?.exposure?.note ?? "Balanced");
  const tooDark= clamp(res?.tooDarkRatio ?? 0, 0, 1);
  const tooBright= clamp(res?.tooBrightRatio ?? 0, 0, 1);
  const colored = clamp((res?.validColored ?? 0) / 2500, 0, 1);

  const isPortrait = (skinR > 0.14) || ((res?.aiTypeDetected ?? "") === "portrait");
  const isLandscape = (sky + fol > 0.55) || ((res?.aiTypeDetected ?? "") === "landscape");
  const isVivid = (avgS > 0.55) && (colored > 0.35);
  const isLowSat = (avgS < 0.33) || (colored < 0.25);
  const isHighlightHeavy = (expNote === "Highlight heavy") || (hiR > 0.33) || (tooBright > 0.28);
  const isShadowHeavy = (expNote === "Shadow heavy") || (shR > 0.33) || (tooDark > 0.28);
  const isExtreme = (expNote === "Extreme contrast") || ((hiR > 0.28) && (shR > 0.28));

  const sc = {
    velvia: 0,
    eterna: 0,
    classic_chrome: 0,
    classic_negative: 0,
    nostalgic_negative: 0,
    reala_ace: 0,
    astia: 0,
    provia: 0,
  };

  sc.velvia += (isLandscape ? 0.30 : 0.05);
  sc.velvia += scoreClamp01((avgS - 0.45) * 1.6) * 0.35;
  sc.velvia += scoreClamp01((fol + sky) * 0.5) * 0.20;
  sc.velvia -= (isHighlightHeavy ? 0.10 : 0.00);

  sc.eterna += (isHighlightHeavy ? 0.35 : 0.08);
  sc.eterna += scoreClamp01((0.45 - avgS) * 1.2) * 0.15;
  sc.eterna += (isExtreme ? 0.18 : 0.00);
  sc.eterna += (isLandscape ? 0.10 : 0.05);

  sc.classic_chrome += (isLowSat ? 0.32 : 0.10);
  sc.classic_chrome += (isHighlightHeavy ? 0.14 : 0.06);
  sc.classic_chrome += scoreClamp01((0.55 - avgS) * 1.3) * 0.18;
  sc.classic_chrome += (isLandscape ? 0.10 : 0.05);

  sc.classic_negative += (isShadowHeavy ? 0.30 : 0.08);
  sc.classic_negative += (isExtreme ? 0.12 : 0.00);
  sc.classic_negative += scoreClamp01((0.50 - avgS) * 0.9) * 0.10;

  sc.nostalgic_negative += (isShadowHeavy ? 0.18 : 0.06);
  sc.nostalgic_negative += (isPortrait ? 0.16 : 0.06);
  sc.nostalgic_negative += scoreClamp01((0.48 - avgS) * 0.8) * 0.08;

  sc.reala_ace += (isPortrait ? 0.34 : 0.10);
  sc.reala_ace += scoreClamp01((0.55 - Math.abs(avgS - 0.45) * 2.0)) * 0.18;
  sc.reala_ace += (isHighlightHeavy ? 0.08 : 0.04);

  sc.astia += (isPortrait ? 0.30 : 0.06);
  sc.astia += (isHighlightHeavy ? 0.10 : 0.04);
  sc.astia += scoreClamp01((0.42 - avgS) * 0.9) * 0.06;

  sc.provia += 0.22;
  sc.provia += (isLandscape ? 0.08 : 0.04);
  sc.provia += scoreClamp01((0.50 - Math.abs(avgS - 0.42))) * 0.08;

  const entries = Object.entries(sc).sort((a,b)=> b[1]-a[1]);
  const [bestKey, bestScore] = entries[0];
  const second = entries[1]?.[1] ?? 0;

  let conf = clamp(0.45 + (bestScore - second) * 0.9 + colored * 0.25, 0.25, 0.95);

  let strength = 52;
  strength += (isVivid ? 10 : 0);
  strength += (isLandscape ? 6 : 0);
  strength += (isPortrait ? -2 : 0);
  strength += (isHighlightHeavy ? -8 : 0);
  strength += (isExtreme ? -6 : 0);
  strength += Math.round((conf - 0.5) * 20);

  if(bestKey === "velvia") strength = clamp(strength, 35, 72);
  else if(bestKey === "eterna") strength = clamp(strength, 35, 70);
  else if(bestKey === "classic_negative") strength = clamp(strength, 35, 75);
  else if(bestKey === "classic_chrome") strength = clamp(strength, 35, 75);
  else strength = clamp(strength, 35, 78);

  const reasons = [];
  if(isPortrait) reasons.push("í”¼ë¶€/ì¸ë¬¼ ë¹„ì¤‘");
  if(isLandscape) reasons.push("í’ê²½(í•˜ëŠ˜/ì´ˆë¡) ë¹„ì¤‘");
  if(isVivid) reasons.push("ê³ ì±„ë„");
  if(isLowSat) reasons.push("ì €ì±„ë„/ë¬´ì±„ ê²½í–¥");
  if(isHighlightHeavy) reasons.push("í•˜ì´ë¼ì´íŠ¸ ê³¼ë‹¤");
  if(isShadowHeavy) reasons.push("ì•”ë¶€ ê³¼ë‹¤");
  if(isExtreme) reasons.push("ê·¹ë‹¨ ëŒ€ë¹„");

  const reason = (reasons.length ? reasons.join(" Â· ") : "ë°¸ëŸ°ìŠ¤") + ` Â· avgS ${Math.round(avgS*100)}%`;

  return { key: bestKey, strength, confidence: conf, reason };
}
function applyAutoSuggestionToUI(sug, modeLabel){
  if(!sug || !sug.key) return;
  lastAutoSuggest = sug;

  document.getElementById("fujiPreset").value = sug.key;
  document.getElementById("presetStrength").value = String(sug.strength);

  updateStrengthLabel();
  updatePresetLabel();
  refreshPreviewReady();
  refreshAutoPickReady();

  if(prevFileState && document.getElementById("previewMode").value === "preset"){
    queuePreviewRender("presetChange");
  }

  const msg = `Auto FilmSim ì ìš©: ${presetDisplayName(sug.key)} Â· ${sug.strength}% (ì‹ ë¢° ${Math.round(sug.confidence*100)}%) â€” ${sug.reason}${modeLabel ? (" Â· "+modeLabel) : ""}`;
  document.getElementById("autoSuggestText").textContent = msg;
}

/* =========================================================
   Worker call helper
========================================================= */
async function runWorker(refId, origIdOrNull, aiType, stridePx, enableSpecPoints){
  initWorker();
  return await new Promise((resolve, reject)=>{
    const onMsg = (ev)=>{ cleanup(); resolve(ev.data); };
    const onErr = (err)=>{ cleanup(); reject(err); };
    const cleanup = ()=>{
      worker.removeEventListener("message", onMsg);
      worker.removeEventListener("error", onErr);
    };
    worker.addEventListener("message", onMsg);
    worker.addEventListener("error", onErr);

    const refBuf = refId.data.buffer;
    if(origIdOrNull){
      const origBuf = origIdOrNull.data.buffer;
      worker.postMessage(
        { origBuf, refBuf, hasOrig:true, aiType, mode:userMode, stridePx, enableSpecPoints },
        [origBuf, refBuf]
      );
    }else{
      worker.postMessage(
        { refBuf, hasOrig:false, aiType, mode:userMode, stridePx, enableSpecPoints },
        [refBuf]
      );
    }
  });
}

/* =========================================================
   Analyze (main)
========================================================= */
async function analyzeAll(){
  const btn = document.getElementById("btnAnalyze");
  const spin = document.getElementById("spin");
  const btnText = document.getElementById("btnText");

  if(!refFileState){ alert("íƒ€ê²Ÿ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
  if(shotMode==="two" && !origFileState){ alert("2ì¥ ëª¨ë“œì—ì„œëŠ” ì›ë³¸ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }

  btn.disabled = true;
  spin.style.display = "inline-block";
  btnText.textContent = "ë¶„ì„ ì¤‘â€¦";
  document.getElementById("resultCard").classList.add("hide");

  try{
    const maxDim = parseInt(document.getElementById("maxDim").value, 10);
    const stridePx = (maxDim >= 1280) ? 8 : 10;
    const enableSpecPoints = (document.getElementById("specPoints").value === "on");

    const refCanvas0 = await fileToOrientedCanvas(refFileState, maxDim);
    const wc = document.getElementById("workCanvas");
    const ctx = wc.getContext("2d", {willReadFrequently:true});

    let refId = null;
    let origId = null;

    if(shotMode === "two"){
      const origCanvas0 = await fileToOrientedCanvas(origFileState, maxDim);

      const W = refCanvas0.width;
      const H = refCanvas0.height;

      const refCanvas = refCanvas0;
      const origCanvas = (origCanvas0.width === W && origCanvas0.height === H)
        ? origCanvas0
        : resampleCanvasToSize(origCanvas0, W, H);

      wc.width = W; wc.height = H;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      ctx.clearRect(0,0,W,H);
      ctx.drawImage(origCanvas, 0,0, W,H);
      origId = ctx.getImageData(0,0,W,H);

      ctx.clearRect(0,0,W,H);
      ctx.drawImage(refCanvas, 0,0, W,H);
      refId = ctx.getImageData(0,0,W,H);
    }else{
      wc.width = refCanvas0.width; wc.height = refCanvas0.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.clearRect(0,0,wc.width,wc.height);
      ctx.drawImage(refCanvas0, 0,0);
      refId = ctx.getImageData(0,0,wc.width,wc.height);
    }

    // AI detect (optional)
    let aiType = "fallback";
    let aiNote = "-";
    if(userMode === "auto"){
      await ensureAIModelsLoaded();
      await ensureCocoLoadedIfNeeded();
      try{
        const faces = faceModel ? await faceModel.estimateFaces(wc, false) : [];
        if(faces && faces.length>0){ aiType="portrait"; aiNote="AI: ì–¼êµ´ ê°ì§€"; }
        else{
          const preds = classifyModel ? await classifyModel.classify(wc) : [];
          const lsKw = ['mountain','valley','ocean','sea','beach','tree','forest','sky','nature','landscape','lake','park'];
          const isLandscape = preds?.some(p => lsKw.some(kw => (p.className||"").toLowerCase().includes(kw)));
          if(isLandscape){ aiType="landscape"; aiNote="AI: í’ê²½"; }
          else { aiType="standard"; aiNote="AI: ì¼ë°˜"; }
        }
      }catch(_){
        aiType="fallback"; aiNote="AI íŒë³„ ì‹¤íŒ¨(ìš°íšŒ)";
      }
    }

    const result = await runWorker(refId, origId, aiType, stridePx, enableSpecPoints);
    if(!result || !result.ok) throw new Error("Worker result invalid");

    // Auto FilmSim apply if ON + 1-shot
    const autoOn = (document.getElementById("autoFilmSim").value === "on");
    if(autoOn && shotMode === "one"){
      const sug = recommendFilmSimFromTarget({ ...result, aiTypeDetected: aiType });
      applyAutoSuggestionToUI(sug, "AutoFilmSim");
    }

    // PSE guard
    if(Array.isArray(result.axes)){
      result.axes = result.axes.map(ax=>{
        const avgL01 = (typeof ax.avgL01 === "number") ? ax.avgL01 : 0.5;
        return pseGuardAxisAdjust(ax, avgL01);
      });
    }

    // Apply selected preset overlay (UI)
    const presetKey = document.getElementById("fujiPreset").value;
    const strengthVal = parseInt(document.getElementById("presetStrength").value, 10);
    const strength01 = (presetKey === "off" || strengthVal===0) ? 0 : (strengthVal/100);

    let finalRes = result;

    if(presetKey !== "off" && strength01 > 0){
      const p = FUJI_PRESETS[presetKey];

      finalRes.contrast = clamp(Math.round(lerp(finalRes.contrast, p.contrast, strength01)), -4, 4);
      finalRes.sat      = clamp(Math.round(lerp(finalRes.sat,      p.sat,      strength01)), -4, 4);
      finalRes.tone     = clamp(Math.round(lerp(finalRes.tone,     p.tone,     strength01)), -4, 4);

      const pLUT = curve5ToLUT(p.curve5);
      const outLUT = new Uint8Array(256);
      for(let i=0;i<256;i++){
        outLUT[i] = clamp(Math.round(lerp(finalRes.toneLUT[i], pLUT[i], strength01)), 0, 255);
      }
      for(let i=1;i<256;i++){ if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1]; }
      finalRes.toneLUT = outLUT;

      const m = {};
      (finalRes.axes||[]).forEach(a=> m[a.axis]=a);
      ["R","Y","G","C","B","M"].forEach(k=>{
        if(!m[k] || !p.axes[k]) return;
        m[k].canonH = clamp(Math.round(lerp(m[k].canonH, p.axes[k].H, strength01)), -30, 30);
        m[k].canonS = clamp(Math.round(lerp(m[k].canonS, p.axes[k].S, strength01)), -30, 30);
        m[k].canonL = clamp(Math.round(lerp(m[k].canonL, p.axes[k].L, strength01)), -30, 30);
        m[k] = pseGuardAxisAdjust(m[k], m[k].avgL01 ?? 0.5);
      });
      finalRes.axes = ["R","Y","G","C","B","M"].map(k=>m[k]).filter(Boolean);
    }

    const curvePts = [0,64,128,192,255].map(x=>`IN ${x} â†’ OUT ${finalRes.toneLUT[x]}`);
    const curveTxt = curvePts.join("\n");
    const axesTxt = (finalRes.axes||[]).map(a=>{
      const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
      const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
      const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
      return `${a.axis}: H${H}  S${S}  L${L}`;
    }).join("\n");

    const wb = finalRes.wb;
    const wbText = wb?.ok ? `K ${wb.kelvin} Â· Shift ${wb.abLabel} / ${wb.gmLabel}` : `WB ë¶„ì„ ë¶ˆê°€`;
    const wbRel = wb?.ok ? `${Math.round((wb.reliability||0.2)*100)}%` : `ë‚®ìŒ`;

    const skin = finalRes.skin || {ratio:0};
    const exp  = finalRes.exposure || {highlightRatio:0, shadowRatio:0, note:"-"};
    const reg  = finalRes.regions || {sky:0, foliage:0};

    const shotLabel = (shotMode==="one") ? "1ì¥" : "2ì¥";
    const modeLabel = `${shotLabel} / ${modeName(userMode)}${(userMode==="auto") ? (" ("+aiNote+")") : ""}`;

    document.getElementById("sumMode").textContent = modeLabel;
    document.getElementById("sumBase").textContent =
      `${finalRes.base || "-"}${(presetKey!=="off" && strength01>0) ? (" + "+FUJI_PRESETS[presetKey].name+" "+Math.round(strength01*100)+"%") : ""}`;
    document.getElementById("sumBasic").textContent = `Contrast ${finalRes.contrast} Â· Saturation ${finalRes.sat} Â· Tone ${finalRes.tone}`;
    document.getElementById("sumLift").textContent = finalRes.lift?.isLifted ? `+${finalRes.lift.liftPx}px` : "ì—†ìŒ";
    document.getElementById("sumWB").textContent = wbText;
    document.getElementById("sumWBRel").textContent = wbRel;
    document.getElementById("sumCurve").textContent = curveTxt;
    document.getElementById("sumColors").textContent = axesTxt;

    const autoLine = (lastAutoSuggest && shotMode==="one")
      ? `Auto FilmSim: ${presetDisplayName(lastAutoSuggest.key)} ${lastAutoSuggest.strength}% (conf ${Math.round(lastAutoSuggest.confidence*100)}%)`
      : `Auto FilmSim: -`;

    document.getElementById("sumExtra").textContent =
      `Skin ${Math.round((skin.ratio||0)*100)}% Â· Regions Sky ${Math.round((reg.sky||0)*100)}% / Fol ${Math.round((reg.foliage||0)*100)}% Â· ` +
      `Exposure: ${exp.note} (Hi ${Math.round((exp.highlightRatio||0)*100)}%, Sh ${Math.round((exp.shadowRatio||0)*100)}%)\n` +
      `${autoLine}`;

    // lastRecipe for preview recipe mode
    lastRecipe = {
      name: "LastRecipe",
      contrast: finalRes.contrast,
      sat: finalRes.sat,
      tone: finalRes.tone,
      toneLUT: finalRes.toneLUT,
      axes: (finalRes.axes||[]).map(a=>({axis:a.axis, canonH:a.canonH, canonS:a.canonS, canonL:a.canonL, avgL01:a.avgL01 ?? 0.5})),
      specificPoints: finalRes.specificPoints || [],
      baseHint: `${finalRes.base || "-"}${(presetKey!=="off" && strength01>0) ? (" + "+FUJI_PRESETS[presetKey].name+" "+Math.round(strength01*100)+"%") : ""}`,
      wb: finalRes.wb,
      meta: `Last analysis (${modeLabel})`,
      matrix: null,
      satDamp: null,
      colorChrome: null,
      splitToning: null,
    };
    refreshPreviewReady();

    if(prevFileState && document.getElementById("previewMode").value === "recipe"){
      queuePreviewRender("analysisComplete");
    }

    summaryText =
`[Canon Recipe Generator Pro v11.5.2]
- Mode: ${modeLabel}
- Look Overlay: ${(presetKey==="off"||strength01===0)?"OFF":(FUJI_PRESETS[presetKey].name+" ("+Math.round(strength01*100)+"%)")}
- Base: ${lastRecipe.baseHint}
- Basic: Contrast ${finalRes.contrast}, Sat ${finalRes.sat}, Tone ${finalRes.tone}
- WB: ${wbText} (Rel ${wbRel})
- Regions: Sky ${Math.round((reg.sky||0)*100)}% / Fol ${Math.round((reg.foliage||0)*100)}%
- ${autoLine}

[Curve]
${curveTxt}

[6-Axis]
${axesTxt}
`;

    fullText =
`==================================================
 Canon Recipe Generator Pro v11.5.2 (EV AfterOnly)
==================================================
Shot: ${shotMode==="one"?"1-shot(target)":"2-shot(orig+target)"}
Mode: ${modeName(userMode)}${(userMode==="auto") ? (" / "+aiNote) : ""}
Look Overlay: ${(presetKey==="off"||strength01===0)?"OFF":(FUJI_PRESETS[presetKey].name+" ("+Math.round(strength01*100)+"%)")}
${autoLine}

[WB]
- ${wbText} (Rel ${wbRel})

[Basic]
- Contrast: ${finalRes.contrast}
- Saturation: ${finalRes.sat}
- Tone: ${finalRes.tone}
- Black Lift: ${finalRes.lift?.isLifted ? ("ON (+"+finalRes.lift.liftPx+"px)") : "OFF"}

[Tone Curve (INâ†’OUT)]
${curvePts.map(s=>"â€¢ "+s).join("\n")}

[6-Axis (Canon PSE H/S/L)]
${(finalRes.axes||[]).map(a=>{
  const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
  const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
  const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
  return `[${a.axis}] H:${H}  S:${S}  L:${L}`;
}).join("\n")}

==================================================`;

    document.getElementById("reportBox").textContent = fullText;
    document.getElementById("resultCard").classList.remove("hide");
    setTab("sum");
    document.getElementById("resultCard").scrollIntoView({behavior:"smooth"});

  }catch(e){
    console.error(e);
    alert(
`ì˜¤ë¥˜ ë°œìƒ.

í™•ì¸:
- HEIC/HEIFë©´ JPGë¡œ ë³€í™˜
- ì„±ëŠ¥ ë¶€ì¡±ì´ë©´ 1024 + Specific Points OFF
ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.`
    );
  }finally{
    spin.style.display = "none";
    refreshReady();
    refreshAutoPickReady();
  }
}

/* =========================================================
   Manual Auto-Pick
========================================================= */
async function autoPickFromTargetNow(){
  if(!refFileState){ alert("íƒ€ê²Ÿ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
  if(shotMode !== "one"){ alert("Auto FilmSimì€ 1ì¥(íƒ€ê²Ÿë§Œ) ëª¨ë“œì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤."); return; }

  try{
    const maxDim = parseInt(document.getElementById("maxDim").value, 10);
    const stridePx = (maxDim >= 1280) ? 8 : 10;

    const refCanvas0 = await fileToOrientedCanvas(refFileState, maxDim);
    const wc = document.getElementById("workCanvas");
    const ctx = wc.getContext("2d", {willReadFrequently:true});
    wc.width = refCanvas0.width; wc.height = refCanvas0.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.clearRect(0,0,wc.width,wc.height);
    ctx.drawImage(refCanvas0, 0,0);
    const refId = ctx.getImageData(0,0,wc.width,wc.height);

    const res = await runWorker(refId, null, "fallback", stridePx, false);
    if(!res || !res.ok) throw new Error("AutoPick worker fail");

    const sug = recommendFilmSimFromTarget({ ...res, aiTypeDetected: "fallback" });
    applyAutoSuggestionToUI(sug, "ManualPick");

  }catch(err){
    console.error(err);
    alert("Auto FilmSim ì¶”ì²œ ì‹¤íŒ¨. (ì´ë¯¸ì§€/ë¸Œë¼ìš°ì € ì œí•œ ë˜ëŠ” ë©”ëª¨ë¦¬ ë¶€ì¡±)");
  }
}

/* =========================================================
   Clipboard
========================================================= */
async function copyTextSafe(txt){
  try{
    await navigator.clipboard.writeText(txt);
    return true;
  }catch(e){
    try{
      const ta=document.createElement("textarea");
      ta.value=txt;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      ta.style.top="0";
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      return true;
    }catch(e2){
      return false;
    }
  }
}
async function copySummary(){
  if(!summaryText) return;
  const ok = await copyTextSafe(summaryText);
  alert(ok ? "ìš”ì•½ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}
async function copyFull(){
  if(!fullText) return;
  const ok = await copyTextSafe(fullText);
  alert(ok ? "ì „ì²´ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}

/* =========================================================
   Events
========================================================= */
document.getElementById("previewMode").addEventListener("change", ()=>{
  updatePreviewLabels();
  refreshPreviewReady();
  if(prevFileState) queuePreviewRender("previewModeChange");
});
document.getElementById("previewDim").addEventListener("change", ()=>{
  pvSourceCache = null;
  previewCache = null;
  refreshPreviewReady();
  if(prevFileState) queuePreviewRender("previewDimChange");
});
document.getElementById("previewStrength").addEventListener("input", ()=>{
  updatePreviewLabels();
  if(prevFileState) queuePreviewRender("previewStrength");
});
document.getElementById("previewEV").addEventListener("input", ()=>{
  updatePreviewLabels();
  if(prevFileState) queuePreviewRender("previewEV");
});
document.getElementById("btnPreviewApply").addEventListener("click", ()=>{
  if(prevFileState) queuePreviewRender("manualClick");
});
document.getElementById("btnPreviewReset").addEventListener("click", ()=>{
  split01 = 0.5;
  drawSplitFromCache();
});
document.getElementById("btnPreviewSave").addEventListener("click", ()=>{
  savePreviewPNG();
});
document.getElementById("fujiPreset").addEventListener("change", ()=>{
  updatePresetLabel();
  refreshPreviewReady();
  if(prevFileState && document.getElementById("previewMode").value === "preset"){
    queuePreviewRender("presetChange");
  }
});
document.getElementById("presetStrength").addEventListener("input", ()=>{
  updateStrengthLabel();
  updatePresetLabel();
  if(prevFileState && document.getElementById("previewMode").value === "preset"){
    queuePreviewRender("presetStrength");
  }
});
document.getElementById("aiBoost").addEventListener("change", ()=>{
  document.getElementById("aiBoostLabel").textContent = (document.getElementById("aiBoost").value==="coco") ? "ACCURACY" : "FAST";
});
document.getElementById("specPoints").addEventListener("change", ()=>{
  document.getElementById("specPointsLabel").textContent = (document.getElementById("specPoints").value==="on") ? "ON" : "OFF";
});
document.getElementById("autoFilmSim").addEventListener("change", ()=>{
  updateAutoFilmSimLabel();
  refreshAutoPickReady();
});
document.getElementById("btnAutoPick").addEventListener("click", ()=>{
  autoPickFromTargetNow();
});

/* =========================================================
   Preview: Save / Ready
========================================================= */
document.getElementById("btnPreviewSave").addEventListener("click", ()=> savePreviewPNG());

/* =========================================================
   Boot
========================================================= */
window.onload = ()=>{
  setupDropZone("dropPrev","prevFile","thumbPrev","filePrev", f=>{ prevFileState=f; });
  setupDropZone("dropOrig","origFile","thumbOrig","fileOrig", f=>{ origFileState=f; });
  setupDropZone("dropRef","refFile","thumbRef","fileRef", f=>{ refFileState=f; });

  initWorker();
  bindPreviewDrag();

  document.getElementById("fujiPreset").value = "off";
  document.getElementById("autoFilmSim").value = "off";

  updateStrengthLabel();
  updatePresetLabel();
  updateAutoFilmSimLabel();

  document.getElementById("aiBoostLabel").textContent = "FAST";
  document.getElementById("specPointsLabel").textContent = "ON";

  updatePreviewLabels();
  refreshPreviewReady();
  setPvMeta("ë¯¸ë¦¬ë³´ê¸° ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ì„¸ìš”");

  setShot("one");
  setMode("auto");
  setTab("sum");

  setAIUI("idle", "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)");

  refreshReady();
  refreshAutoPickReady();
};
</script>
</body>
</html>