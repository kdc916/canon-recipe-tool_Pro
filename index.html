<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Canon Recipe Generator Pro (v11.1.1 PSE-HSLGuard + SpecificPoints HOTFIX)</title>

  <!-- AI (ì§€ì—° ë¡œë”©) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#94a3b8; --text:#f1f5f9;
      --line:#263456; --brand:#ff3f34; --ok:#10b981; --warn:#f59e0b;
      --cyan:#06b6d4; --black:#020617; --radius: 16px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0; font-family: -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Noto Sans KR", system-ui, sans-serif;
      background: radial-gradient(1100px 520px at 15% 0%, rgba(255,63,52,0.16), transparent 60%),
                  radial-gradient(900px 520px at 85% 0%, rgba(6,182,212,0.16), transparent 60%),
                  var(--bg);
      color:var(--text);
      padding: 16px;
      line-height: 1.5;
    }
    .app{ max-width: 1020px; margin: 0 auto; padding-bottom: 48px; }
    .header{ display:flex; flex-direction:column; gap:10px; margin-bottom:18px; }
    .title h1{ margin:0; font-size:20px; letter-spacing:-0.4px; }
    .title p{ margin:6px 0 0; color:var(--muted); font-size:13px; word-break: keep-all; }

    .badges{ display:flex; gap:8px; flex-wrap:wrap; }
    .badge{
      border:1px solid var(--line); background: rgba(18,26,51,0.7);
      padding:6px 12px; border-radius:999px; font-size:11px; font-weight:800;
      display:flex; gap:6px; align-items:center;
    }
    .dot{ width:8px; height:8px; border-radius:50%; background:var(--muted); }
    .dot.ok{ background:var(--ok); } .dot.warn{ background:var(--warn); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 860px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background: rgba(18,26,51,0.86);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 12px 26px rgba(0,0,0,0.34);
      overflow:hidden;
    }
    .card-h{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid var(--line);
      background: rgba(2,6,23,0.35);
    }
    .card-h strong{ font-size:14px; }
    .step{
      font-size:12px; color:var(--muted);
      padding:4px 10px; border:1px solid var(--line);
      border-radius:999px; background: rgba(2,6,23,0.35);
      font-weight:900;
      white-space:nowrap;
    }
    .card-b{ padding:16px; }

    .seg{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:14px;
      margin-bottom:12px;
    }
    .seg .label{ color:var(--muted); font-size:12px; font-weight:900; margin-bottom:8px; }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:10px 14px;
      border-radius:999px;
      font-size:13px;
      font-weight:900;
      cursor:pointer;
      transition:0.15s;
      flex: 1 1 auto;
      text-align:center;
      user-select:none;
    }
    .chip.active{
      border-color: var(--brand);
      background: rgba(255,63,52,0.15);
      color: #ff8b86;
      box-shadow: 0 0 0 2px rgba(255,63,52,0.10) inset;
    }

    .uploader{ display:flex; flex-direction:column; gap:12px; }
    .drop{
      border:2px dashed var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:18px;
      transition: 0.15s;
      cursor:pointer;
      min-height: 140px;
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      align-items:center;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .drop.dragover{ border-color: var(--ok); background: rgba(16,185,129,0.10); }
    .drop .label{ font-weight:950; font-size:14px; }
    .drop .hint{ color:var(--muted); font-size:12px; line-height:1.45; }
    .drop input{ display:none; }
    .thumb{
      width:100%;
      display:none;
      border-radius:10px;
      max-height:140px;
      object-fit:cover;
      border:1px solid var(--line);
    }
    .filename{
      font-size:12px;
      color: var(--cyan);
      font-weight:900;
      display:none;
      word-break:break-all;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-bottom: 12px; }
    .kv{
      flex:1;
      display:flex; justify-content:space-between; align-items:center;
      font-size:13px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:10px 12px;
      border-radius:12px;
      gap:10px;
    }
    .kv b{ font-weight:950; }
    .kv select, .kv input[type="range"]{
      width: 54%;
      background: rgba(18,26,51,0.9);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-weight:800;
    }
    .kv .val{ color: var(--cyan); font-weight:950; white-space:nowrap; }

    .btn{
      border:0;
      border-radius:14px;
      padding:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      font-size:14px;
      width: 100%;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
    }
    .btn.primary{ background: var(--brand); color:white; }
    .btn.primary:active{ filter: brightness(0.92); transform: scale(0.985); }
    .btn.ghost{ background: rgba(2,6,23,0.25); border:1px solid var(--line); color: var(--text); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none !important; }

    .mini{
      color:var(--muted);
      font-size:12px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:12px;
      border-radius:12px;
      word-break: keep-all;
      line-height: 1.55;
    }

    .tabs{
      display:flex; gap:8px;
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      padding:8px;
      border-radius:14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-top:14px;
    }
    .tabs .left{ display:flex; gap:8px; flex-wrap:wrap; }
    .tab{
      border:1px solid var(--line);
      background: rgba(18,26,51,0.9);
      color: var(--text);
      padding:8px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      user-select:none;
    }
    .tab.active{
      border-color: var(--ok);
      color: var(--ok);
      box-shadow: 0 0 0 2px rgba(16,185,129,0.12) inset;
    }
    .tabHint{
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(2,6,23,0.35);
      white-space:nowrap;
    }

    .summaryCard{ display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px; }
    .pill{
      border:1px solid var(--line);
      background: rgba(2,6,23,0.25);
      border-radius:14px;
      padding:14px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .pill .k{ color:var(--muted); font-size:12px; margin-bottom:4px; }
    .pill .v{ font-weight:950; font-size: 14px; line-height:1.4; }
    .pill .v.ok{ color:var(--ok); } .pill .v.warn{ color:var(--warn); } .pill .v.cyan{ color:var(--cyan); }

    .report{
      margin-top:12px;
      background: var(--black);
      color: var(--ok);
      border:1px solid rgba(16,185,129,0.32);
      border-radius:14px;
      padding:16px;
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size:13px;
      overflow-x:auto;
      line-height:1.62;
    }

    .spinner{
      width:18px; height:18px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
      display:none;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }
    .hide{ display:none !important; }
    canvas{ display:none; }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="title">
        <h1>ğŸ“· Canon Recipe Generator Pro <span style="color:var(--cyan); font-size:14px;">v11.1.1 HOTFIX</span></h1>
        <p>
          âœ… <b>PSE HSL Guard</b> Â· âœ… <b>Specific Points ìƒì„± ë¡œì§ ì•ˆì •í™”</b><br/>
          v11.1.1: í¬ì¸íŠ¸ê°€ 0ê°œë¡œ ë–¨ì–´ì§€ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ <b>ì„ê³„ê°’ ìë™ ì™„í™” + ê¸€ë¡œë²Œ ë°±ì—… í¬ì¸íŠ¸</b> + <b>0ê°œ ì‚¬ìœ  í‘œì‹œ</b>ë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.
        </p>
      </div>
      <div class="badges">
        <div class="badge"><span id="dotAI" class="dot warn"></span><span id="aiText">AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)</span></div>
        <div class="badge"><span id="dotO" class="dot"></span> ì›ë³¸(ì„ íƒ)</div>
        <div class="badge"><span id="dotR" class="dot"></span> íƒ€ê²Ÿ(í•„ìˆ˜)</div>
      </div>
    </div>

    <div class="grid">
      <!-- STEP 1 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 1. ì‚¬ì§„ ë„£ê¸°</strong>
          <span class="step">1/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ë°©ì‹</div>
            <div class="chips">
              <div class="chip active" data-shot="one" onclick="setShot('one')">1ì¥ ëª¨ë“œ (íƒ€ê²Ÿë§Œ)</div>
              <div class="chip" data-shot="two" onclick="setShot('two')">2ì¥ ëª¨ë“œ (ì›ë³¸+íƒ€ê²Ÿ)</div>
            </div>
          </div>

          <div class="uploader">
            <div class="drop hide" id="dropOrig">
              <div class="label">ì›ë³¸ (ì¶”ì²œ: Standard/Neutral)</div>
              <div class="hint">ìºë…¼ í‘œì¤€/ë‰´íŠ¸ëŸ´ë¡œ ì°ì€ ì›ë³¸ ì‚¬ì§„</div>
              <input id="origFile" type="file" accept="image/*"/>
              <img id="thumbOrig" class="thumb" alt="orig"/>
              <div id="fileOrig" class="filename"></div>
            </div>

            <div class="drop" id="dropRef">
              <div class="label">íƒ€ê²Ÿ (ì›í•˜ëŠ” ìƒ‰ê°)</div>
              <div class="hint">
                ë§Œë“¤ê³  ì‹¶ì€ ì˜í™”/í•„ë¦„ ëŠë‚Œì˜ ì°¸ê³  ì‚¬ì§„.<br/>
                <b>ì£¼ì˜:</b> iPhone <b>HEIC</b>ëŠ” <b>JPGë¡œ ë³€í™˜</b> í›„ ì—…ë¡œë“œ ê¶Œì¥.
              </div>
              <input id="refFile" type="file" accept="image/*"/>
              <img id="thumbRef" class="thumb" alt="ref"/>
              <div id="fileRef" class="filename"></div>
            </div>
          </div>

          <div class="mini" style="margin-top:12px;">
            <b>Specific Points</b>ëŠ” <b>2ì¥ ëª¨ë“œ</b>ì—ì„œ ê°€ì¥ ì˜ ìƒì„±ë©ë‹ˆë‹¤. (ì›ë³¸/íƒ€ê²Ÿì´ â€œë¹„ìŠ·í•œ ì¥ë©´â€ì¼ìˆ˜ë¡ ì¢‹ìŒ)
          </div>
        </div>
      </div>

      <!-- STEP 2 -->
      <div class="card">
        <div class="card-h">
          <strong>STEP 2. ì„¤ì •</strong>
          <span class="step">2/3</span>
        </div>
        <div class="card-b">
          <div class="seg">
            <div class="label">ë¶„ì„ ëª¨ë“œ (í„°ì¹˜)</div>
            <div class="chips">
              <div class="chip active" data-mode="auto" onclick="setMode('auto')">AI ìë™</div>
              <div class="chip" data-mode="portrait" onclick="setMode('portrait')">ì¸ë¬¼</div>
              <div class="chip" data-mode="landscape" onclick="setMode('landscape')">í’ê²½</div>
              <div class="chip" data-mode="snap" onclick="setMode('snap')">ìŠ¤ëƒ…</div>
              <div class="chip" data-mode="night" onclick="setMode('night')">ì•¼ê²½</div>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í•´ìƒë„</b>
              <select id="maxDim">
                <option value="1024" selected>1024px (ê¶Œì¥)</option>
                <option value="1280">1280px (ì •ë°€)</option>
              </select>
              <span class="val">ë¦¬ì‚¬ì´ì¦ˆ ë¶„ì„</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>AI ê°•í™”(ì„ íƒ)</b>
              <select id="aiBoost">
                <option value="off" selected>OFF (ë¹ ë¦„)</option>
                <option value="coco">ON: COCO-SSD (ì •í™•â†‘, ë¬´ê±°ì›€)</option>
              </select>
              <span class="val" id="aiBoostLabel">FAST</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Specific Points</b>
              <select id="specPoints">
                <option value="on" selected>ON (ê¶Œì¥)</option>
                <option value="off">OFF</option>
              </select>
              <span class="val" id="specPointsLabel">ON</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>Look Overlay</b>
              <select id="fujiPreset">
                <option value="off" selected>Off (ë¶„ì„ë§Œ)</option>
                <optgroup label="Fuji 5th Gen Looks">
                  <option value="classic_chrome">Fuji_ClassicChrome</option>
                  <option value="classic_negative">Fuji_ClassicNegative</option>
                  <option value="reala_ace">Fuji_RealaAce</option>
                  <option value="nostalgic_negative">Fuji_NostalgicNeg</option>
                  <option value="provia">Fuji_Provia</option>
                  <option value="astia">Fuji_Astia</option>
                  <option value="velvia">Fuji_Velvia</option>
                  <option value="eterna">Fuji_Eterna</option>
                </optgroup>
                <optgroup label="Ricoh GR Looks">
                  <option value="gr_positive">GR_Positive</option>
                </optgroup>
              </select>
              <span class="val" id="presetLabel">OFF</span>
            </div>
          </div>

          <div class="row">
            <div class="kv">
              <b>í”„ë¦¬ì…‹ ê°•ë„</b>
              <input id="presetStrength" type="range" min="0" max="100" value="50"
                     oninput="updateStrengthLabel(); updatePresetLabel(); refreshReady();"/>
              <span class="val" id="strengthLabel">50%</span>
            </div>
          </div>

          <button id="btnAnalyze" class="btn primary" onclick="analyzeAll()" disabled>
            <span id="btnText">ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”</span>
            <span id="spin" class="spinner"></span>
          </button>

          <div class="mini" style="margin-top:12px;">
            í¬ì¸íŠ¸ê°€ ì•ˆ ëœ¨ë©´: <b>2ì¥ ëª¨ë“œ + 1280</b>ë¡œ ë¨¼ì € í™•ì¸í•˜ì„¸ìš”. (v11.1.1ì€ ê·¸ë˜ë„ ëœ¨ê²Œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤ ğŸ˜)
          </div>
        </div>
      </div>

      <!-- STEP 3 -->
      <div class="card hide" style="grid-column: 1 / -1;" id="resultCard">
        <div class="card-h">
          <strong>STEP 3. ê²°ê³¼</strong>
          <span class="step" style="color:var(--ok); border-color:var(--ok);">ì™„ë£Œ</span>
        </div>
        <div class="card-b">
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; gap:10px;">
              <button class="btn ghost" onclick="copySummary()" style="flex:1;">ğŸ“‹ ìš”ì•½ ë³µì‚¬</button>
              <button class="btn ghost" onclick="copyFull()" style="flex:1;">ğŸ“‹ ì „ì²´ ë³µì‚¬</button>
            </div>
          </div>

          <div class="tabs">
            <div class="left">
              <div class="tab active" data-tab="sum" onclick="setTab('sum')">ìš”ì•½ ë³´ê¸°</div>
              <div class="tab" data-tab="full" onclick="setTab('full')">ì „ì²´ ë³´ê¸°</div>
            </div>
            <div class="tabHint" id="tabHint">ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.</div>
          </div>

          <div class="summaryCard" id="summaryBox">
            <div class="pill">
              <div>
                <div class="k">ë¶„ì„ ëª¨ë“œ</div>
                <div class="v cyan" id="sumMode">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì¶”ì²œ ë² ì´ìŠ¤</div>
                <div class="v ok" id="sumBase">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">ê¸°ë³¸ ì¡°ì •</div>
                <div class="v" id="sumBasic">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ë¸”ë™ ë¦¬í”„íŠ¸</div>
                <div class="v" id="sumLift">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">WB ì œì•ˆ</div>
                <div class="v cyan" id="sumWB">-</div>
              </div>
              <div style="text-align:right;">
                <div class="k">ì‹ ë¢°ë„</div>
                <div class="v" id="sumWBRel">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">í†¤ ì»¤ë¸Œ (IN â†’ OUT)</div>
                <div class="v" id="sumCurve" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill">
              <div>
                <div class="k">6ìƒ‰ì¶• (H / S / L)</div>
                <div class="v" id="sumColors" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="pill" id="specPill">
              <div style="width:100%;">
                <div class="k">Specific Colors Points (ìš”ì•½)</div>
                <div class="v" id="sumSpecific" style="white-space:pre-wrap; font-size:13px;">-</div>
              </div>
            </div>

            <div class="mini" id="sumExtra">-</div>
          </div>

          <div id="fullBox" class="hide">
            <div id="reportBox" class="report"></div>
          </div>

          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   State
========================================================= */
let shotMode = "one";
let userMode = "auto";
let viewTab  = "sum";

let origFileState = null;
let refFileState  = null;

let summaryText = "";
let fullText = "";

// Worker lifecycle
let worker = null;
let workerUrl = null;

// Lazy AI
let faceModel = null;
let classifyModel = null;
let cocoModel = null;
let aiState = "idle";
let aiStatusText = "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)";

/* =========================================================
   Presets (ë™ì¼)
========================================================= */
const FUJI_PRESETS = {
  off: null,
  provia: { name:"Fuji_Provia", base:"í‘œì¤€ (Standard)", contrast:+1, sat:+1, tone:0, curve5:{0:2,64:66,128:128,192:194,255:252}, axes:{ R:{H:0,S:0,L:0},Y:{H:0,S:0,L:0},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-2,L:0},M:{H:0,S:0,L:0} } },
  astia:  { name:"Fuji_Astia",  base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", contrast:-1, sat:+1, tone:+1, curve5:{0:8,64:78,128:132,192:198,255:255}, axes:{ R:{H:+2,S:-6,L:+6},Y:{H:-2,S:-6,L:+6},G:{H:0,S:0,L:0},C:{H:0,S:0,L:0},B:{H:0,S:-6,L:0},M:{H:0,S:0,L:0} } },
  classic_chrome: { name:"Fuji_ClassicChrome", base:"ë‰´íŠ¸ëŸ´ (Neutral) ë˜ëŠ” ìƒì„¸ (Fine Detail)", contrast:+2, sat:-3, tone:-1, curve5:{0:12,64:72,128:126,192:186,255:242}, axes:{ R:{H:+2,S:-10,L:+4}, Y:{H:-2,S:-18,L:+4}, G:{H:+4,S:-12,L:-2}, C:{H:-6,S:-8,L:-2}, B:{H:-8,S:-12,L:-4}, M:{H:+2,S:-6,L:0} } },
  classic_negative: { name:"Fuji_ClassicNegative", base:"ë‰´íŠ¸ëŸ´ (Neutral)", contrast:+3, sat:-2, tone:-2, curve5:{0:16,64:82,128:128,192:176,255:236}, axes:{ R:{H:-6,S:-12,L:+6}, Y:{H:-8,S:-22,L:+8}, G:{H:+10,S:+4,L:-8}, C:{H:+6,S:+6,L:-8}, B:{H:+4,S:-14,L:-8}, M:{H:+4,S:-8,L:0} } },
  reala_ace: { name:"Fuji_RealaAce", base:"í‘œì¤€ (Standard) / ì¸ë¬¼ì‚¬ì§„ (Portrait)", skinProtect:true, contrast:+2, sat:+1, tone:+1, curve5:{0:4,64:68,128:130,192:200,255:248}, axes:{ R:{H:0,S:-4,L:+3}, Y:{H:0,S:-6,L:+3}, G:{H:0,S:-2,L:0}, C:{H:+2,S:0,L:-2}, B:{H:+2,S:-2,L:-4}, M:{H:0,S:-2,L:0} } },
  nostalgic_negative: { name:"Fuji_NostalgicNeg", base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", contrast:+1, sat:-1, tone:+2, curve5:{0:14,64:84,128:136,192:194,255:244}, axes:{ R:{H:-4,S:+2,L:+6},Y:{H:-6,S:+4,L:+8},G:{H:+4,S:-8,L:0},C:{H:+6,S:-8,L:-2},B:{H:+8,S:-12,L:-4},M:{H:0,S:-4,L:0} } },
  velvia: { name:"Fuji_Velvia", base:"í’ê²½ì‚¬ì§„ (Landscape)", contrast:+3, sat:+4, tone:-1, curve5:{0:0,64:56,128:126,192:210,255:255}, axes:{ R:{H:0,S:+6,L:0},Y:{H:0,S:+10,L:+2},G:{H:-6,S:+18,L:-6},C:{H:-2,S:+12,L:-6},B:{H:-4,S:+10,L:-8},M:{H:0,S:+4,L:0} } },
  eterna: { name:"Fuji_Eterna", base:"ë‰´íŠ¸ëŸ´ (Neutral)", contrast:-2, sat:-3, tone:-1, curve5:{0:16,64:88,128:132,192:180,255:238}, axes:{ R:{H:0,S:-10,L:+2},Y:{H:0,S:-12,L:+2},G:{H:0,S:-8,L:0},C:{H:+2,S:-8,L:0},B:{H:+2,S:-8,L:0},M:{H:0,S:-8,L:0} } },
  gr_positive: { name:"GR_Positive", base:"í‘œì¤€ (Standard)", contrast:+2, sat:+2, tone:0, curve5:{0:0,64:60,128:132,192:198,255:252}, axes:{ R:{H:0,S:+8,L:0},Y:{H:-2,S:+6,L:+2},G:{H:-6,S:+2,L:-6},C:{H:+2,S:+6,L:-4},B:{H:-4,S:+10,L:-8},M:{H:0,S:0,L:0} } }
};

/* =========================================================
   UI helpers
========================================================= */
function clamp(v,a,b){ return v<a?a:(v>b?b:v); }
function lerp(a,b,t){ return a+(b-a)*t; }
function setDot(id, state){
  const el = document.getElementById(id);
  el.className = "dot" + (state ? (" " + state) : "");
}
function modeName(mode){
  if(mode==="auto") return "AIìë™";
  if(mode==="portrait") return "ì¸ë¬¼";
  if(mode==="landscape") return "í’ê²½";
  if(mode==="snap") return "ìŠ¤ëƒ…";
  if(mode==="night") return "ì•¼ê²½";
  return "ìˆ˜ë™";
}
function setTab(tab){
  viewTab = tab;
  document.querySelectorAll(".tab").forEach(el=> el.classList.toggle("active", el.dataset.tab === tab));
  const hint = document.getElementById("tabHint");
  if(tab === "sum"){
    hint.textContent = "ì´ˆë³´ììš© ìš”ì•½ ë·°ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.remove("hide");
    document.getElementById("fullBox").classList.add("hide");
  }else{
    hint.textContent = "ìƒì„¸ ë ˆì‹œí”¼ ë¦¬í¬íŠ¸ì…ë‹ˆë‹¤.";
    document.getElementById("summaryBox").classList.add("hide");
    document.getElementById("fullBox").classList.remove("hide");
  }
}
function setMode(mode){
  userMode = mode;
  document.querySelectorAll(".chip[data-mode]").forEach(el=> el.classList.toggle("active", el.dataset.mode === mode));
  refreshReady();
}
function setShot(mode){
  shotMode = mode;
  document.querySelectorAll(".chip[data-shot]").forEach(el=> el.classList.toggle("active", el.dataset.shot === mode));
  document.getElementById("dropOrig").classList.toggle("hide", shotMode !== "two");
  refreshReady();
}

function updateStrengthLabel(){
  const v = parseInt(document.getElementById("presetStrength").value, 10);
  document.getElementById("strengthLabel").textContent = v + "%";
}
function setStrengthEnabled(enabled){
  const s = document.getElementById("presetStrength");
  s.disabled = !enabled;
  s.style.opacity = enabled ? "1" : "0.5";
}
function updatePresetLabel(){
  const key = document.getElementById("fujiPreset").value;
  const strength = parseInt(document.getElementById("presetStrength").value, 10);
  if(key === "off"){
    document.getElementById("presetLabel").textContent = "OFF";
    setStrengthEnabled(false);
    return;
  }
  setStrengthEnabled(true);
  const name = FUJI_PRESETS[key]?.name || "LookPreset";
  const extra = FUJI_PRESETS[key]?.skinProtect ? " Â· SkinSafe" : "";
  document.getElementById("presetLabel").textContent = `ON: ${name}${extra} (${strength}%)`;
}
document.getElementById("fujiPreset").addEventListener("change", ()=>{ updatePresetLabel(); refreshReady(); });

document.getElementById("aiBoost").addEventListener("change", ()=>{
  const v = document.getElementById("aiBoost").value;
  document.getElementById("aiBoostLabel").textContent = (v==="coco") ? "ACCURACY" : "FAST";
});
document.getElementById("specPoints").addEventListener("change", ()=>{
  const v = document.getElementById("specPoints").value;
  document.getElementById("specPointsLabel").textContent = (v==="on") ? "ON" : "OFF";
});

/* =========================================================
   HEIC / EXIF
========================================================= */
function isHeicFile(file){
  const name = (file?.name || "").toLowerCase();
  const type = (file?.type || "").toLowerCase();
  return (name.endsWith(".heic") || name.endsWith(".heif") || type.includes("heic") || type.includes("heif"));
}
function maybeWarnHeic(file){
  if(isHeicFile(file)){
    alert("âš ï¸ HEIC/HEIF íŒŒì¼ì€ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë¦¬ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”.\nJPGë¡œ ë³€í™˜ í›„ ì¬ì‹œë„í•´ ì£¼ì„¸ìš”.");
  }
}
async function getExifOrientation(file){
  try{
    const name = (file?.name || "").toLowerCase();
    const type = (file?.type || "").toLowerCase();
    const isJpeg = type.includes("jpeg") || type.includes("jpg") || name.endsWith(".jpg") || name.endsWith(".jpeg");
    if(!isJpeg) return 1;

    const buf = await file.slice(0, 256 * 1024).arrayBuffer();
    const view = new DataView(buf);
    if(view.getUint16(0, false) !== 0xFFD8) return 1;

    let offset = 2;
    const length = view.byteLength;
    while(offset < length){
      if(view.getUint8(offset) !== 0xFF) break;
      const marker = view.getUint8(offset + 1);
      offset += 2;
      if(marker === 0xD9 || marker === 0xDA) break;

      const segLen = view.getUint16(offset, false);
      if(segLen < 2) break;

      if(marker === 0xE1){
        const start = offset + 2;
        if(start + 6 <= length){
          const isExif =
            view.getUint8(start+0)===0x45 && view.getUint8(start+1)===0x78 &&
            view.getUint8(start+2)===0x69 && view.getUint8(start+3)===0x66;
          if(isExif){
            const tiff = start + 6;
            const endian = view.getUint16(tiff, false);
            const little = (endian === 0x4949);
            const getU16 = (o)=> view.getUint16(o, little);
            const getU32 = (o)=> view.getUint32(o, little);
            const magic = getU16(tiff + 2);
            if(magic !== 0x002A) return 1;
            const ifd0Offset = getU32(tiff + 4);
            let ifd0 = tiff + ifd0Offset;
            const entries = getU16(ifd0);
            ifd0 += 2;
            for(let i=0;i<entries;i++){
              const ent = ifd0 + i*12;
              const tag = getU16(ent + 0);
              if(tag === 0x0112){
                const val = getU16(ent + 8);
                return val || 1;
              }
            }
          }
        }
      }
      offset += segLen;
    }
    return 1;
  }catch(e){ return 1; }
}

/* =========================================================
   Upload
========================================================= */
function setupDropZone(dropId, inputId, thumbId, nameId, onSetFile){
  const drop = document.getElementById(dropId);
  const input = document.getElementById(inputId);
  const thumb = document.getElementById(thumbId);
  const nameEl = document.getElementById(nameId);

  drop.addEventListener("click", ()=> input.click());
  drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("dragover"); });
  drop.addEventListener("dragleave", ()=> drop.classList.remove("dragover"));
  drop.addEventListener("drop", (e)=>{
    e.preventDefault(); drop.classList.remove("dragover");
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreview(f, thumb, nameEl);
      refreshReady();
    }
  });
  input.addEventListener("change", ()=>{
    const f = input.files && input.files[0];
    if(f){
      maybeWarnHeic(f);
      onSetFile(f);
      updatePreview(f, thumb, nameEl);
      refreshReady();
    }
  });
}
function updatePreview(file, imgEl, nameEl){
  nameEl.textContent = "âœ… " + file.name;
  nameEl.style.display = "block";
  const r = new FileReader();
  r.onload = (e)=>{ imgEl.src = e.target.result; imgEl.style.display = "block"; };
  r.readAsDataURL(file);
}

/* =========================================================
   AI load (lazy)
========================================================= */
function setAIUI(state, text){
  const dot = document.getElementById("dotAI");
  const label = document.getElementById("aiText");
  aiState = state;
  aiStatusText = text || aiStatusText;
  dot.className = (state === "ready") ? "dot ok" : "dot warn";
  label.textContent = aiStatusText;
}
async function ensureAIModelsLoaded(){
  if(aiState === "ready") return true;
  if(aiState === "loading") return false;

  setAIUI("loading", "AI ë¡œë”©ì¤‘â€¦(ìë™ ëª¨ë“œ)");
  try{
    await tf.ready();
    faceModel = await blazeface.load();
    classifyModel = await mobilenet.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ");
    return true;
  }catch(e){
    console.warn(e);
    setAIUI("failed", "AI ì‹¤íŒ¨(ìš°íšŒ) Â· ìˆ˜ë™/ëŒ€ì²´ë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}
async function ensureCocoLoadedIfNeeded(){
  const need = (document.getElementById("aiBoost").value === "coco");
  if(!need) return false;
  if(cocoModel) return true;
  try{
    setAIUI("loading", "AI+ (COCO-SSD) ë¡œë”©ì¤‘â€¦");
    await new Promise((resolve, reject)=>{
      const s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js";
      s.onload = resolve;
      s.onerror = reject;
      document.head.appendChild(s);
    });
    cocoModel = await cocoSsd.load();
    setAIUI("ready", "AI ì¤€ë¹„ì™„ë£Œ + COCO-SSD");
    return true;
  }catch(e){
    console.warn("COCO-SSD ë¡œë”© ì‹¤íŒ¨:", e);
    setAIUI("failed", "COCO-SSD ì‹¤íŒ¨(ìš°íšŒ) Â· ê¸°ë³¸ AIë¡œ ì§„í–‰");
    return false;
  }finally{
    refreshReady();
  }
}

/* =========================================================
   Ready
========================================================= */
function refreshReady(){
  const hasRef = !!refFileState;
  const hasOrig = !!origFileState;

  setDot("dotR", hasRef ? "ok" : "");
  setDot("dotO", (shotMode === "two" && hasOrig) ? "ok" : "");

  const btn = document.getElementById("btnAnalyze");
  const btnText = document.getElementById("btnText");

  const readyForShot = (shotMode === "one") ? hasRef : (hasRef && hasOrig);
  btn.disabled = !readyForShot;

  if(!readyForShot){ btnText.textContent = "ì‚¬ì§„ì„ ë„£ì–´ì£¼ì„¸ìš”"; return; }
  btnText.textContent = (userMode === "auto" && aiState !== "ready") ? "âš¡ ë¶„ì„ ì‹œì‘ (í•„ìš” ì‹œ AI ë¡œë”©)" : "âš¡ ë¶„ì„ ì‹œì‘";
}

/* =========================================================
   Image decode + resize
========================================================= */
async function fileToHTMLImage(file){
  return await new Promise((resolve, reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}
async function decodeToImageBitmap(file){
  try{
    if(typeof createImageBitmap === "function") return await createImageBitmap(file);
    throw new Error("createImageBitmap not available");
  }catch(e){
    return await fileToHTMLImage(file);
  }
}
function applyOrientationTransform(ctx, orientation, w, h){
  switch(orientation){
    case 2: ctx.translate(w, 0); ctx.scale(-1, 1); break;
    case 3: ctx.translate(w, h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0, h); ctx.scale(1, -1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1, -1); break;
    case 6: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); break;
    case 7: ctx.translate(w, 0); ctx.rotate(0.5*Math.PI); ctx.scale(-1, 1); break;
    case 8: ctx.translate(0, h); ctx.rotate(-0.5*Math.PI); break;
  }
}
function drawScaledToCanvas(bitmapOrImg, maxDim, orientation=1){
  const ow = bitmapOrImg.width;
  const oh = bitmapOrImg.height;
  if(orientation === 5 || orientation === 7) orientation = 1;

  const swapWH = (orientation>=5 && orientation<=8);
  const rw = swapWH ? oh : ow;
  const rh = swapWH ? ow : oh;

  const scale = Math.min(1, maxDim / Math.max(rw, rh));
  const tw = Math.max(1, Math.round(rw * scale));
  const th = Math.max(1, Math.round(rh * scale));

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  canvas.width = tw; canvas.height = th;

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,tw,th);

  ctx.save();
  applyOrientationTransform(ctx, orientation, tw, th);
  if(swapWH) ctx.drawImage(bitmapOrImg, 0, 0, th, tw);
  else ctx.drawImage(bitmapOrImg, 0, 0, tw, th);
  ctx.restore();
  ctx.restore();

  return {canvas, ctx, tw, th};
}
function canvasToImageData(){
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  return ctx.getImageData(0,0,canvas.width, canvas.height);
}
function drawBitmapToFixedSize(bitmapOrImg, w, h){
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", {willReadFrequently:true});
  canvas.width = w; canvas.height = h;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(bitmapOrImg, 0, 0, w, h);
  return ctx.getImageData(0,0,w,h);
}

/* =========================================================
   âœ… PSE HSL Guard
========================================================= */
function pseConeMaxS01(l01){
  const t = Math.abs(2*l01 - 1);
  return clamp(1 - t, 0, 1);
}
function pseGuardAxisAdjust(axis, avgL01){
  const cone = pseConeMaxS01(avgL01);
  const scale = clamp(0.35 + 0.65*cone, 0.35, 1.0);

  let s = axis.canonS;
  const absS = Math.abs(s);
  const softCap = Math.round(30 * clamp(cone*1.15, 0.15, 1.0));
  if(absS > softCap){
    s = Math.round(Math.sign(s) * (softCap + (absS-softCap)*0.25));
  }
  s = Math.round(s * scale);

  let l = axis.canonL;
  const lScale = clamp(0.55 + 0.45*cone, 0.55, 1.0);
  l = Math.round(l * lScale);

  return {...axis, canonS: clamp(s,-30,30), canonL: clamp(l,-30,30)};
}

/* =========================================================
   Overlay helpers
========================================================= */
function curve5ToLUT(curve5){
  const xs = [0,64,128,192,255];
  const ys = xs.map(x => clamp(Math.round(curve5[x]), 0, 255));
  const lut = new Uint8Array(256);
  for(let i=0;i<xs.length-1;i++){
    const x0=xs[i], x1=xs[i+1];
    const y0=ys[i], y1=ys[i+1];
    const dx = (x1 - x0);
    for(let x=x0; x<=x1; x++){
      const t = dx === 0 ? 0 : (x - x0) / dx;
      lut[x] = clamp(Math.round(lerp(y0, y1, t)), 0, 255);
    }
  }
  for(let i=1;i<256;i++){ if(lut[i] < lut[i-1]) lut[i] = lut[i-1]; }
  return lut;
}
function isPortraitLike(baseStr){
  const s = (baseStr || "").toLowerCase();
  return s.includes("portrait") || s.includes("ì¸ë¬¼");
}
function applyHighlightKnee(lut, kneeStart, kneeStrength){
  if(kneeStrength <= 0) return lut;
  const out = new Uint8Array(256);
  for(let i=0;i<256;i++){
    let v = lut[i];
    if(i >= kneeStart){
      const t = (i - kneeStart) / (255 - kneeStart + 1e-6);
      const compress = 1.0 - kneeStrength * (0.35 + 0.65*t);
      v = Math.round(kneeStart + (v - kneeStart) * compress);
    }
    out[i] = clamp(v, 0, 255);
    if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
  }
  return out;
}
function realaSkinAxisStrength(strength01, skinRatio){
  const s = clamp(skinRatio || 0, 0, 0.35) / 0.35;
  const factor = clamp(0.55 - 0.33*s, 0.22, 0.55);
  return strength01 * factor;
}
function normalizeAnalysis(result){
  const safe = (v, d)=> (v===undefined || v===null) ? d : v;
  return {
    contrast: clamp(parseInt(safe(result.contrast,0),10)||0, -4, 4),
    sat:      clamp(parseInt(safe(result.sat,0),10)||0, -4, 4),
    tone:     clamp(parseInt(safe(result.tone,0),10)||0, -4, 4),
    toneLUT:  safe(result.toneLUT, new Uint8Array(256).map((_,i)=>i)),
    axes:     Array.isArray(result.axes) ? result.axes : [],
    lift:     safe(result.lift, {isLifted:false, strength:0, liftPx:0}),
    base:     safe(result.base, "í‘œì¤€ (Standard)"),
    baseReason: safe(result.baseReason, "-"),
    warnings: Array.isArray(result.warnings) ? result.warnings : [],
    wb:       safe(result.wb, {ok:false, kelvin:0, abLabel:"0", gmLabel:"0", reliability:0.2, note:"-"}),
    skin:     safe(result.skin, {ratio:0, highlightRisk:0, sampled:0, source:"none"}),
    exposure: safe(result.exposure, {shadowRatio:0, highlightRatio:0, midRatio:0, note:"-"}),
    regions:  safe(result.regions, {sky:0, foliage:0, skin:0, valid:0}),
    specificPoints: Array.isArray(result.specificPoints) ? result.specificPoints : [],
    spDebug:  safe(result.spDebug, {enabled:false, minCount:0, stepPx:0, candidates:0, picked:0, fallbackPicked:0, note:"-"}),
    aiTypeDetected: safe(result.aiTypeDetected, "fallback"),
    aiNote:   safe(result.aiNote, "-"),
    cocoTop:  safe(result.cocoTop, null),
    sceneHint: safe(result.sceneHint, {kind:"unknown", note:"-"}),
    baseHint: safe(result.baseHint, safe(result.base,"í‘œì¤€ (Standard)"))
  };
}
function applyFujiOverlay(analysisIn, presetKey, strength01){
  const analysis = normalizeAnalysis(analysisIn);
  if(!presetKey || presetKey === "off" || !FUJI_PRESETS[presetKey] || strength01 <= 0){
    analysis.baseHint = analysis.base;
    return analysis;
  }

  const p = FUJI_PRESETS[presetKey];
  const portraitLike = (analysis.aiTypeDetected === "portrait") || isPortraitLike(analysis.base);
  const skinRatio = analysis.skin?.ratio || 0;
  const hlRisk = analysis.skin?.highlightRisk || analysis.exposure?.highlightRatio || 0;

  const outContrast = clamp(Math.round(lerp(analysis.contrast, p.contrast, strength01)), -4, 4);
  const outSat      = clamp(Math.round(lerp(analysis.sat,      p.sat,      strength01)), -4, 4);
  const outTone     = clamp(Math.round(lerp(analysis.tone,     p.tone,     strength01)), -4, 4);

  const pLUT = curve5ToLUT(p.curve5);
  let outLUT = new Uint8Array(256);
  for(let i=0;i<256;i++){
    outLUT[i] = clamp(Math.round(lerp(analysis.toneLUT[i], pLUT[i], strength01)), 0, 255);
  }
  for(let i=1;i<256;i++){ if(outLUT[i] < outLUT[i-1]) outLUT[i] = outLUT[i-1]; }

  if(p.skinProtect){
    const baseKneeStart = portraitLike ? 195 : 205;
    const kneeStart = clamp(Math.round(baseKneeStart - 12 * clamp(hlRisk,0,1)), 182, 210);

    let kneeStrength = strength01 * (portraitLike ? 0.55 : 0.42);
    kneeStrength *= (1.0 + 0.65*clamp(skinRatio/0.20, 0, 1));
    kneeStrength *= (1.0 + 0.55*clamp(hlRisk, 0, 1));
    kneeStrength = clamp(kneeStrength, 0, 0.42);

    outLUT = applyHighlightKnee(outLUT, kneeStart, kneeStrength);
  }

  const outAxes = analysis.axes.map(ax=>{
    const key = ax.axis;
    const pa = p.axes?.[key];
    if(!pa) return {...ax};

    let axisStrength = strength01;
    if(presetKey === "reala_ace" && (key === "R" || key === "Y")){
      axisStrength = realaSkinAxisStrength(axisStrength, skinRatio);
    }
    if(p.skinProtect && portraitLike && (key === "R" || key === "Y")){
      axisStrength = Math.min(axisStrength, strength01 * 0.45);
    }

    const targetH = clamp(Math.round(lerp(ax.canonH, pa.H, axisStrength)), -30, 30);
    const safeH = (p.skinProtect && (key==="R"||key==="Y") && (portraitLike || skinRatio > 0.03))
      ? clamp(targetH, -10, +10)
      : targetH;

    return {
      ...ax,
      canonH: safeH,
      canonS: clamp(Math.round(lerp(ax.canonS, pa.S, axisStrength)), -30, 30),
      canonL: clamp(Math.round(lerp(ax.canonL, pa.L, axisStrength)), -30, 30),
    };
  });

  analysis.baseHint = `${analysis.base} + ${p.name}${p.skinProtect ? " SkinSafe" : ""} ${Math.round(strength01*100)}%`;
  return {...analysis, contrast: outContrast, sat: outSat, tone: outTone, toneLUT: outLUT, axes: outAxes};
}

/* =========================================================
   Worker lifecycle
========================================================= */
function terminateWorker(){
  try{ if(worker){ worker.terminate(); worker = null; } }catch(e){}
  try{ if(workerUrl){ URL.revokeObjectURL(workerUrl); workerUrl = null; } }catch(e){}
}
window.addEventListener("beforeunload", ()=> terminateWorker());

function initWorker(){
  if(worker) return;

  const code = `
    function clamp(v,a,b){ return v<a?a:(v>b?b:v); }

    function rgbToHsl01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0;
      const l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, l];
    }
    function rgbToHsv01(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0;
      const s = max===0 ? 0 : d/max;
      const v = max;
      if(d!==0){
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h, s, v];
    }

    function srgbToLin(u){
      u/=255;
      return (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
    }
    function linRgbToXyz(lr,lg,lb){
      const X = lr*0.4124564 + lg*0.3575761 + lb*0.1804375;
      const Y = lr*0.2126729 + lg*0.7151522 + lb*0.0721750;
      const Z = lr*0.0193339 + lg*0.1191920 + lb*0.9503041;
      return [X,Y,Z];
    }
    function xyToCct(x,y){
      const n = (x - 0.3320) / (y - 0.1858 + 1e-9);
      const cct = 449*n*n*n + 3525*n*n + 6823.3*n + 5520.33;
      return cct;
    }
    function xyToUv(x,y){
      const denom = (-2*x + 12*y + 3);
      const u = (4*x) / (denom + 1e-9);
      const v = (9*y) / (denom + 1e-9);
      return [u,v];
    }
    function wbShiftFromUv(u,v){
      const u0 = 0.1978398, v0 = 0.4683363;
      const du = u - u0;
      const dv = v - v0;
      let ab = clamp(Math.round(-du * 250), -9, 9);
      let gm = clamp(Math.round(dv * 250), -9, 9);
      const abLabel = (ab>0) ? ("A" + ab) : (ab<0 ? ("B" + (-ab)) : "0");
      const gmLabel = (gm>0) ? ("G" + gm) : (gm<0 ? ("M" + (-gm)) : "0");
      const mag = Math.sqrt(du*du + dv*dv);
      const rel = clamp((mag*120), 0.15, 1.0);
      return {ab, gm, abLabel, gmLabel, rel};
    }
    function circularHueDiff(h2,h1){
      let d=(h2-h1)%360;
      if(d>180) d-=360;
      if(d<=-180) d+=360;
      return d;
    }

    function luminanceHistFromRGBA(rgba, stridePx){
      const hist = new Uint32Array(256);
      let total=0, tooDark=0, tooBright=0;
      const step = 4 * Math.max(1, stridePx|0);
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) | 0;
        hist[lum]++; total++;
        if(lum<=10) tooDark++;
        if(lum>=245) tooBright++;
      }
      return {hist,total,tooDark,tooBright};
    }
    function uniformHist(){
      const hist = new Uint32Array(256);
      for(let i=0;i<256;i++) hist[i]=1;
      return {hist,total:256,tooDark:0,tooBright:0};
    }
    function cdfFromHist(hist,total){
      const cdf = new Float32Array(256);
      let acc=0;
      for(let i=0;i<256;i++){ acc += hist[i]; cdf[i] = acc/total; }
      return cdf;
    }
    function buildToneLUTByCDFMatch(cdfO,cdfR){
      const lut = new Uint8Array(256);
      let j=0;
      for(let i=0;i<256;i++){
        const p = cdfO[i];
        while(j<255 && cdfR[j] < p) j++;
        lut[i]=j;
      }
      return lut;
    }
    function percentileByHist(hist,total,p){
      const target = total*p;
      let acc=0;
      for(let i=0;i<256;i++){
        acc+=hist[i];
        if(acc>=target) return i;
      }
      return 255;
    }
    function applyBlackLiftCompensation(lut, refP02){
      const liftRaw = Math.max(0, refP02 - 10);
      const strength = Math.max(0, Math.min(1, liftRaw/22));
      const liftPx = Math.round(6 + 18*strength);
      const out = new Uint8Array(256);
      for(let i=0;i<256;i++){
        let boost = 0;
        if(i < 128) boost = liftPx * (1 - (i/128));
        out[i] = Math.min(255, lut[i] + boost);
        if(i>0 && out[i] < out[i-1]) out[i] = out[i-1];
      }
      return {lut: out, strength, liftPx, isLifted: strength>=0.20};
    }

    function estimateExposure(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sh=0, hi=0, mid=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 50) sh++;
        else if(y > 205) hi++;
        else mid++;
        n++;
      }
      if(n<=0) return {shadowRatio:0, highlightRatio:0, midRatio:0, note:"-"};
      const sr = sh/n, hr = hi/n, mr = mid/n;
      let note = "Balanced";
      if(hr>0.35) note = "Highlight heavy";
      if(sr>0.35) note = "Shadow heavy";
      if(hr>0.30 && sr>0.30) note = "Extreme contrast";
      return {shadowRatio:sr, highlightRatio:hr, midRatio:mr, note};
    }

    function estimateRegions(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sky=0, fol=0, skin=0, valid=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 18 || y > 245) continue;

        const hsv = rgbToHsv01(r,g,b);
        const hDeg = hsv[0]*360;
        const s = hsv[1], v = hsv[2];
        if(s < 0.10) continue;

        valid++;
        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        const isSky = (hDeg >= 190 && hDeg <= 245 && s >= 0.18 && v >= 0.22);
        const isFol = (hDeg >= 70 && hDeg <= 160 && s >= 0.18 && v >= 0.18);
        if(isSkin) skin++;
        if(isSky)  sky++;
        if(isFol)  fol++;
      }
      if(valid <= 0) return {sky:0, foliage:0, skin:0, valid:0};
      return { sky: clamp(sky/valid,0,1), foliage: clamp(fol/valid,0,1), skin: clamp(skin/valid,0,1), valid };
    }

    function estimateSkinGlobal(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let skin=0, total=0, hi=0, hiTotal=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const y = 0.299*r + 0.587*g + 0.114*b;
        if(y < 28 || y > 245) continue;
        const hsv = rgbToHsv01(r,g,b);
        if(hsv[1] < 0.10) continue;

        const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
        const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;

        total++;
        const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173);
        if(isSkin){
          skin++;
          if(y >= 210) hi++;
        }
        if(y >= 210) hiTotal++;
      }
      const ratio = total>0 ? (skin/total) : 0;
      const highlightRisk = hiTotal>0 ? (hi/hiTotal) : 0;
      return {ratio: clamp(ratio,0,1), highlightRisk: clamp(highlightRisk,0,1), sampled: total, source:"global"};
    }

    function estimateWB(rgba, stridePx){
      const step = 4 * Math.max(1, stridePx|0);
      let sumX=0, sumY=0, sumZ=0, n=0;
      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(lum < 18 || lum > 245) continue;
        const xyz = linRgbToXyz(srgbToLin(r), srgbToLin(g), srgbToLin(b));
        sumX += xyz[0]; sumY += xyz[1]; sumZ += xyz[2]; n++;
      }
      if(n < 300) return {ok:false, kelvin: 0, abLabel:"0", gmLabel:"0", reliability:0.15, note:"ìƒ˜í”Œ ë¶€ì¡±"};
      const X = sumX/n, Y = sumY/n, Z = sumZ/n;
      const denom = (X+Y+Z) + 1e-9;
      let cct = xyToCct(X/denom, Y/denom);
      if(!isFinite(cct)) cct = 5200;
      const uv = xyToUv(X/denom, Y/denom);
      const sh = wbShiftFromUv(uv[0], uv[1]);
      const reliability = clamp(0.55*clamp(n/6000, 0.2, 1.0) + 0.45*sh.rel, 0.2, 1.0);
      return {ok:true, kelvin: clamp(Math.round(cct/10)*10, 2000, 10000), ab: sh.ab, gm: sh.gm, abLabel: sh.abLabel, gmLabel: sh.gmLabel, reliability, note: "íƒ€ê²Ÿ í‰ê·  ê¸°ë°˜" };
    }

    function getColorAxesDataWeighted(rgba, stridePx){
      const buckets = {
        R:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        Y:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        G:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        C:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        B:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
        M:{sumCos:0,sumSin:0,sumS:0,sumL:0,wSum:0,count:0},
      };

      let valid=0;
      let sumS=0, sumTone=0, toneN=0;

      const step = 4 * Math.max(1, stridePx|0);

      for(let i=0;i<rgba.length;i+=step){
        const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
        const hsl = rgbToHsl01(r,g,b);
        let h=hsl[0]*360, s=hsl[1], l=hsl[2];

        if(s < 0.08) continue;
        if(l < 0.06 || l > 0.94) continue;

        let k='M';
        if(h>=340 || h<20) k='R';
        else if(h>=20 && h<80) k='Y';
        else if(h>=80 && h<150) k='G';
        else if(h>=150 && h<210) k='C';
        else if(h>=210 && h<280) k='B';
        else k='M';

        const wS = Math.pow(s, 1.5);
        const wL = 1.0 - Math.min(0.8, Math.abs(l-0.5)*1.6);
        const w = Math.max(0.01, wS*wL);

        const rad = h*Math.PI/180;
        const bk = buckets[k];
        bk.sumCos += Math.cos(rad)*w;
        bk.sumSin += Math.sin(rad)*w;
        bk.sumS += s*w;
        bk.sumL += l*w;
        bk.wSum += w;
        bk.count++;
        valid++;

        sumS += s;
        sumTone += Math.sin(rad);
        toneN++;
      }

      const out={};
      for(const k in buckets){
        const b=buckets[k];
        if(b.wSum>0){
          let hh = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
          if(hh<0) hh+=360;
          out[k]={H:hh, S:b.sumS/b.wSum, L:b.sumL/b.wSum, count:b.count};
        } else {
          out[k]={H:0,S:0,L:0,count:0};
        }
      }

      const avgS = toneN>0 ? (sumS/toneN) : 0;
      const avgTone = toneN>0 ? (sumTone/toneN) : 0;

      return {axes: out, validColored: valid, avgS, avgTone};
    }

    // ========= Specific Points v11.1.1 =========
    function regionMaskType(r,g,b){
      const y = 0.299*r + 0.587*g + 0.114*b;
      const hsv = rgbToHsv01(r,g,b);
      const hDeg = hsv[0]*360;
      const s = hsv[1], v = hsv[2];

      const cb = 128 - 0.168736*r - 0.331264*g + 0.5*b;
      const cr = 128 + 0.5*r - 0.418688*g - 0.081312*b;
      const isSkin = (cb >= 77 && cb <= 127 && cr >= 133 && cr <= 173) && (s >= 0.10) && (v >= 0.12);

      const isSky = (hDeg >= 190 && hDeg <= 245 && s >= 0.18 && v >= 0.22);
      const isFol = (hDeg >= 70 && hDeg <= 160 && s >= 0.18 && v >= 0.18);

      if(isSkin) return 0;
      if(isSky)  return 1;
      if(isFol)  return 2;
      if(y < 60) return 3;
      if(y > 200) return 4;
      return 5;
    }

    function initBins(regionCount, hueBins){
      const bins = [];
      for(let r=0;r<regionCount;r++){
        const arr = [];
        for(let h=0;h<hueBins;h++){
          arr.push({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0});
        }
        bins.push(arr);
      }
      return bins;
    }
    function pushBin(bins, region, hueIdx, hDeg, s, l){
      const b = bins[region][hueIdx];
      const rad = hDeg*Math.PI/180;
      b.sumCos += Math.cos(rad);
      b.sumSin += Math.sin(rad);
      b.sumS += s;
      b.sumL += l;
      b.count += 1;
    }
    function binToMean(b){
      if(b.count<=0) return null;
      let hDeg = Math.atan2(b.sumSin, b.sumCos) * 180/Math.PI;
      if(hDeg < 0) hDeg += 360;
      return {hDeg, s01: b.sumS/b.count, l01: b.sumL/b.count, count: b.count};
    }

    function computeMinCount(stridePx, pixelCount){
      // v11.1ì˜ 220ì€ ëª¨ë°”ì¼/strideì—ì„œ ë„ˆë¬´ ë¹¡ì…ˆ â†’ ìë™ ì™„í™”
      // - stride 10(1024 ê¶Œì¥): 70~110
      // - stride 8(1280 ì •ë°€): 90~140
      const base = (stridePx <= 8) ? 110 : 85;
      const scale = clamp(Math.sqrt(pixelCount / 700000), 0.75, 1.25);
      return Math.round(base * scale);
    }

    function buildSpecificPoints(origRGBA, refRGBA, stridePx){
      const regionCount = 6;
      const hueBins = 24;
      const binsO = initBins(regionCount, hueBins);
      const binsR = initBins(regionCount, hueBins);

      const stepPx = Math.max(1, stridePx|0);
      const step = 4 * stepPx;

      for(let i=0;i<origRGBA.length;i+=step){
        const r=origRGBA[i], g=origRGBA[i+1], b=origRGBA[i+2];
        const hsl = rgbToHsl01(r,g,b);
        const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
        if(s < 0.08 || l < 0.04 || l > 0.96) continue;
        const reg = regionMaskType(r,g,b);
        const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
        pushBin(binsO, reg, hi, hDeg, s, l);
      }
      for(let i=0;i<refRGBA.length;i+=step){
        const r=refRGBA[i], g=refRGBA[i+1], b=refRGBA[i+2];
        const hsl = rgbToHsl01(r,g,b);
        const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
        if(s < 0.08 || l < 0.04 || l > 0.96) continue;
        const reg = regionMaskType(r,g,b);
        const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
        pushBin(binsR, reg, hi, hDeg, s, l);
      }

      const pixelCount = Math.max(origRGBA.length, refRGBA.length) / 4;
      const minCount = computeMinCount(stepPx, pixelCount);

      const regionNames = ["SKIN","SKY","FOLIAGE","SHADOW","HIGHLIGHT","MID"];
      const regionPriority = {SKIN:0, SKY:1, FOLIAGE:2, MID:3, SHADOW:4, HIGHLIGHT:5};

      let candidates = 0;
      const points = [];
      for(let reg=0; reg<regionCount; reg++){
        for(let hi=0; hi<hueBins; hi++){
          const mo = binToMean(binsO[reg][hi]);
          const mr = binToMean(binsR[reg][hi]);
          if(!mo || !mr) continue;
          candidates++;
          if(mo.count < minCount || mr.count < minCount) continue;

          points.push({
            region: regionNames[reg],
            inH: mo.hDeg, inS: mo.s01, inL: mo.l01,
            outH: mr.hDeg, outS: mr.s01, outL: mr.l01,
            countO: mo.count, countR: mr.count,
            weight: (mo.count + mr.count) * 0.5
          });
        }
      }

      points.sort((a,b)=>{
        const pr = (regionPriority[a.region]||9) - (regionPriority[b.region]||9);
        if(pr!==0) return pr;
        return (b.weight||0) - (a.weight||0);
      });

      const picked = points.slice(0, 36);

      // âœ… ë°±ì—…: ì§€ì—­ ë§¤ì¹­ì´ ë„ˆë¬´ ì•ˆ ë˜ë©´ "ê¸€ë¡œë²Œ(HUE-bin)" í¬ì¸íŠ¸ë¥¼ ìƒì„±
      let fallbackPicked = [];
      if(picked.length < 6){
        // ê¸€ë¡œë²Œì€ regionCount=1ì²˜ëŸ¼ MIDë¡œ í•©ì³ì„œ ì²˜ë¦¬
        const gO = new Array(hueBins).fill(0).map(()=>({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0}));
        const gR = new Array(hueBins).fill(0).map(()=>({sumCos:0,sumSin:0,sumS:0,sumL:0,count:0}));

        for(let i=0;i<origRGBA.length;i+=step){
          const r=origRGBA[i], g=origRGBA[i+1], b=origRGBA[i+2];
          const hsl = rgbToHsl01(r,g,b);
          const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
          if(s < 0.08 || l < 0.05 || l > 0.95) continue;
          const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
          pushBin([gO], 0, hi, hDeg, s, l);
        }
        for(let i=0;i<refRGBA.length;i+=step){
          const r=refRGBA[i], g=refRGBA[i+1], b=refRGBA[i+2];
          const hsl = rgbToHsl01(r,g,b);
          const hDeg = hsl[0]*360, s=hsl[1], l=hsl[2];
          if(s < 0.08 || l < 0.05 || l > 0.95) continue;
          const hi = clamp((hsl[0]*hueBins)|0, 0, hueBins-1);
          pushBin([gR], 0, hi, hDeg, s, l);
        }

        // fallbackëŠ” ë” ì™„í™”ëœ threshold
        const minCount2 = Math.max(35, Math.round(minCount * 0.55));

        const tmp = [];
        for(let hi=0; hi<hueBins; hi++){
          const mo = binToMean(gO[hi]);
          const mr = binToMean(gR[hi]);
          if(!mo || !mr) continue;
          if(mo.count < minCount2 || mr.count < minCount2) continue;
          tmp.push({
            region: "GLOBAL",
            inH: mo.hDeg, inS: mo.s01, inL: mo.l01,
            outH: mr.hDeg, outS: mr.s01, outL: mr.l01,
            countO: mo.count, countR: mr.count,
            weight: (mo.count + mr.count) * 0.5
          });
        }
        tmp.sort((a,b)=> (b.weight||0)-(a.weight||0));
        fallbackPicked = tmp.slice(0, 18);
      }

      const final = (picked.length >= 6) ? picked : (picked.concat(fallbackPicked)).slice(0, 24);

      const note =
        (picked.length>=6) ? "region OK"
        : (fallbackPicked.length>0 ? "fallback GLOBAL used" : "no valid bins");

      return {
        points: final,
        debug: { enabled:true, minCount, stepPx, candidates, picked: picked.length, fallbackPicked: fallbackPicked.length, note }
      };
    }

    function baseRecommend(mode, aiType, axesR, totalColored, contrast, sceneHint){
      if(mode !== "auto"){
        if(mode==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"ìˆ˜ë™"};
        if(mode==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"ìˆ˜ë™"};
        if(mode==="night") return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ìˆ˜ë™"};
        if(mode==="snap") return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
        return {base:"í‘œì¤€ (Standard)", reason:"ìˆ˜ë™"};
      }
      if(aiType==="portrait") return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"AI ê°ì§€"};
      if(aiType==="landscape") return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"AI ê°ì§€"};
      if(totalColored < 1500) return {base:"ëª¨ë…¸í¬ë¡¬ (Monochrome)", reason:"ìƒ‰ìƒ ë°ì´í„° ì ìŒ"};
      if((axesR.R.count + axesR.Y.count) > totalColored*0.55) return {base:"ì¸ë¬¼ì‚¬ì§„ (Portrait)", reason:"R/Y ë¹„ì¤‘"};
      if((axesR.G.count + axesR.B.count + axesR.C.count) > totalColored*0.45) return {base:"í’ê²½ì‚¬ì§„ (Landscape)", reason:"G/B/C ë¹„ì¤‘"};
      if(contrast <= -2) return {base:"ë‰´íŠ¸ëŸ´ (Neutral)", reason:"ê³„ì¡° í™•ë³´"};
      return {base:"í‘œì¤€ (Standard)", reason:"ë²”ìš©"};
    }

    self.onmessage = (e)=>{
      const {origBuf, refBuf, hasOrig, aiType, mode, stridePx, sceneHint, enableSpecPoints} = e.data;
      const stride = Math.max(1, stridePx|0);

      const refRGBA = new Uint8ClampedArray(refBuf);
      const origRGBA = hasOrig ? new Uint8ClampedArray(origBuf) : null;

      const r = luminanceHistFromRGBA(refRGBA, stride);
      const o = hasOrig ? luminanceHistFromRGBA(origRGBA, stride) : uniformHist();

      let lut = buildToneLUTByCDFMatch(cdfFromHist(o.hist, o.total), cdfFromHist(r.hist, r.total));
      const lift = applyBlackLiftCompensation(lut, percentileByHist(r.hist, r.total, 0.02));
      lut = lift.lut;

      const oRange = Math.max(1, percentileByHist(o.hist, o.total, 0.95) - percentileByHist(o.hist, o.total, 0.05));
      const rRange = Math.max(1, percentileByHist(r.hist, r.total, 0.95) - percentileByHist(r.hist, r.total, 0.05));
      let contrast = clamp(Math.round(((rRange/oRange)-1)*6), -4, 4);

      const exposure = estimateExposure(refRGBA, stride);
      if(exposure.note === "Extreme contrast") contrast = clamp(contrast - 1, -4, 4);

      const cR = getColorAxesDataWeighted(refRGBA, stride);
      const axesR = cR.axes;
      const axesO = hasOrig ? getColorAxesDataWeighted(origRGBA, stride).axes : {
        R:{H:0,S:0.24,L:0.50,count:9999},
        Y:{H:60,S:0.24,L:0.50,count:9999},
        G:{H:120,S:0.24,L:0.50,count:9999},
        C:{H:180,S:0.24,L:0.50,count:9999},
        B:{H:240,S:0.24,L:0.50,count:9999},
        M:{H:300,S:0.24,L:0.50,count:9999},
      };

      const keys = ['R','Y','G','C','B','M'];
      const names = ["Red","Yellow","Green","Cyan","Blue","Magenta"];
      const axesOut = [];
      for(let i=0;i<6;i++){
        const k = keys[i];
        const rA = axesR[k];
        const oA = axesO[k];

        const countR = rA.count || 0;
        const reliability = clamp(Math.sqrt(countR / 2000), 0.20, 1.0);

        const diffH = circularHueDiff(rA.H, oA.H);
        const diffS = (rA.S - oA.S) * 100;
        const diffL = (rA.L - oA.L) * 100;

        axesOut.push({
          axis: k,
          label: names[i],
          canonH: clamp(Math.round((diffH/6.0) * reliability), -30, 30),
          canonS: clamp(Math.round((diffS/10.0) * reliability), -30, 30),
          canonL: clamp(Math.round((diffL/10.0) * reliability), -30, 30),
          avgL01: clamp(rA.L || 0.5, 0, 1),
          countR
        });
      }

      const baseRec = baseRecommend(mode, aiType, axesR, cR.validColored, contrast, sceneHint);

      const warnings = [];
      const darkRatio = r.tooDark / r.total;
      const brightRatio = r.tooBright / r.total;
      if(darkRatio > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ì–´ë‘¡ìŠµë‹ˆë‹¤(ì•”ë¶€ ë¹„ì¤‘â†‘). ê²°ê³¼ ì‹ ë¢°ë„ê°€ ë‚®ì•„ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      if(brightRatio > 0.35) warnings.push("íƒ€ê²Ÿì´ ë§¤ìš° ë°ìŠµë‹ˆë‹¤(ëª…ë¶€ ë¹„ì¤‘â†‘). í†¤ì»¤ë¸Œê°€ ë‹¨ìˆœí™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      if(cR.validColored < 1500) warnings.push("ìœ íš¨ ìƒ‰ìƒ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤(ì €ì±„ë„/ë¬´ì±„ìƒ‰). 6ìƒ‰ì¶•ì€ ì°¸ê³ ìš©ì…ë‹ˆë‹¤.");

      const wb = estimateWB(refRGBA, stride);
      const skin = estimateSkinGlobal(refRGBA, stride);
      const regions = estimateRegions(refRGBA, stride);

      let specificPoints = [];
      let spDebug = {enabled:false, minCount:0, stepPx:stride, candidates:0, picked:0, fallbackPicked:0, note:"-"};

      if(enableSpecPoints){
        if(hasOrig){
          const res = buildSpecificPoints(origRGBA, refRGBA, stride);
          specificPoints = res.points || [];
          spDebug = res.debug || spDebug;
          if(specificPoints.length === 0){
            warnings.push("Specific Points: í¬ì¸íŠ¸ 0ê°œ. (v11.1.1ì€ ë°±ì—…ê¹Œì§€ ì‹œë„í–ˆì§€ë§Œ ìƒ˜í”Œì´ ë„ˆë¬´ ë¶€ì¡±í•œ ì¼€ì´ìŠ¤)");
          }
        }else{
          warnings.push("Specific Points: 2ì¥ ëª¨ë“œì—ì„œë§Œ ìƒì„±ë©ë‹ˆë‹¤. (ì›ë³¸+íƒ€ê²Ÿ í•„ìš”)");
          spDebug = {enabled:true, minCount:0, stepPx:stride, candidates:0, picked:0, fallbackPicked:0, note:"need 2-shot"};
        }
      }

      self.postMessage({
        ok:true,
        contrast,
        sat: clamp(Math.round((cR.avgS - 0.45) * 10), -4, 4),
        tone: clamp(Math.round(cR.avgTone * 4), -4, 4),
        toneLUT: lut,
        lift: {isLifted: lift.isLifted, strength: lift.strength, liftPx: lift.liftPx},
        base: baseRec.base,
        baseReason: baseRec.reason,
        axes: axesOut,
        warnings,
        wb,
        skin,
        exposure,
        regions,
        specificPoints,
        spDebug,
        aiTypeDetected: aiType
      });
    };
  `;

  workerUrl = URL.createObjectURL(new Blob([code], {type:"application/javascript"}));
  worker = new Worker(workerUrl);
  Promise.resolve().then(()=>{ try{ URL.revokeObjectURL(workerUrl); workerUrl = null; }catch(e){} });
}

/* =========================================================
   AI detection (ê°„ë‹¨)
========================================================= */
async function detectAiType(canvas){
  if(userMode !== "auto") return {type:"manual", note:"ìˆ˜ë™"};
  if(!faceModel || !classifyModel) return {type:"fallback", note: aiStatusText};

  try{
    const faces = await faceModel.estimateFaces(canvas, false);
    if(faces && faces.length > 0) return {type:"portrait", note:`AI: ì–¼êµ´ ê°ì§€`};

    const preds = await classifyModel.classify(canvas);
    const lsKw = ['mountain','valley','ocean','sea','beach','tree','forest','sky','nature','landscape','lake','park'];
    const isLandscape = preds?.some(p => lsKw.some(kw => (p.className||"").toLowerCase().includes(kw)));
    if(isLandscape) return {type:"landscape", note:`AI: í’ê²½`};
    return {type:"standard", note:`AI: ì¼ë°˜`};
  }catch(e){
    return {type:"fallback", note:"AI íŒë³„ ì‹¤íŒ¨(ìš°íšŒ)"};
  }
}
async function cocoDetectTopIfEnabled(canvas){
  if(!cocoModel) return null;
  try{
    const preds = await cocoModel.detect(canvas);
    if(!preds || !preds.length) return null;
    preds.sort((a,b)=> (b.score||0)-(a.score||0));
    const top = preds[0];
    const bb = top.bbox || [0,0,0,0];
    const area = Math.max(0, bb[2]) * Math.max(0, bb[3]);
    const imgArea = Math.max(1, canvas.width * canvas.height);
    const areaRatio = clamp(area / imgArea, 0, 1);
    return {class: top.class, score: top.score || 0, bbox: bb, areaRatio};
  }catch(e){
    return null;
  }
}
function buildSceneHint(cocoTop){
  if(!cocoTop) return {kind:"unknown", note:"-"};
  const c = (cocoTop.class || "").toLowerCase();
  const s = cocoTop.score || 0;
  const ar = cocoTop.areaRatio || 0;
  return {kind:"object", note:`COCO:${c} (${Math.round(s*100)}%, area ${Math.round(ar*100)}%)`};
}

/* =========================================================
   Specific points formatting (PSE cone clamp)
========================================================= */
function pseClampPointS01(s01, l01){
  const maxS = pseConeMaxS01(l01);
  return clamp(s01, 0, maxS);
}
function fmtPct01(x){ return `${Math.round(clamp(x,0,1)*100)}%`; }
function fmtDeg(x){ return `${Math.round(((x%360)+360)%360)}Â°`; }

function formatSpecificPoints(points){
  if(!points || !points.length) return {summary:"", full:""};
  const lines = points.slice(0, 10).map((p, idx)=>{
    const inS = pseClampPointS01(p.inS, p.inL);
    const outS = pseClampPointS01(p.outS, p.outL);
    return `${idx+1}) [${p.region}] IN(${fmtDeg(p.inH)}, ${fmtPct01(inS)}, ${fmtPct01(p.inL)}) â†’ OUT(${fmtDeg(p.outH)}, ${fmtPct01(outS)}, ${fmtPct01(p.outL)})`;
  });
  const full = points.map((p, idx)=>{
    const inS = pseClampPointS01(p.inS, p.inL);
    const outS = pseClampPointS01(p.outS, p.outL);
    return `${idx+1}) [${p.region}] IN(H ${fmtDeg(p.inH)} / S ${fmtPct01(inS)} / L ${fmtPct01(p.inL)})  â†’  OUT(H ${fmtDeg(p.outH)} / S ${fmtPct01(outS)} / L ${fmtPct01(p.outL)})  (nO ${p.countO}, nR ${p.countR})`;
  }).join("\n");
  return {summary: lines.join("\n"), full};
}

/* =========================================================
   Analyze
========================================================= */
async function analyzeAll(){
  const btn = document.getElementById("btnAnalyze");
  const spin = document.getElementById("spin");
  const btnText = document.getElementById("btnText");

  if(!refFileState){ alert("íƒ€ê²Ÿ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
  if(shotMode==="two" && !origFileState){ alert("2ì¥ ëª¨ë“œì—ì„œëŠ” ì›ë³¸ ì‚¬ì§„ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }

  btn.disabled = true;
  spin.style.display = "inline-block";
  btnText.textContent = "ë¶„ì„ ì¤‘â€¦";
  document.getElementById("resultCard").classList.add("hide");

  try{
    const maxDim = parseInt(document.getElementById("maxDim").value, 10);
    const stridePx = (maxDim >= 1280) ? 8 : 10;
    const enableSpecPoints = (document.getElementById("specPoints").value === "on");

    initWorker();

    // ref
    const refOri = await getExifOrientation(refFileState);
    const bmR = await decodeToImageBitmap(refFileState);
    const refCanvasInfo = drawScaledToCanvas(bmR, maxDim, refOri);
    const refId = canvasToImageData();

    // AI
    let ai = {type:"fallback", note:"-"};
    let cocoTop = null;
    let sceneHint = {kind:"unknown", note:"-"};

    if(userMode === "auto"){
      await ensureAIModelsLoaded();
      await ensureCocoLoadedIfNeeded();

      ai = await detectAiType(refCanvasInfo.canvas);

      if(cocoModel){
        cocoTop = await cocoDetectTopIfEnabled(refCanvasInfo.canvas);
        sceneHint = buildSceneHint(cocoTop);

        // person ìŠ¹ê²© ì•ˆì •í™”(ê¸°ë³¸)
        if(cocoTop && cocoTop.class === "person"){
          const scoreOK = (cocoTop.score || 0) >= 0.65;
          const areaOK  = (cocoTop.areaRatio || 0) >= 0.08;
          if(scoreOK && areaOK){
            ai = {type:"portrait", note:`AI: ì‚¬ëŒ(person) ê°ì§€(ì•ˆì •)`};
          }
        }
      }
    }

    // orig (ref size ê°•ì œ)
    let origId = null;
    if(shotMode === "two"){
      const origOri = await getExifOrientation(origFileState);
      const bmO = await decodeToImageBitmap(origFileState);
      const w = refCanvasInfo.tw, h = refCanvasInfo.th;
      const tmp = drawScaledToCanvas(bmO, maxDim, origOri);
      origId = drawBitmapToFixedSize(tmp.canvas, w, h);
      drawBitmapToFixedSize(bmR, w, h);
    }

    // Worker
    const result = await new Promise((resolve, reject)=>{
      const onMsg = (ev)=>{ cleanup(); resolve(ev.data); };
      const onErr = (err)=>{ cleanup(); reject(err); };
      const cleanup = ()=>{
        worker.removeEventListener("message", onMsg);
        worker.removeEventListener("error", onErr);
      };
      worker.addEventListener("message", onMsg);
      worker.addEventListener("error", onErr);

      const refBuf = refId.data.buffer;
      if(origId){
        const origBuf = origId.data.buffer;
        worker.postMessage(
          { origBuf, refBuf, hasOrig:true, aiType:ai.type, mode:userMode, stridePx, sceneHint, enableSpecPoints },
          [origBuf, refBuf]
        );
      }else{
        worker.postMessage(
          { refBuf, hasOrig:false, aiType:ai.type, mode:userMode, stridePx, sceneHint, enableSpecPoints },
          [refBuf]
        );
      }
    });

    if(!result || !result.ok) throw new Error("Worker result invalid");

    result.aiTypeDetected = ai.type;
    result.aiNote = ai.note;
    result.cocoTop = cocoTop;
    result.sceneHint = sceneHint;

    // âœ… PSE HSL Guard ì ìš©
    if(Array.isArray(result.axes)){
      result.axes = result.axes.map(ax=>{
        const avgL01 = (typeof ax.avgL01 === "number") ? ax.avgL01 : 0.5;
        return pseGuardAxisAdjust(ax, avgL01);
      });
    }

    // Overlay (optional)
    const presetKey = document.getElementById("fujiPreset").value;
    const strengthVal = parseInt(document.getElementById("presetStrength").value, 10);
    const strength01 = (presetKey === "off" || strengthVal===0) ? 0 : (strengthVal/100);
    const finalRes = applyFujiOverlay(result, presetKey, strength01);

    // UI strings
    const pts = [0,64,128,192,255].map(x=>`IN ${x} â†’ OUT ${finalRes.toneLUT[x]}`);
    const curveTxt = pts.join("\n");

    const axesTxt = finalRes.axes.map(a=>{
      const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
      const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
      const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
      return `${a.axis}: H${H}  S${S}  L${L}`;
    }).join("\n");

    const wb = finalRes.wb;
    const wbText = wb?.ok ? `K ${wb.kelvin} Â· Shift ${wb.abLabel} / ${wb.gmLabel}` : `WB ë¶„ì„ ë¶ˆê°€`;
    const wbRel = wb?.ok ? `${Math.round((wb.reliability||0.2)*100)}%` : `ë‚®ìŒ`;

    const reg  = finalRes.regions || {sky:0, foliage:0, skin:0, valid:0};
    const exp  = finalRes.exposure || {note:"-", highlightRatio:0, shadowRatio:0};
    const spDbg = finalRes.spDebug || {enabled:false, note:"-"};

    const shotLabel = (shotMode==="one") ? "1ì¥" : "2ì¥";
    const modeLabel = `${shotLabel} / ${modeName(userMode)}${(userMode==="auto") ? (" ("+finalRes.aiNote+")") : ""}`;

    // Specific points display + 0ê°œ ì‚¬ìœ 
    const sp = formatSpecificPoints(finalRes.specificPoints || []);
    document.getElementById("specPill").classList.toggle("hide", !enableSpecPoints);

    if(!enableSpecPoints){
      document.getElementById("sumSpecific").textContent = "-";
    }else if(shotMode !== "two"){
      document.getElementById("sumSpecific").textContent = "2ì¥ ëª¨ë“œì—ì„œë§Œ ìƒì„±ë©ë‹ˆë‹¤. (ì›ë³¸+íƒ€ê²Ÿ í•„ìš”)";
    }else if((finalRes.specificPoints||[]).length === 0){
      document.getElementById("sumSpecific").textContent =
        `í¬ì¸íŠ¸ 0ê°œ\n- ì›ì¸: ìƒ‰ ìƒ˜í”Œ ë¶€ì¡±/ì¥ë©´ ì°¨ì´/ì €ì±„ë„\n- ë””ë²„ê·¸: minCount ${spDbg.minCount || "?"}, stepPx ${spDbg.stepPx || "?"}, cand ${spDbg.candidates || "?"}, note ${spDbg.note || "-"}`;
    }else{
      document.getElementById("sumSpecific").textContent =
        sp.summary + `\n\n[dbg] minCount ${spDbg.minCount}, stepPx ${spDbg.stepPx}, picked ${spDbg.picked}, fallback ${spDbg.fallbackPicked}, note ${spDbg.note}`;
    }

    // Render
    document.getElementById("sumMode").textContent = modeLabel;
    document.getElementById("sumBase").textContent = finalRes.baseHint || finalRes.base || "-";
    document.getElementById("sumBasic").textContent = `Contrast ${finalRes.contrast} Â· Saturation ${finalRes.sat} Â· Tone ${finalRes.tone}`;
    document.getElementById("sumLift").textContent = finalRes.lift?.isLifted ? `+${finalRes.lift.liftPx}px` : "ì—†ìŒ";
    document.getElementById("sumWB").textContent = wbText;
    document.getElementById("sumWBRel").textContent = wbRel;
    document.getElementById("sumCurve").textContent = curveTxt;
    document.getElementById("sumColors").textContent = axesTxt;

    const cocoLine = finalRes.cocoTop
      ? `COCO Top: ${finalRes.cocoTop.class} (${Math.round(finalRes.cocoTop.score*100)}%) area ${Math.round(finalRes.cocoTop.areaRatio*100)}%`
      : `COCO Top: -`;

    document.getElementById("sumExtra").textContent =
      `PSE-HSLGuard: ON Â· Regions Sky ${Math.round((reg.sky||0)*100)}% / Fol ${Math.round((reg.foliage||0)*100)}% Â· ` +
      `Exposure: ${exp.note} (Hi ${Math.round((exp.highlightRatio||0)*100)}%, Sh ${Math.round((exp.shadowRatio||0)*100)}%) Â· ` +
      `${cocoLine}`;

    const presetLabel = (presetKey==="off" || strength01===0)
      ? "Look Overlay: OFF"
      : `Look Overlay: ${FUJI_PRESETS[presetKey].name} (${Math.round(strength01*100)}%)`;

    summaryText =
`[Canon Recipe Generator Pro v11.1.1]
- Mode: ${modeLabel}
- ${presetLabel}
- Base: ${finalRes.baseHint || finalRes.base}
- Basic: Contrast ${finalRes.contrast}, Sat ${finalRes.sat}, Tone ${finalRes.tone}
- WB: ${wbText} (Rel ${wbRel})
- PSE-HSLGuard: ON
- Regions: Sky ${Math.round((reg.sky||0)*100)}% / Fol ${Math.round((reg.foliage||0)*100)}%
- ${cocoLine}

[Curve]
${curveTxt}

[6-Axis]
${axesTxt}
`;

    const warnBlock = (finalRes.warnings && finalRes.warnings.length)
      ? ("[âš ï¸ Warnings]\n" + finalRes.warnings.map((w,i)=>`${i+1}) ${w}`).join("\n") + "\n\n")
      : "";

    const spFullBlock = (enableSpecPoints && shotMode==="two" && (finalRes.specificPoints||[]).length)
      ? (`[Specific Colors Points]\n${sp.full}\n\n`)
      : "";

    fullText =
`==================================================
 Canon Recipe Generator Pro v11.1.1 (HOTFIX)
==================================================
Shot: ${shotMode==="one"?"1-shot(target)":"2-shot(orig+target)"}
Mode: ${modeName(userMode)}${(userMode==="auto") ? (" / "+finalRes.aiNote) : ""}
${presetLabel}
${cocoLine}

${warnBlock}[WB]
- ${wbText} (Rel ${wbRel})

[Base]
- ${finalRes.baseHint || finalRes.base}
- Reason: ${finalRes.baseReason || "-"}

[Basic]
- Contrast: ${finalRes.contrast}
- Saturation: ${finalRes.sat}
- Tone: ${finalRes.tone}
- Black Lift: ${finalRes.lift?.isLifted ? ("ON (+"+finalRes.lift.liftPx+"px)") : "OFF"}

[Tone Curve]
${pts.map(s=>"â€¢ "+s).join("\n")}

[6-Axis (PSE-HSLGuard Applied)]
${finalRes.axes.map(a=>{
  const H = (a.canonH>0?`+${a.canonH}`:`${a.canonH}`);
  const S = (a.canonS>0?`+${a.canonS}`:`${a.canonS}`);
  const L = (a.canonL>0?`+${a.canonL}`:`${a.canonL}`);
  return `[${a.axis}] H:${H}  S:${S}  L:${L}`;
}).join("\n")}

[SpecificPoints Debug]
- enabled: ${spDbg.enabled}
- minCount: ${spDbg.minCount}
- stepPx: ${spDbg.stepPx}
- candidates: ${spDbg.candidates}
- picked: ${spDbg.picked}
- fallbackPicked: ${spDbg.fallbackPicked}
- note: ${spDbg.note}

${spFullBlock}==================================================`;

    document.getElementById("reportBox").textContent = fullText;

    document.getElementById("resultCard").classList.remove("hide");
    setTab("sum");
    document.getElementById("resultCard").scrollIntoView({behavior:"smooth"});
  }catch(e){
    console.error(e);
    alert(
`ì˜¤ë¥˜ ë°œìƒ.

í™•ì¸:
- HEIC/HEIFë©´ JPGë¡œ ë³€í™˜
- ì„±ëŠ¥ ë¶€ì¡±ì´ë©´ 1024 + Specific Points OFF
ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.`
    );
  }finally{
    spin.style.display = "none";
    refreshReady();
  }
}

/* =========================================================
   Copy (clipboard fallback)
========================================================= */
async function copyTextSafe(txt){
  try{
    await navigator.clipboard.writeText(txt);
    return true;
  }catch(e){
    try{
      const ta=document.createElement("textarea");
      ta.value=txt;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      ta.style.top="0";
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      return true;
    }catch(e2){
      return false;
    }
  }
}
async function copySummary(){
  if(!summaryText) return;
  const ok = await copyTextSafe(summaryText);
  alert(ok ? "ìš”ì•½ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}
async function copyFull(){
  if(!fullText) return;
  const ok = await copyTextSafe(fullText);
  alert(ok ? "ì „ì²´ ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨(ê¶Œí•œ í™•ì¸)");
}

/* =========================================================
   Boot
========================================================= */
window.onload = ()=>{
  setupDropZone("dropOrig","origFile","thumbOrig","fileOrig", f=>origFileState=f);
  setupDropZone("dropRef","refFile","thumbRef","fileRef", f=>refFileState=f);

  initWorker();

  // Look Overlay ê¸°ë³¸ê°’ OFF
  document.getElementById("fujiPreset").value = "off";
  updateStrengthLabel();
  updatePresetLabel();

  document.getElementById("aiBoostLabel").textContent = "FAST";
  document.getElementById("specPointsLabel").textContent = "ON";

  setShot("one");
  setMode("auto");
  setTab("sum");

  setAIUI("idle", "AI ë¯¸ë¡œë”© (ìë™ ì‹œ ë¶„ì„ ë•Œ ë¡œë”©)");
  refreshReady();
};
</script>
</body>
</html>